---
layout: post
title: scaffolding
categories: Promramming
categories: TODO
---

http://jeonghwan-kim.github.io/2017/10/22/js-context-binding.html


```jsx
function hello() {
  console.log(this.name);
}

var obj = {
  name: 'chris',
  hello: hello
};

helloFn = obj.hello;

name = 'global context!'

helloFn(); // 'chris'일까 'global context!'일까?
```
obj 객체의 프로퍼티에 hello() 함수를 할당했지만, helloFn에 레퍼런스를 저장하는 순간 이것은 일반 함수가 된다.
따라서 일반함수 helloFn()을 호출하면 기본 바인딩 규칙을 따르게 된다. 함수를 실행하는 순간 글로벌 컨택스트가 this에 바인딩되고 this.name은 obj.name이 아닌 글로벌 객체의 name인 ‘global context!’를 바라보게 되는 것이다.


명시적 바인딩
좀 더 직관적으로 “난 객체를 컨택스트로 바인딩 할거야!”라고 코드에 의도를 나타내는 방법은 없을까? 그리고 타임아웃 함수에 넘겨준 콜백함수 문제도 해결하는 방법은 없을까?

자바스크립트의 call(), apply(), bind() 함수가 그런 역할을 하는 내장 함수들이다. call()과 apply() 함수는 실행할 함수 인자를 넘기는 방식만 다를뿐, 컨텍스트 객체를 명시한다는 점에서 동일한 함수다.

----
해당 내용은 다음 글을 참고 하였습니다.
- 
---
layout: post
title: ES6의 새로운 기능들
tags:
  - ES6
  - ECMA2015
categories: Javascript
---

## 소개
현재 javascript는 1999년 ES3를 시작이래로 비동기 프로그래밍이 가능한 async, await가 추가된 ES8(ECMA2017)이 최신입니다. 이 글에서는 ES5(2009)이후 가장 많은 업데이트가 일어난 ES6(ECMA2015)에 추가된 새로운 기능들을 정리하고자 합니다. 문법의 큰 변화로 인해 진입장벽이 높다면 높을 수 있기 때문에 front 개발자라면 꼭 공부해야 합니다. ES6의 새로운 기능들을 살펴 봅시다!

## 기능 목록 
ES6의 기능들을 정리하면 다음과 같습니다.

1. 기본 매개 변수: 함수에 넘겨주는 인자값에 대한 기본값을 합수의 매개변수에서 정의 해 줄 수 있다. 
2. 템플릿 리터럴: 변수와 문자열의 +연산자의 복잡한 조합 대신 `(back-ticed) 안에 ${NAME} 로 구문을 정리하여 간단하게 사용 가능하다.
3. 멀티 라인 문자열: 기존 멀티라인을 처리하기 위해 사용하던 +'\n' 대신 `(back-ticed) 문자열로 멀티 라인을 묶어 주면 간단하게 처리 할 수 있다.
4. 비구조화 할당: 구조화된 데이터(json)의 프로퍼티를 변수에 각각 할당받아 처리할 필요 없이 {,,}을 사용하여 한꺼번에 할당이 가능하다. 이 때 주의점은 할당하려는 변수와 구조화된 데이터의 프로퍼티명을 같게 할 것. 구조화된 데이터는 {}, 배열은 []를 사용하여 한번에 할당이 가능하다. 특히 함수에서 매개변수의 일부만 입력으로 받고 싶을때 유용하다.
5. 향상된 객체 리터럴: 객체 리터럴 정의시 __proto__ 속성을 사용하여 바로 프로토 타입설정(상속목적)이 가능하다. 속성이름과 할당하는 값이 동일한 경우 속성명만을 정의하여 할당 가능한 단축 표기법을 제공한다. (key:value 대신 key만을 정의함) 또한. 동적으로 속명명을 정의하는 것이 가능하다. 즉, 객체 생성이 편리 해 졌다.
6. 화살표 함수: 항상 익명함수로 정의되며 this의 값을 현재 문맥에 바인딩 시킨다. 자신을 포함한 외부 scop에서 this를 계승(lexical scope) 받는다. 따라서 주의 사항으로는, 객체의 메소드 정의시 화살표 함수를 사용하게 되면 함수안의 this는 전역객체를 바인딩하게 되므로 객체의 메소드 정의 방법으로 정의해야 한다. 생성자 함수로도 사용하지 않는다.
7. promise: Promise는 비동기 프로그래밍을 위한 라이브러리이다. 콜백지옥에서 벗어 날 수 있다. 
8. 블록 범위 생성자 let, const: let은 블록 유효 범위로 지정되며, const는 상수 정의시에 사용한다.
9. 클래스: class 키워드를 사용하여 protorype기반 상속 보다 명확하게 클래스를 정의할 수 있다(객체 지향 패턴). et과 set, static 키워드를 사용해 메소드 정의가 가능하다. 상속시 부모생성자를 호출하기 위해 super()를 사용할 수 있다.
10. 모듈: 컴포넌트 정의를 위한 모듈을 지원한다. 기존에는 모듈사용에 대한 공식적인 방법이 없었기 때문에 비공식적으로 JavaScript 모듈 로더들 AMD, CommonJS(module.eports로 모듈 정의후 require()로 모듈을 불러와 사용)의 패턴을 사용하였데 새롭게 import와 export 가 제공된다.
11. for ...of 반복문: foreach 반복문은 오직 Array 객체에서만 사용가능한 메서드이다. for ...in 반복문은 객체의 속성을 반복하여 작업할 수 있었으나 key만 접근 가능하고 value에는 접근할 수 없었다. for of 반복문은 [Symbol.iterator] 속성을 가지는 컬렉션(prototype까지 접근 가능) 전용으로 사용 가능하다.
12. Generators: Generators는 function와 yield 키워드를 이용하여 iterator 선언을 단순하게 작성할 수 있게 한다. function로 선언한 함수는 Generator 객체를 반환합니다. Generators는 iterator의 하위 타입이며 next와 throw 메서드를 가지고 있다. 이 메서드들로 인해 yield 키워드로 반환된 값은 다시 generator에 주입거나 예외처리를 할 수 있게 되었다.
13. Unicode: 완전한 유니코드를 지원하기 위해 문자열에 새로운 유니코드 리터럴과 정규표현식에 u 모드가 추가되었다. 또한 21비트 형식까지 처리하기 위한 신규 API가 추가되었다. 추가된 기능은 JavaScript로 글로벌 앱을 만드는 것이 가능하다.
14. 모듈 로더: 모듈 로더는 주요 모듈 포맷으로 작성된 모듈을 해석하고 로드한다. 모듈 로더는 런타임에 실행된다.
15. Map + Set + WeakMap + WeakSet: 일반 알고리즘을 위한 효율적인 데이터 구조를 제공한다. WeakMap과 WeakSet는 메모리 누수로 부터 자유롭게 해준다. 이들 내 저장된 객체에 다른 참조가 없는 경우, garbage collection 될 수 있다.
16. Proxies: 프록시(Proxy)를 사용하면 호스트 객체에 다양한 기능을 추가하여 객체를 생성할 수 있다. 프록시는 대상을 가상화하여 프록시와 대상이 사용하는 기능을 동일한 객체로 표시되도록 한다. interception, 객체 추상화, 로깅/수집, 값 검증 등에 사용될 수 있다.
17. Symbols: 심볼(Symbol)은 객체 상태의 접근 제어를 가능하게 한다. Symbol은 새로운 원시 타입으로 이름 충돌의 위험 없이 속성(property)의 키(key)로 사용할 수 있다. 옵션 파라미터인 description는 디버깅 용도로 사용되며 식별 용도는 아니다. Symbol은 고유(unique)하며, Object.getOwnPropertySymbols와 같은 reflection 기능들로 접근할 수 있기 때문에 private 하진 않다(for in나 Object.keys()로는 접근 불가).
18. Math + Number + String + Array + Object APIs: core Math 라이브러리, Array 생성 helper, String helper, 복사를 위한 Object.assign 등 많은 라이브러리들이 추가되었다.
11. Reflect API: Reflection API는 런타임 시 객체에 대해 작업을 수행할 수 있다. 프록시 트랩(proxy traps)와 같은 메타 함수들을 가지고 있다. Reflection은 프록시를 구현하는데 유용하다. Reflect 객체로 표현된 리플렉션 API는 프록시가 오버라이드 할 수있는 것과 동일한 로우 레벨 연산에 대한 기본 동작을 제공하는 메서드 컬렉션이다. 모든 프록시 Trap에 대해 Reflect 메서드가 있다.
12. Tail Calls: 마지막에 호출되는 함수가 호출 스택이 초과되게 하지 않습니다. 재귀 알고리즘을 매우 큰 입력 값에서도 안전하게 만든다.


## 마치며 
ES6(ECMA2015)는 확정되었지만 아직 모든 브라우저에서 완전하게 지원되지 않습니다. 따라서 Babel과 가은 자바스크립트 컴파일러를 통해 최신버전의 문법을 브라우저와 호환가능한 문법으로 변환하여 사용해야 합니다. babel사용시 조심한 점은, babel은 문법을 변환해 주는 역할만 할 뿐 최신으로 추가된 함수를 변환하는 것이 아니기 때문에 이 때에는 babel-polyfill를 별도로 설정하여 사용해야 합니다. polyfill은 프로그램이 처음에 시작될 때 현재 브라우저에서 지원하지 않는 함수를 검사해서 각 object의 prototype에 붙여주는 역할을 합니다. 즉, babel은 컴파일-타임에 실행되고 babel-polyfill은 런-타임에 실행되는 것입니다. 앞으로 계속 ES6를 지원하는 브라우저들은 점점 늘어 날 것 이기 때문에 미리미리 공부해 둡시다.


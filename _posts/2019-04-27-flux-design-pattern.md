---
layout: post
title: Flux Design Pattern  
tags:
 - flux
categories: Programming
---

## 소개
Flux 디자인 패턴에 대해 설명합니다. Flux는 MVC 의 한계로 인해 등장하였습니다. 먼저 MVC패턴은 Model, View, Controller 세 가지 부분으로 이루어져 있고 기본 데이터 흐름은 다음과 같습니다.
- Model: 자료(Data)를 생성, 저장, 처리하는 역할을 하는 부분이다. 
- View: Model로부터 받은 자료를 여러 가지 형태로 사용자에게 보여주는 역할을 한다. 
- Controller: 소프트웨어의 흐름을 제어하는 것으로 View와 Model 사이에서 관계를 설정하여 주는 부분을 말한다. Controller는 Model이나 View가 바뀌더라도 수정 없이 작동되어야 한다.

뷰는 데이터를 렌더링 하기 위해 데이터를 가지고 있는 모델이 뷰로 데이터를 보내게 되는데, 이때 발생하는 문제점은 Model과 View의 관계가 복잡해지는 애플리케이션 규모가 커지는 경우, 점점 복잡해 진다는 것입니다. 복잡해 진다는 것은 결국에는 고드의 에측이나 테스트가 어려워진다는 것이고 그렇다면 소프트웨어의 품질을 담보하기가 어려워 집니다. 

부모-자식(parent-child) 관계가 아닌 컴포넌트끼리 데이터를 교류 할 때엔 글로벌 이벤트 시스템을 설정 하는 방법으로 Flux 디자인 패턴을 사용합니다. 가장 많이 사용되고 있는 예로는 React애플리케이션에서 사용되는 Redux가 있습니다. 조금 다르기는 하지만 Redux는 리엑트(Reaact) 애플리케이션의 효율적인 데이터 교류 및 state 관리를 쉽고 효율적으로 하기 위해 사용하는 라이브러리로서 이를 사용하면 리엑트 같은 싱글 페이지 애플리케이션(SPA: Single Page Application)에서 상태적 데이터 관리를 시간 흐름에 따라 복잡해 지지 않도록 제어 할 수 있습니다. (React 외에도, jQuery 혹은 Angular 를 사용하는 어플리케이션에서도 사용 될 수 있습니다.) Redux는 자바스크립트 앱을 위한 예측 가능한 상태 컨테이너입니다.

## Flusx Design Pattern
구성요소로는 Action, Dispatcher, Store, View 가 있습니다. 시스템에서 사용자로 부터 어떠한 Action을 받았을 때, Dispatcher가 받은 Action들을 통제하여 Store에 있는 데이터를 업데이트합니다. 그리고 변동된 데이터가 있으면 View 에 리렌더링하는 방식입니다. 그리고, View에서 Dispatcher로 Action을 보낼 수도 있습니다. Dispatcher은 작업이 중첩되지 않도록 해줍니다. 즉, 어떤 Action이 Dispatcher를 통하여 Store에 있는 데이터를 처리하고, 그 작업이 끝날 때 까지 다른 Action들을 대기시킵니다. 

중요한 점! 단방향 데이터 흐름을 기억하고 각각의 구성 요소에 대해 알아 봅시다.

### 액션(Action)
사용자가 요청하는 변경 사항입니다.

### 액션 생성자(Action Creator)
액션들을 미리 준비 하고 있습니다. 뷰로부터 사용자 입력이 들어 왔다는 것을 전달 받으면 디스페처에게 어떤 메시지를 보내야 할지 알려주면 액션 생성자는 나머지 시스템이 이해할 수 있는 포맷형식으로 바꿔주는 역할을 합니다. 액션 생성자가 액션 메시지를 생성한 뒤에는 디스패처(dispatcher) 로 해당 액션 메시지를 보내주게된다. 이렇게 하나의 시스템이 모든 가능한 액션들을 알게 됨으로써 갖는 효과가 있는데, 이 액션 생성자를 통해 시스템에서 제공하는 전체 API(모든 가능한 상태변경) 를 바로 확인할 수 있다는 점입니다.

### 디스패처(Dispatcher)
다른 아키텍처들과는 달리 액션의 타입과는 관계없이 등록된 모든 스토어에 액션을 보냅니다. 스토어는 특정 액션만 구독(subsribe)하는 것이 아니고 모든 액션을 받은 뒤 받은 액션을 처리할지 말지를 스토어가 결정합니다. 이처럼 디스패처(dispatcher)는 액션을 보낼 필요가 있는 모든 스토어(store)가 연결되어 있으며, 액션 생성자(the action creator)가 보낸 액션 메시지를 연결된 모든 스토어 에게 전달해주는 역할을 합니다. 처리 방식은 동기적 방식으로 동기적으로 처리 된다는 것은 여러 액션이 들어와도 우선순위를 가진 액션 순으로 처리하기 때문에 비동기 적인 방식처럼 순서가 뒤죽박죽 되거나 복잡한 상황이 발생하지 않는다는 것을 의미 합니다.

### 스토어(Store)
애플리케이션 내의 모든 상태(State)와 그와 관련된 로직을 가지고 있습니다. 모든 상태 변경은 스토어에서 결정됩니다. 디스패처로부터 모든 액션을 받은 스토어는 내부에서 상태 변경을 결정하기 위해 switch구문을 통해 필요한 액션을 구분하게 되고 구분되어진 액션 내용 중 상태변경에 대한 내용이 포함되어 있다면 액션에서 전닯다은 상태 변경을 진행합니다. 주의할점은, 스토어는 전달받은 액션으로 부터 데이터의 상태 변경을 "결정"만 할 뿐 자체적으로 상태를 변경할 수는 없습니다. Flux의 기본 시스템 구성이 단방향 데이터 흐름인 것과 스토어에는 상태를 설정할 수 있는 설정자(setter)가 존재하지 않는 다는 것을 알아 둡시다.

그러므로 상태 변경이 필요한 경우 변경을 요청하기 위해 반드시 처음부터 모든 정해진 절차(액션 생성자->디스패처 파이프라인->스토어)를 따라 상태 변경에 대한 액션을 보내야 합니다.

그 다음 절차로 스토어에서의 일이 모두 처리되고 나면 스토어는 변경 이벤트(change event)를 컨트롤러 뷰(the controller view)에 내보내어 상태가 변경되었다는 것을 알려줍니다. 

### 컨트롤러 뷰(Controlloer View)
스토어에서 상태가 변경되었다는 사실을 전달받은 컨트롤러 뷰는 다신 아래 있는 모든 뷰(The View)에게 새로운 상태를 넘겨주고 렌더(Rendering)혹은 리렌더(Rerendering)하라고 알려줍니다. 

### 뷰(The View)
컨트롤러 뷰에게 새로운 상태를 전달 받는 뷰는 해당 내용들를 사람들이 이해할 수 있는 포맷(HTML)으로 변경하여 보여줍니다(Rendering 혹은 ReRendering). 뷰는 애플리케이션 내부에 대해서 아는바가 없습니다. 단지 보여줄 뿐입니다.

## 동작 순서

### 준비

- 스토어(Store): 디스패처(Disptcher)에게 "액션 생성자에게 액션 메세지가 오면 알려줘" 라고 말해 둔다.
- 컨트롤러 뷰(Controller View): 스토어(Store)에게 "현재 보여줘야 하는 상태가 뭐야?"라고 물어 최신 상태에 대한 답을 받아 뷰(The View)에게 전달한다.
- 뷰(The View): 최신 상태를 받으면 렌더링(Rendering) 한다.
- 컨트롤러 뷰(Controller View): 스토어(Store)에게 "상태가 바뀌면 알려줘"라고 부탁한다. 스토어를 구독하고 있다.

### 데이터 흐름
- 뷰(The View): 사용자에게 입력이 들어오면 액션 생성자(Action Creator)에게 알려준다
- 액션 생성자(Action Creator): 준비하고 있던 액션을 포맷에 맞게 가공한 다음 디스패처(Disptcher)에게 넘겨준다. 
- 디스패처(dispatcher): 들어온 액션의 순서에 따라 액션을 스토어(store)로 보낸다. 액션을 구독하고 있다.
- 스토어(store): 모든 액션을 받고 필요한 액션 만을 골라 상태(state)를 필요에 맞게 변경한다. 스토어(store)는 자신을 구독(subscribe) 하고 있는 컨트롤러 뷰(the controller view)에게 그 사실을 알린다.
- 컨트롤러 뷰(the controller view): 스토어(store)에게 변경된 상태를 요청하고, 스토어(store)는 상태(state)를 컨트롤러 뷰(the controller view)에게 전달한다. 스토어(store)에게 새로운 상태(state)를 전달받은 컨트롤러 뷰(the controller view)는 자신 아래의 모든 뷰(the view)에게 새로운 상태(state)에 맞게 렌더링(re-rendering) 하라고 알린다.


지금까지 Flux Design Pattern에 대해서 살펴 보았습니다. 내용을 정리 해보면 다음과 같습니다.

## Flux 패턴의 핵심요소
Flux에는 4가지 핵심요소가 존재합니다: action, store, dispatcher 그리고 view. 이 요소들은 아래의 역할을 수행합니다:

Action은 type 속성과 일부 데이터가 있는 단순한 객체입니다. 예를 들어 { type : "INCREMENT", local_data: { delta : 1 } } 입니다.
Store는 응용프로그램의 state와 로직이 들어있습니다. store가 응용프로그램의 특정 도메인을 관리한다고 생각하면 됩니다. Flux의 store는 아무거나 다 저장할수있기 때문에 MVC의 Model과는 좀 다릅니다.
Dispatcher은 허브역할을 합니다. Dispatcher은 작업을 처리하고(예를들면 사용자 상태 변경) store에 등록된 콜백함수를 호출합니다. Dispatcher은 MVC의 Controller와는 다릅니다. 대개 Dispatcher은 로직이 많지 않으므로 동일한 프로젝트 내에서 여러번 사용하기도 합니다.
View는 controller-view이며, GUI MVC패턴에서도 일반적인 요소입니다. 이 요소는 store가 변경사항을 말해주면 해당 부분을 다시 렌더링합니다. 또한 View는 Dispatcher에 새로운 Action을 추가할 수도 있습니다.

## Flux와 MVC의 차이점
Flux 에선 응용프로그램의 데이터 흐름이 필수요소이며 Dispatcher에 의해 매우 엄격한 규칙으로 강제화됩니다. MVC에서는 흐름이 강제되지 않으며, MVC패턴 대부분들이 이를 다르게 구현합니다. 심지어 같은 프레임워크에서도 개발자마다 다르게 구현하기도 합니다. 
단방향 흐름 : 모든 상태 변화는 Dispatcher에 의해 진행됩니다. store는 다른 store를 직접 변경할 수 없습니다. view와 action도 마찬가지입니다. 모든 변화는 action을 거쳐 Dispatcher에서 실행됩니다. MVC에선 양방향 흐름을 가지는 것이 매우 일반적입니다.
Store은 model이 없더라도 응용프로그램과 관련된 모든 상태를 저장 할 수 있습니다. MVC에선 객체를 모델링합니다.


----
해당 내용은 다음 글을 참고 하였습니다.
- https://m.blog.naver.com/backsajang420/221368106022
- https://lunit.gitbook.io/redux-in-korean/
- https://dogbirdfoot.tistory.com/14
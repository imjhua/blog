---
layout: post
title: Javascript 기본 개념
tags:
  - javascript
categories: JavaScript
---


## 소개
자바스크립트는 객체 기반의 스크립트 프로그래밍 언어입니다. 인터프리팅 방식을 사용하고, C++이나 자바같은 정적인(Static) 언어가 아니라 동적 언어로 타입을 명시할 필요가 없는 인터프리터 언어입니다. 그렇기 때문에 보다 유연하며 추상화(abstraction)나 위임(delegation) 등의 메커니즘이 프로토타입(prototype) 객체나 함수를 통해 구현이 가능합니다. 작고 빠르기 때문에 웹문서를 동적으로 꾸밀 때 가장 널리 쓰여 웹 브라우저 내에서 주로 사용합니다. 자바스크립트는 HTML과 CSS로 만들어진 정적인 페이지를 동적인 페이지로 만들 수 있습니다. HTML과 CSS와 결합외어 웹페이지 상에 올려진 후, 브라우저의 자바스크립트 엔진(인터프리터기)에 의해 실행(이말인 즉슨 브라우저 자바스크립트 엔진 버전에 따라 최신 문법이 호환될수도 있고 되지 않을 수도 있음을 의미함) 됩니다. 현재에는 웹 애플리케이션, 웹서버(nodejs)와 함께 클라이언트 웹페이지를 동시에 구현할 수 있는 수준까지 발전되었습니다. 웹 개발의 핵심 기술인 javascripts의 기본 개념들을 정리해봅시다. 

## 기본 개념
자바스크립트의 기본 개념으로는 프로토타입, 실행 컨텍스트, 일급객체 함수, 호이스팅, 실행 컨텍스트, 클로저, 스코프(유효범위) 체인 등이 있습니다. 앞으로 자세히 살펴 봅시다.

### 프로토타입 기반 프로그래밍
프로토타입 기반 프로그래밍 이란 객체의 원형인 프로토타입을 이용하여 새로운 객체를 만들어내는 프로그래밍 기법을 의미합니다. 자바스크립트는 클래스라는 개념이 없습니다. 그래서 기존 객체를 복사하여 새로운 객체를 생성하는데 그렇기 때문에 프로토타입 기반언어라고도 불리웁니다. 프로토타입 기반 언어는 객체 원형인 프로토타입을 이용하여 새로운 객체를 만들어 내는데 이 또한 또 다른 객체의 원형이 될 수 있습니다. 프로토타입 기반으로 만들어진 객체 역시 자기자신의 프로토타입을 갖게 됩니다. 프로토 타입은 객체를 확장하고 객체지향 프로그래밍이 가능하도록 합니다. prototype에 저장된 속성들은 생성자를 통해서 객체가 만들어질 때 그 객체에 연결됩니다. 

이 새로운 객체의 원형을 이용하면 또 다른 새로운 객체를 만들어 낼수도 있으며 이런 구조로 객체를 확장하는 방식을 프로토타입 기반 프로그래밍이라고 합니다.

### 프로토타입 객체의 속성 
Prototype Object는 일반적인 객체와 같으며 기본적인 속성으로 constructor와 ____proto__를__ 가지고 있습니다.
- constructor: 생성자로써, 자신을 만들어낸 객체와 연결된 속성
- ____proto____: 상위 객체. 객체를 만들어내기 위해 사용된 객체원형에 대한 숨겨진 연결. 자신을 만들어낸 객체의 원형(Prototype Link)
- prototype: 자기 자신. 자신을 통해 만들어질 객체의 원형(Prototype Object)

#### prototype 프로퍼티
prototype 프로퍼티는 객체가 생성될 당시 만들어지는 객체 자신의 원형이될 prototype 객체를 가리킵니다. prototype이 원형이라는 뜻이니, 결국 자기자신의 원형을 가르키는 속성이 prototype입니다. 자기 자신을 가리키는 속성입니다. 이 뜻은 앞으로도 자신을 통해 만들어질 객체들이 원형으로 사용할 객체를 의미하고 자신을 원형으로 만들어질 다른 객체가 참조할 프로토타입이 됩니다. 자신을 원형으로 만들어질 새로운 객체들 즉 하위로 물려줄 연결에 대한 속성입니다.

#### ____proto____ 
객체를 만들어내기 위해 사용된 객체원형에 대한 숨겨진 연결(Link)입니다. 자신이 상속받은 상위객체, 객체원형(부모)을 의미합니다. 상위에서 물려받은 객체의 프로토타입에 대한 정보가 있습니다. 해당 프로퍼티를 따라 다니며 프로토타입 체인을 찾아 다닐 수 있습니다.


### 프로토타입 체인
객체의 생성 과정에서 모태가 되는 프로토타입과의 연결고리가 이어져 상속관계를 통하여 상위 프로토타입으로 연속해서 이어지는 관계를 프로토타입 체인이라고 한다. 이 연결은 상위에서 물려받은 객체의 프로토타입에 대한 정보를 담고 있는 ____proto____ 프로퍼티를 따라 찾아 갈 수 있습니다.

즉, 프로토타입 체인이란 위에서 봤던 프로토타입을 상속해서 만들어지는 객체들관의 연관관계를 의미합니다. ____proto____ 프로퍼티들간 이어진 점선을 타고 가다보면 최종적으로 Object 객체의 prototype Object에 다다르게 됩니다. 자바스크립트의 모든 객체는 Object 객체에서부터 파생되어 나온 자식들이기 때문입니다. 이러한 프로토타입 체인은 하위 객체에서 상위객체의 프로퍼티와 메소드를 상속받습니다. 그리고 동일한 이름의 프로퍼티와 메소드를 재정의 하지 않는 이상 상위에서 정의한 내용을 그대로 물려받게 됩니다. 하위 객체는 상위 객체의 속성과 메소드를 상속 받는 것이 아니라 그것을 공유하고 있는 것입니다.


### 실행 문맥(Excution Context)
여러개의 호출이 들어 오는 경우, 호출된 작업은 호출 스택에 하나씩 쌓이게 되고 가장 마지막에 들어온 스택을 먼저 실행하여 스택에서 제거 하는 방식으로 스택이 비워질때까지 반복합니다. 호출 스택에 저장되는 각 항목을 실행 맥락(execution context)이라고 부릅니다. 

즉, 실행 컨텍스트는 자바스크립트 코드 블럭이 실행되는 환경을 말합니다. 스코프(scope), 호이스팅(hoisting), this, function, 클로저(closure) 등의 동작원리를 담고 있는 자바스크립트의 핵심 원리이기도 합니다. ECMAScript 스팩에 따르면 실행 컨텍스트를 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 정의합니다. 즉, 실행컨텍스틀는 실행 가능한 코드가 실행되기 위해 필요한 환경이라고 할 수 있습니다. 자바스크립트 엔진은 코드를 실행하기 위히여 실행에 필요한 여러가지 정보(전역변수, 지역변수, 매개변수, 변수 선언, 변수의 유효범위, this 등)를 알고 있기 위해 이러한 정보를 형상화하고 구분하기 위해 실행 컨텍스트를 물리적 객체의 형태로 관리 합니다. 

함수 실행시, 실행 문맥 생성과정은 다음과 같습니다. 크게 실행문맥생성과정과 코드실행과정으로 나뉩니다.
1. 함수를 실행할 코드를 찾는다.
2. 함수를 실행하기전에 실행문맥을 생성한다.
3. 생성과정을 시작한다. - 활성 객체 (컨텍스트에서 실행에 필요한 정보들을 담고 있음)
- 스코프체인 초기화 또는 생성
- 변수 객체(Valiable Object) 생성: 매개변수의 정보를 저장하고 있는 arguments 객체 생성
- 함수가 가지고 있는 변수 및 객체 정보를 생성
- this 값 결정
5. 코드 실행과정 실행 
- 줄 마다 문맥안의 함수 코드를 실행하고 변수의 값을 할당
6. 함수 실행이 마무리되면 해당 컨텍스트는 사라짐. (클로저 제외) 페이지가 종료되면 전역 컨텍스트가 사라짐.

참고) 활성 객체에는 이 함수가 가지고 있는 파라미터나 변수, 객체 등에 대한 정보가 저장된다. 또한 다른 스코프에서 이 실행 컨텍스트를 참조할 땐 저 활성 객체를 참조 하게 된다. 함수 실행시에는 사용되는 변수들을 변수객체 안에서 값을 찾고, 없다면 스코프 체인을 따라 올라가며 찾는다.

자바스크립트의 실행 문맥은 크게 다음 3가지의 컴포넌트로 나누어 집니다.
1. 렉시컬 환경 컴포넌트(LexicalEnvironment): 현재 문맥, 렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정됩니다.
2. 변수 환경 컴포넌트(VariableEnvironment)
3. 디스 바인딩 컴포넌트(This Binding): 실행 문맥, 실행시 함수를 소유하고 있는 객체를 가르킨다.

렉시컬 환경 컴포넌트와 변수 환경 컴포넌트는 타입이 같고 with 문을 사용할 때를 제외하면 내부 값이 똑같다고 알려져있습니다. 디스 바인딩 컴포넌트의 경우, this는 함수가 실행되었을 때 그 함수가 속해 있던 객체를 참조합니다.


### 일급객체 함수
자바스크립트에서 함수는 일급 객체입니다. 다음 조건을 만족하면 일급 객체의 조건을 만족 할 수 있습니다.
- 변수(variable)나 데이터 구조에 담을 수 있다. (할당)
- 인자(parameter)로 전달할 수 있다.
- 반환값(return value)으로 전달할 수 있다.

다음을 추가로 만족하면 일급 함수가 됩니다.
- 런타임(runtime) 생성이 가능하다.
- 익명(anonymous)으로 생성이 가능하다.

따라서 자바스크립트에서 함수는 일급 객체 이면서 동시에 일급 함수입니다. 변수나 데이터 구조 안에 담을 수 있으며 인자로 전달 할 수 있고 반환값으로도 사용할수 있으며 런타임에 생성 가능 합니다. 

자바스크립트에서 함수가 일급객체 인것이 중요한 이유는 고차 함수(Higher-Order Function: HOF)가 가능하다는 것 입니다. 고차 함수는 함수를 인자로 받거나 결과로 반환하는 함수로서 이같은 조건에 부합하려면 무조건 일급 객체여야만 합니다. 함수를 인자로 받는 것을 흔히 콜백(callback)이라고 하며 이를 통해 되돌려지기가 가능하게 됩니다. 즉, 함수의 흐름을 제어 하는 등 비동기적인 실행 맥락을 처리 할 때 유용합니다. 여러 함수들이 반복적으로 가지고 있는 기능들을 고차 함수에 정의해 두고, 나머지 디테일한 기능은 인자로 넣는 콜백함수를 통해 중복되는 부분을 줄이면서 가독성을 높일 수 있습니다. 함수를 반환하는 고차 힘수를 이용하면 필요할때 재활용 할 수 있는 함수를 만들 수 있습니다.

### 호이스팅
코드 구현 위치와 상관 없이 브라우저가 자바스크립트를 해석 할때 맨 위로 끌어 올리는 현상으로 메모리 할당을 우선적으로 해 줍니다.

### 함수의 종류(함수 선언식vs함수 표현식-할당)
자바스트립트에서 함수는 두가지 중요한 개념이 있습니다. 바로 함수 선언식과 함수 표현식입니다. 두 함수모두 함수 호출 방법에는 큰 차이가 없으나 호이스팅과 관련하여 가장 큰 차이가 있는데, 함수 표현식(var로 할당)은 호이스팅에 영향을 받지 않지만 함수 선언식은 호이스팅에 영향을 받는 다는 점입니다. 즉, 함수 선언식은 호이스팅에 의해 다른 코드보다 먼저 읽고 실행 됩니다. 할당 구문인 함수 표현식은 런타임 과정이 이루어지기 때문에 호이스팅 되지 않습니다.

- 함수 선언식은 호이스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않는다. 
- 함수 선언식은 코드를 구현한 위치와 관계없이 자바스크립트의 특징인 호이스팅에 따라 브라우저가 자바스크립트를 해석할 때 맨 위로 끌어 올려진다.

#### 함수 선언식
함수 선언식은 함수의 문장으로써 실행 가능한 코드 블럭이 아니며, 함수의 정의를 나타내는 문장으로 해석됩니다. 때문에 수행결과가 존재 하지 않습니다. 이러한 이유료 함수 선언을 클래스(class)와 동일한 개념으로 이해 할 수 있습니다. 호이스팅 된다는 특징이 있습니다.

```js
function 함수명() {
  // code
}

function funcDeclarations() {
  return 'A function declaration';
}
funcDeclarations(); // 'A function declaration'
```

#### 함수 표현식
함수 표현식은 함수리터럴로 특정변수에 할당되거나 즉시 실행 가능한 코드 블럭으로서 존재하는 함수입니다. 이때 즉시 실행 가능한 코드 블럭으로 존재하는 함수를 즉시실행함수표현 (IIFE, Immediately Invoked Function Expression) 또는 자기 호출 함수라고 하는데, 이를 통해 블록 스코프를 흉내 낼 수 있습니다. ES6 이전 (let이 없을 때) 블록 레벨 스코프는 존재하지 않았는데 이를 흉내 낼 수 있는 방법으로 익명함수를 정의 하고 바로 호출하는 방법입니다. 함수 표현이 실행 코드로 해석되기 위하여(변수에 할당하지 않지만 함수 선언식이 아닌 표현식으로 인식 될 수 있도록) 괄호로 묶어 주어야 합니다. 괄호로 묶어 주지 않으면 함수 선언의 시작으로 인식하여 에러가 발생하게 됩니다. 코드 블럭으로서 존재하는 함수 표현식은 해석과 동시에 실행되는 코드 블록이 됩니다. 

- 기명 함수 표현석
- 익명 함수 표현식
- 기명 즉시 실행 함수
- 익명 즉시 실행 함수 (2가지)

```js
var 함수명 = function () {
  // code
};

var funcExpression = function () {
    return 'A function expression';
}
funcExpression(); // 'A function expression'
```

다음은 익명함수와 기명함수로 작성된 함수 표현식 및 즉시 실행함수의 예입니다.
```js
// 기명 함수표현식(named function expression) 
var company = function company() {  
    /* 실행코드 */
}; 

// 익명 함수표현식(anonymous function expression)
var company = function() {  
    /* 실행코드 */
};

// 기명 즉시실행함수(named immediately-invoked function expression)
(function company() {
    /* 실행코드 */
}());

// 익명 즉시실행함수(immediately-invoked function expression)
// Javascript 대가이신 더글라스 클락포트의 권장 표기법
(function() {
    /* 실행코드 */
}());

// 익명 즉시실행함수(immediately-invoked function expression)
(function() {
    /* 실행코드 */
})();
```

### 스코프(유효범위)
ES6 전까지 자바스크립트는 전통적으로 함수 레벨 스코프를 지원하였습니다. 블록 레벨 스코프는 지원하지 않았습니다. 자바스크립트에서 스코프의 특징은 함수 호출시점이 아닌 선언된 시점을 기준으로 유효범위를 갖는다는 것인데 외부/내부함수가 아닌 경우, 함수가 또 다른 함수를 호출한다고 했을 때 또 다른 함수에서 이전 함수의 지역변수를 사용한다 하더라도 선언시점에는 그 관계를 모르기 때문에 최초 선언된 전역 변수의 값을 갖게 됩니다. 

#### 함수 레벨 스코프
var키워드로 선언된 변수나 함수 선언식으로 만들어진 함수는 함수 레벨 스코프를 가집니다.

#### 블록 레벨 스코프
ES6에서 지원하는 let키워드를 통해 선언하면 블록 레벨 스코프를 가집니다. 블록 내부에서는 참조가 가능하며 그 밖의 영역에서 참조 할 경우 에러가 발생합니다. 


#### 렉시컬 스코프(Lexical scope) = 정적 스코프(작성된 현재 문맥) != 동적 스코프(실행 문맥)
렉시컬 스코프는 정적 스코프 라고도 하며 동적 스코프와는 반대 되는 개념입니다. 동적 스코프는 프로그램의 런타임 도중의 실행 컨텍스트나 호출 컨텍스트에 의해 결정됩니다. 렉시컬 스코프는 `소스코드가 작성된 그 문맥에서 결정되는 유효 범위`로써 현대 프로그래밍에서 대부분의 언어들은 렉시컬 스코프 규칙을 따릅니다. 렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정됩니다. 함수를 처음 선언하는 순간, 함수 내부의 변수는 자기 스코프로부터 가장 가까운 곳에 있는 변수를 참고 하게 됩니다. 변수 선언시 가장 가까운 스코프가 전역 변수라면 전역 변수를 참조 하게 됩니다. 

이때 함수 실행시의 this는 실행 문맥(함수가 작성 됐을때가 아닌 실행 당시의 문맥)에 의하여 함수를 소유하고 있는 객체를 가리키게 되는데 런타임에서 객체 내부의 속성으로 정의된 함수가 실행 될때, this는 함수가 아닌 객체를 참조 합니다. es6에 새롭게 추가된 화살표 함수는 렉시컬 스코프를 갖기 때문에 새롭게 만들어진 객체(인스턴스)가 아닌 당시 문맥에 의한 상위 객체를 가르키게 됩니다. 따라서 기존의 메소드 정의 방법과 화살표 정의 방법 구분하여 사용하는데 주의해야 합니다. (참고. 실행문맥 3가지 환경)


### 스코프 체인
전역변수와 지역변수의 개념에서 나옵니다. 내부 함수에서는 외부함수의 변수에 접근이 가능하지만 외부함수에서는 내부함수의 변수에 접근 할 수 없습니다. 변수의 값은 먼저 자기 자신의 스코프에서 찾고 점점 위로 올라가 상위 스코프를 찾으며 마지막으로는 전역 스코프에서 값을 찾게 됩니다.

### 클로저
클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말합니다. 이로써 내부함수가 외부함수의 데이터에 접근하게 됩니다. 다른 함수의 스코프에 있는 변수에 접근 가능한 함수라고도 하며 함수의 부모 함수의 범위에 대한 접근성을 제공하는 것을 뜻하기도 합니다. 이미 스코프 체인이 결정된 이후에 전역에서 함수를 호출할 지라도 호출되는 함수는 이미 결정된 렉시컬 환경에서 변수의 값을 찾습니다. `렉시컬 환경, 렉시컬 스코프는 함수를 둘러싼 환경으로 소스코드가 작성된 그 문맥에서 바로 결정되는 것을 의미합니다. 함수를 만들고 그 함수 내부의 코드가 탐색하는 스코프를 함수 생성 당시의 렉시컬 스코프로 고정하면 바로 클로저가 되는 것`입니다. 

```js
var makeClosure = function() {
  var name = 'jh';
  return function () {
    console.log(name);
  }
};
var closure = makeClosure(); // function () { console.log(name); }
closure(); // 'jh';
```
외부 함수는 호출됨과 동시에 실행 컨텍스트 스택(콜스택)에서 제거 되었으므로 외부 함수의 변수값들은 더 이상 유효하지 않지만, 내부 함수에서 외부 함수의 렉시컬 환경으로 외부 함수의 환경을 참조 했기에 외부 함수의 콜스택이 제거된 이후에도 변수에 접근이 가능한 것입니다. 즉, 자바스크립트에서 클로저는 함수가 생성되는 시점에 생성됩니다. 함수가 생성될 때 그 함수의 렉시컬 환경을 포섭(closure)하여 실행될 때 이용하는 것입니다. 클로저 안에 정의된 함수는 만들어진 환경을 기억합니다. `클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수`라고 정의 할 수 있습니다. 외부함수를 실행하면서 생성되는 지역변수 객체는 스코프체인에 들어가게 되고, 내부함수의 스코프 체인으로 참조됩니다. 외부함수는 종료되었지만 여전히 내부함수 스코프 체인으로 참조되므로 가비지 컬렉션의 대상이 되지 않아 여전히 접근이 가능 한 것입니다. 

클로저는 렉시컬 환경을 기억해야 하므로 메모리 차원에서 손해를 볼수 있지만 현재 상태를 유지할 수 있으며, 객체지향 프로그래밍을 한다면 은닉도 쉽게 할수 있다는 장점이 있습니다. 기존 prototype으로 객체를 다루던 자바스크립트에서 클로저를 통해 java처럼 외부에서 특별한 인터페이스를 제공하지 않는 이상 변수에 직접 접근이 힘들게 됩니다. 여러 영역에서 사용되는 변수들의 이름이 서로 충돌해도 오류가 발생하지 않는 문제를 해결할수 있으며 호출 객체를 단위로 캡슐화가 가능합니다. 

주의사항으로는, 가비지 컬렉터가 호출이 끝난 함수를 제거하지 못해서 메모리 낭비와 성능이 떨어지는 현상이 발생 할 수 있습니다. 중첩되는 반복문에서 조심해야 합니다. 클로저는 각자의 환경을 가집니다. 이 환경을 기억하기 위해서는 당연히 메모리가 소모될 것입니다. 클로저를 생성해놓고 참조를 제거하지 않는 것은 C++에서 동적할당으로 객체를 생성해놓고 delete를 사용하지 않는 것과 비슷합니다. 클로저를 통해 내부 변수를 참조하는 동안에는 내부 변수가 차지하는 메모리를 GC가 회수하지 않습니다. 따라서 클로저 사용이 끝나면 참조를 제거하는 것이 좋습니다.


클로저 예
```js
var i;
for (i = 0; i < 10; i++) {
  setTimeout(function() {
    console.log(i);
  }, 100);
}
```
간단하게 0-9까지의 정수를 출력하는 코드이지만 실제로 돌려보면 엉뚱하게도 10만 열 번 출력되는 걸 볼 수 있습니다. 이유는 먼저 setTimeout()에 인자로 넘긴 익명함수는 모두 0.1초 뒤에 호출될 것 입니다.. 그 0.1초 동안에 이미 반복문이 모두 순회되면서 i값은 이미 10이 된 상태. 그 때 익명함수가 호출되면서 이미 10이 되어버린 i를 참조하는 것입니다.

클로저는 독립적인 (자유) 변수를 가리키는 함수로, 클로저 안에 정의된 함수는 만들어진 환경을 ‘기억한다’는 특징을 가지고 있기에 클로저를 사용하면 원하는 대로 동작하도록 만들 수 있습니다.

```js
var i;
for (i = 0; i < 10; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);
    }, 100);
  })(i);
}
```

중간에 IIFE(즉시실행함수표현 IIFE, Immediately Invoked Function Expression)를 덧붙여 setTimeout()에 걸린 익명함수를 클로저로 만들었습니다. 앞서 말한대로 클로저는 만들어진 환경을 기억합니다. 이 코드에서 i는 IIFE내에 j라는 형태로 주입되고, 클로저에 의해 각기 다른 환경속에 포함됩니다. 반복문은 10회 반복되므로 10개의 환경이 생길 것이고, 10개의 서로 다른 환경에 10개의 서로 다른 j가 생깁니다.

이쯤에서 IIFE 매개변수로 i를 넘기지 않고 그냥 직접 참조해도 되지 않느냐는 의문이 들 수도 있다. 하지만 직접 그렇게 해보면 원하는 대로 동작하지 않습니다. 위의 예제에서는 IIFE를 통해서 클로저마다 환경이 생깁니다. 하지만 인자로 i를 넘기지 않는다면 당연히 클로저가 참조하는 IIFE의 함수 스코프에서도 i값이 없으므로 생성 당시의 외부 스코프인 글로벌을 탐색하게 되고 결국 모두 같은 i를 참조하게 됩니다. 반면에, 인자로 i를 넘기게 되면 IIFE로 만든 10개의 스코프에 모두 i라는 변수가 다른 값으로 생기므로 정상적으로 동작할 수 있는 것입니다.



### use strict 모드
Strict Mode의 선언방식 입니다. 이 문구는 ES5부터 적용되는 키워드로, 안전한 코딩을 위한 하나의 가이드라인 입니다. Strict Mode는 코드에 더 나은 오류 검사를 적용하는 방법입니다. Strict Mode를 사용하면, 예를 들어 암시적으로 선언한 변수를 사용하거나 읽기 전용 속성에 값을 할당하거나 확장할 수 없는 개체에 속성을 추가할 수 없습니다. Strict Mode는 ECMAScript5 버전에 있는 새로운 기능으로써, 당신의 프로그램 또는 함수를 엄격한 운용 콘텍스트 안에서 실행시킬 수 있게끔 합니다. 이 엄격한 콘텍스트는 몇가지 액션들을 실행할 수 없도록 하며, 좀 더 많은 예외를 발생시킵니다.

strict 모드의 선언법은 두가지가 있는데 전역으로 사용하고자 하는 경우 자바스크립트 코드의 맨 윗부분에 "use strict"를 명시하고 함수내에서만 strict 모드를 사용하고자 할 때는 함수 내의 최상위에 "use strict"를 명시합니다.

strict 모드의 제한되는 내용은 다음과 같습니다.
- 선언하지 않고 변수를 사용할 때.
- 변수, 함수, 매개변수를 삭제하려할 때.
-  동일한 프로퍼티를 한번 이상 선언하려 할 때.
- 매개변수 이름이 동일할 때.
- 8진법의 숫자 리터럴과 특수문자를 할당하려 할 때.
- 읽기전용에 할당하려 할 때.
- 얻기 전용 (get-only)  에 할당하려 할 때.
- 삭제불가능한 프로퍼티를 삭제하려 할 때.
- with 키워드를 사용하려 할 때.
- eval() 을 사용하려 할 때.

Strict Mode의 장점은 다음과 같습니다.
- 흔히 발생하는 코딩 실수를 잡아내서 예외를 발생 시킵니다.
- 상대적으로 안전하지 않은 액션이 발생하는 것을 방지합니다.
- 정확하게 고려되지 않은 기능들을 비활성화 시킵니다.



## 마치며
자바스크립트의 동작원리를 이해하기 위한 기본 개념들을 살펴 보았습니다.

----
해당 내용은 다음 글을 참고 하였습니다.
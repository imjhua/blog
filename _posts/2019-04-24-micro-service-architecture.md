---
layout: post
title: 마이크로 서비스 아키텍처 (Micro Service Architecture)
tags:
 - msa
 - micero-service-architecture
comments: true
---

## 소개
대용량 웹서비스가 많아짐에 따라 정의된 아키텍처로써 서비스 지향 아키텍처(SOA: Srevice Oriented Architecture)를 근간으로 도메인을 기능별로 분리한 단위보다 더 작은 최소 단위가 된다. 기능일수도 있고 최소 함수 및 조직단위가 하나의 서비스가 될 수 있다.

## 모노리틱 아키텍처(Monolithic Architecture)
모노토릭은 완전히, 통인된, 단일 결정된 뜻으로 기존의 전통적인 웹 시스템 개발에 많이 사용된 스타일이다. 하나의 애플리케이션 내에 모든 로직들이 있는 통짜 구조의 아키텍처 이다. 상호 호ㅜㄹ을 하는 컴포넌트들이 함수호출을 통해 작용한다. 전체 애플리케이션을 하나로 처리하기 때문에 개발툴 등에서 하나의 애플리케이션만 개발하면 되고 배포 및 테스트도 하나의 애플리케이션만 수행한다.

### 장점 
규모가 작은 애플리케이션에서는 배포 및 운영 관리가 용이하고 매우 간단하다. 하나의 구조로 되어 있기 때문에 트랜잭션 관리 등이 용이하다. 
- 작은 규모에서는 빠른 프로토타입 실행, 그리고 생산성을 가져갈 수 있다.
- 배포할때에는 하나의 서버만 변경하면 되기 때문에 심플하게 재 배포할 수 있다.
- call by reference에 의한 컴포넌트간 호출시 성능에 제약이 덜함
- 트트렌젝션 관리가 용이하다.
- 운영 관리가 용이하다.

### 단점
컴포넌트들은 타이트한 연결로 전체 시스템 구조를 제대로 파악하지 못하는 경우 개발시에 모듈의 성능 문제나 장애가 다른 컴포넌트들에게 영향을 주게 되어 문제가 발생할 수 있다. 일부 컴포넌트에서만 수정이 이루어진 경우에도 전체를 통으로 배포해야 하므로 잦은 배포에 분리 하며 컴포넌트별로 특성에 맞게 다른 기술을 도입하고자 할때 유연하지 못하다. 또한 대형시스템에서 크기가 큰 경우 빌드, 배포시간, 서버기동시간이 오래 걸린다. 
- 규모가 클 경우에 빌드 및 배포 시간 그리고 서버의 기동 시간까지 오래걸린다.
- 한 두 사람의 실수는 전체 시스템 빌드의 실패를 유발한다. (Java같은 컴파일 언어 시에) 때문에 협업개발하기가 쉽지않다.
- 구조가 커지면 커질수록 해당 프로젝트의 소스코드를 수정하기위해 전체 프로젝트 구조와 로직을 숙지하기 까지 러닝커브시간이 깊어진다.
- 컴포넌트 재 배포시, 수정된 컴포넌트 뿐만 아니라, 전체 어플리케이션을 재 컴파일 하기 때문에 잦은 배포가 있는 시스템의 경우 불리하다. - 빌드, 구동 시간까지 오래걸린다.
- 예를들어 Java 언어 플랫폼에서, 비동기 입출력을 요구하는 스펙에 맞추는 기능을 개발했을때에, 전체 시스템이 꺼지지 않기위한 복잡한 예외처리를 요구한다.(이 경우 node.js같은 언어가 더 적합하지만..)

## 서비스 지향 아키텍처(SOA: Service Oriented Architecture)
2000년대 초반 대용량 분산 시스템 설계의 한가지 방법으로 엔터프라이즈 시스템이 중심이 되는 아키텍처로 기존의 애플리케이션의 기능들을 비지니스적인 의미를 가지는 기능 단위로 묶어서 표준화된 호출 인터페이스를 통해서 서비스로 구현하고, 이 서비스들을 기업의 업무에 따라 조합하여 애플리케이션을 구성하는 소프트웨어 개발 아키텍처이다. 점점 확장되어가능 독립된 업무 시스템의 통합에 대한 요구와 시스템 업무변화에 대한 대응력을 높이기 위해 등장하였다. 서비스와 API를 기본 컨셉으로 두고 있다. 구여기서 서비스란 비지니스적 의미를 가지는 기능들을 모아 놓은 소프트웨어 컴포넌트를 의미한다.

토마스 얼의 SOA에 대한 정의
> SOA는 공개, 기민성, 확장, 연합, 자립적 요소들로 구성된 조합가능한 아키텍처이며 서비스 품질, 다양한 벤더, 상호 운영성, 서비스 발견 그리고 잠재적으로 재사용 가능한 서비스들이 웹서비스로 구현된다. SOA는 비지니스 로직과 기술을 추상화하여, 이 도메인 간에 느슨한 결합을 유도한다. SOA는 과거 플랫폼의 진화물로서 전통적인 아키텍처의 특징들을 고스란히 가지고 있으며, 명확한 원칙을 가지고 SOE를 지원하며 서비스 지향을 촉진한다. SOA는 엔터프라이즈 환경을 이상적으로는 표준화하지만, 치밀한 사전 계획에 의한 이전 필요성과 현재도 진화하고 있는 기술에 대한 지원만이 이러한 목적을 달성할 수 있다.

W3C의 Web Service Architecture Working Group에서 활동하고 있는 Hao He 박사의 SOA에 대한 정의
> 상호 작동하는 시스템 사이를 느슨하게 연결하려는 목적을 가진 아키텍처

## 마이크로 서비스 아키텍처(Micro Service Architecture)
2014년 부터 IT업계에서 알려지기 시작했다. 서비스와 API를 기본 컨셉으로 하는 서비스 지향 아키텍처(SOA)에 근간을 두고 대용량 웹서비스 개발에 맞는 구조로 경량화되고 대규모 개발팀의 조직 구조에 맞도록 변형된 아키텍처이다. 엔터프라이즈 시스템보다는 대규모 처리가 필요한 B2C 형 서비스에 적합하다.

### 서비스
시스템을 구성하고 있는 컴포넌트들을 하나의 서비스라는 개념으로 정의하는데 이떄 컴포넌트들은 데이터부터 비지니스로직까지 독립적으로 상호 컴포넌트들간에 의존성이 없는(수직적 분할) 상태로 RestAPI와 같은 표준 인터페이스를 통해 그 기능을 외부에 제공하며 API를 통해 타 서비스와 통신한다.

데이터 저장시에는 중앙집중화된 하나의 통 데이터베이스를 사용하는 것이 아닌, 서비스가 API에서 부터 데이터베이스까지 분리되는 수직분할원칙에 따라 서비스 별로 별도의 데이터베이스를 사용한다. 

### 장점
컴포넌트 별 의존성이 없기 때무에 독립적인 배포가 가능하다. 다른 서비스 컴포넌트에 대한 의존성이 없이 서비스를 독립적으로 개발 및 배포 운영할 수 있다. 서비스 부분만 재 배포 하면 되기 때문에, 빠르고 전체 시스템의 영향도를 최소화한 수준에서 배포를 진행할 수 있다.

서비스 별로 독립된 배포 구조는 확장성에 있어서도 많은 장점을 가지고 오는데, 부하가 많은 특정 서비스에 대해서만 확장이 가능하여 조금 더 유연한 확장 모델을 가질 수 있다. 모노리틱 아키텍처의 경우에는 특정 서비스의 부하가 많아서 성능 확장이 필요할 때, 전체 서버의 수를 늘리거나 각 서버의 CPU 수를 늘려줘야 하지만, 마이크로 서비스 아키텍처의 경우에는 부하를 많이 받는 서비스 컴포넌트 만 확장을 해주면 된다. 즉, 확장성이 좋다. 여러 언어로 개발해도 문제가 되지 않는다. Polyglot

### 단점
다른 컴포넌트의 데이타를 API 통신을 통해서만 가지고 와야 하기 때문에 성능상 문제를 야기할 수 있고, 또한 이 기종 데이타 베이스간의 트렌젝션을 묶을 수 없는 문제점을 가지고 있다. (이 문제는 SOA때 부터 존재해왔다)



## API Gateway
마이크로 서비스 아키텍처 설계시 많이 언급되는 컴포넌트이다. 프록시처럼 API들 앞에서 모든 API대한 end-point를 통합하고 추가적인 기능을 제공하는 미들웨어로 SOA의 ESB(Enterprise Service Bus)의 경량화 버전이다. 

* 미들웨어(middleware)는 응용 소프트웨어가 운영 체제로부터 제공받는 서비스 이외에 추가적으로 이용할 수 있는 서비스를 제공하는 컴퓨터 소프트웨어

### ESB vs APIgateway
SOA 프로젝트의 실패중의 하나가 ESB로 꼽히는 경우가 많은데, 이는 ESB를 Proxy나 Gateway처럼 가벼운 연산만이 아니라, 여러개의 서비스를 묶는 로직에 무겁게 사용했기 때문이다. (사용하면 안된다는 것이 아니라 잘 사용해야 한다는 것이다.) ESB는 메세지를 내부적으로 XML로 변환하여 처리하는데, XML 처리는 생각하는것 보다 파싱에 대한 오버헤드가 매우 크다.  또한 ESB의 고유적인 버스나 게이트웨이로써의 특성이 아니라 타 시스템을 통합 하기 위한 EAI적인 역할을 ESB를 이용해서 구현함으로써 많은 실패 사례를 만들어 내었다. 그래서 종종 ESB는 Enterprise Service Bus가 아니라 EnterpriSe nightmare Bus로 불리기도 한다. 

이러한 개념적인 문제를 해결하기 위해서 나온 제품군이 apigateway라는 미들웨어 제품군들인데, ESB와 기본적인 특성은 유사하나 기능을 낮추고 EAI의 통합 기능을 제거하고 API 처리에만 집중한 제품군들로, 클라우드상에서 작동하는 PaaS (Platform As A Service)형태의 서비스로는 apigee.com이나 3scale.com 등이 있고, 설치형 제품으로는 상용 제품인 CA社의 Layer7이나 오픈소스인 Apache Service Mix, MuleSoft의 ESB 제품 그리고 WSO2의 API Platform 등이 있다.

Apigateway 부분에 마이크로 서비스 아키텍처의 다른 부분 보다 많은 부분을 할애한 이유는, 컴포넌트를 서비스화 하는 부분에 까지는 대부분 큰 문제가 없이 적응을 하지만 apigateway의 도입 부분의 경우, 내부적인 많은 잡음이 날 수 있고, 또한 도입을 했더라도 잘못된 설계나 구현으로 인해서 실패 가능성이 비교적 높은 모듈이기 때문이다. 마이크로 서비스 아키텍처의 핵심 컴포넌트이기도 하지만, 도입을 위해서는 팀의 상당 수준의 높은 기술적인 이해와 개발 능력을 필요로 한다.


### 주요 기능
Apigateway가 마이크로 서비스 아키텍처 상에서 수행하는 주요 기능은 다음과 같다.

#### EndPoint 통합 및 토폴로지 정리
마이크로 서비스 아키텍처의 문제점 중의 하나는 각 서비스가 다른 서버에 분리 배포 되기 때문에, API의 End point 즉, 서버의 URL이 각기 다르다는 것이다. API를 사용하는 클라이언트에서 서버간의 통신이나, 서버간의 API 통신의 경우 p2p(Point to Point)형태로 토폴로지가 복잡해지고 거미줄 모양의 서비스 컴포넌트간의 호출 구조는 향후 관리의 문제를 일으킬 수 있다. 하나의 end point를 변경하였을 때, 제대로 관리가 되지 않을 경우가 있다. 이러한 토폴로지상의 문제점을 해결하기 위해서 중앙에 서비스 버스와 같은 역할을 하는 채널을 배치 시켜서, 전체 토폴로지를 p2p에서 hub & spoke 방식으로 변환 시켜서, 서비스간 호출을 단순화 시킬 수 있다.


#### Orchestration
여러개의 서비스를 묶어서 하나의 새로운 서비스를 만드는 개념이다. 이는 마이크로 서비스 아키텍처가 서비스 자체가 작은 덩어리(fine grained) 형태로 잘게 쪼게졌기 때문에 가능한 일인데, 사실 orchestration을 api gateway 계층에서 하는 것은 gateway 입장에서 부담이 되는 일이다. 실제로 과거의 SOA 시절에 많은 ESB(Enterprise Service Bus) 프로젝트가 실패한 원인 중의 하나가 과도한 orchestration 로직을 넣어서 전체적인 성능 문제를 유발한 경우가 많았다. 그래서 orchestration 서비스의 활용은 마이크로 서비스 아키텍처에 대한 높은 이해와 api gateway 자체에 대한 높은 수준의 기술적인 이해를 필요로 한다.

실제로 넷플릭스의 경우 마이크로 서비스 아키텍처를 사용하면서, 여러개의 서비스들을 gateway 계층을 통해서 orchestration 하는 모델을 사용하고 있다. 


#### 공통 기능 처리 (Cross cutting function handling)
또한 API에 대한 인증 (Authentication)이나, Logging과 같은 공통 기능에 대해서 서비스 컴포넌트 별로 중복 개발해야 하는 비효율성을 유발할 수 있다. api gateway에서 이러한 공통 기능을 처리하기 되면, api 자체는 비지니스 로직에만 집중을 하여 개발에 있어서의 중복등을 방지 할 수 있다.

#### mediation(중재)
이외에도 XML이나 네이티브 메세지 포맷을 json등으로 상호 변환해주는 message transformation 기능이나, 프로토콜을 변환하는 기능, 서비스간의 메세지를 라우팅해주는 기능등 여러가지 고급 mediation 기능을 제공을 하지만, api gateway를 최대한 가볍게 가져간다는 설계 원칙 아래서 가급 적이면 고급적인 mediation 기능을 사용할 때는 높은 수준의 설계와 기술적인 노하우를 동반해야 한다.


### Conway’s Law (컨웨이의 법칙)
마이크로 서비스 아키텍처의 흥미로운 점중의 하나는 아키텍처 스타일의 조직 구조나 팀 운영 방식에 영향을 준다는 것인데, 마이크로 서비스 아키텍처는 컨웨이의 법칙에 근간을 두고 있다.

컨웨이의 법칙은
"모든 시스템은 그 조직의 의사소통 구조와 동일하게 만들어진다."
"소프트웨어의 구조는 그 소프트웨어를 만드는 조직의 구조와 일치한다"
라는 이론이다.

마이크로 서비스 아키텍처는 각 컴포넌트를 팀에 배치해서 책임지고 개발하는 것을 근간으로 하며, 팀간의 의존성을 제거해서 각 팀이 컴포넌트 개발을 독립적으로할 수 있는 구조로 잡혀있다.




## 마이크로 서비스 아키텍처의 문제점
마이크로 서비스 아키텍처의 경우 성능, 메모리, 테스팅, 트랜잭션 처리등의 문제점이 있다.

### 성능
서비스간의 호출을 API통신으로 주고 받는 메세지들이 네트워크를 통해서 전송되기 때문에 그만한 시간이 더 추가로 소요된다. 이는 비동기패턴이나 캐쉬 등을 이용해 해결한다. 

### 메모리
각 서비스를 독립된 서버에 분할 배치하기 때문에, 중복되는 모듈에 대해서 그만큼 메모리 사용량이 늘어난다. 서비스 애플리케이션을 기동하거나 운영할때 메모리가 필요하다. 가용 메모리 용량을 늘려 해결 가능하다. 

### 테스팅
서비스들이 각각 분리가 되어 있고, 다른 서비스에 대한 종속성을 가지고 있기 때문에, 특정 사용자 시나리오나 기능을 테스트하고자 할 경우 여러 서비스에 걸처서 테스트를 진행해야 하기 때문에 테스트 환경 구축이나 문제 발생시 분리된 여러개의 시스템을 동시에 봐야 하기 때문에 테스팅의 복잡도가 올라간다.

### 운영
운영 관점에서는 서비스 별로 서로 다른 기술을 사용할 수 있으며, 시스템이 아주 잘게 서비스 단위로 쪼게 지기 때문에 운영을 해야할 대상 시스템의 개수가 늘어나고, 필요한 기술의 수도 늘어나게 된다.

### 서비스간 트렌젝션 처리
구현상의 가장 어려운 점중의 하나가, 트렌젝션 처리이다. 모노리틱 아키텍처에서는 RDBMS를 사용하면서 하나의 애플리케이션 내에서 트렌젝션이 문제가 있으면 쉽게 데이타베이스의 기능을 이용해서 rollback을 할 수 있었다. 여러개의 데이타베이스를 사용하더라도, 분산 트렌젝션을 지원하는 트렌젝션 코디네이터 (JTS – Java Transaction Service)등을 이용해서 쉽게 구현이 가능했는데, API 기반의 여러 서비스를 하나의 트렌젝션으로 묶는 것은 불가능하다.

사실 이 문제는 마이크로 서비스 아키텍처 이전에도, 서비스와 API를 기본 컨셉으로 하는 SOA에도 있었던 문제이다.

이러한 문제를 해결하기 위해서 몇가지 방안이 있는데, 그 첫번째 방법으로는 아예 애플리케이션 디자인 단계에서 여러개의 API를 하나의 트렌젝션으로 묶는 분산 트렌젝션 시나리오 자체를 없애는 방안이다. 트랜잭션 보장이 중요한 엔터프라이즈 시스템(금융이나 제조)에는 모노리틱 아키텍처로 접근하는 것이 낫다. 


----
해당 내용은 다음 글을 참고 하였습니다.
- https://bcho.tistory.com/948
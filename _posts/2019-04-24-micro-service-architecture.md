---
layout: post
title: 마이크로 서비스 아키텍쳐 (Micro Service Architecture)
tags:
 - msa
 - micero-service-architecture
comments: true
---

## 소개
대용량 웹서비스가 많아짐에 따라 정의된 아키텍처로써 서비스 지향 아키텍처(SOA: Srevice Oriented Architecture)를 근간으로 도메인을 기능별로 분리한 단위보다 더 작은 최소 단위가 된다. 기능일수도 있고 최소 함수 및 조직단위가 하나의 서비스가 될 수 있다.

## 모노리틱 아키텍쳐(Monolithic Architecture)
모노토릭은 완전히, 통인된, 단일 결정된 뜻으로 기존의 전통적인 웹 시스템 개발에 많이 사용된 스타일이다. 하나의 애플리케이션 내에 모든 로직들이 있는 통짜 구조의 아키텍쳐 이다. 상호 호ㅜㄹ을 하는 컴포넌트들이 함수호출을 통해 작용한다. 전체 애플리케이션을 하나로 처리하기 때문에 개발툴 등에서 하나의 애플리케이션만 개발하면 되고 배포 및 테스트도 하나의 애플리케이션만 수행한다.

### 장점 
규모가 작은 애플리케이션에서는 배포 및 운영 관리가 용이하고 매우 간단하다. 하나의 구조로 되어 있기 때문에 트랜잭션 관리 등이 용이하다. 


### 단점
컴포넌트들은 타이트한 연결로 전체 시스템 구조를 제대로 파악하지 못하는 경우 개발시에 모듈의 성능 문제나 장애가 다른 컴포넌트들에게 영향을 주게 되어 문제가 발생할 수 있다. 일부 컴포넌트에서만 수정이 이루어진 경우에도 전체를 통으로 배포해야 하므로 잦은 배포에 분리 하며 컴포넌트별로 특성에 맞게 다른 기술을 도입하고자 할때 유연하지 못하다. 또한 대형시스템에서 크기가 큰 경우 빌드, 배포시간, 서버기동시간이 오래 걸린다. 

## 서비스 지향 아키텍쳐(Service Oriented Architecture)
엔터프라이즈 시스템 중심


## 마이크로 서비스 아키텍쳐(Micro Service Architecture)
서비스 지향 아키텍쳐(SOA)에 근간을 두고 대용량 웹서비스 개발에 맞는 구조로 경량화되고 대규모 개발팀의 조직 구조에 맞도록 변형된 아키텍쳐 이다. 

### 서비스
시스템을 구성하고 있는 컴포넌트들을 하나의 서비스라는 개념으로 정의하는데 이떄 컴포넌트들은 데이터부터 비지니스로직까지 독립적으로 상호 컴포넌트들간에 의존성이 없는(수직적 분할) 상태로 RestAPI와 같은 표준 인터페이스를 통해 그 기능을 외부에 제공하며 API를 통해 타 서비스와 통신한다.

데이터 저장시에는 중앙집중화된 하나의 통 데이터베이스를 사용하는 것이 아닌, 서비스가 API에서 부터 데이터베이스까지 분리되는 수직분할원칙에 따라 서비스 별로 별도의 데이터베이스를 사용한다. 

### 장점
컴포넌트 별 의존성이 없기 때무에 독립적인 배포가 가능하다. 다른 서비스 컴포넌트에 대한 의존성이 없이 서비스를 독립적으로 개발 및 배포/운영할 수 있다. 서비스 부분만 재 배포 하면 되기 때문에, 빠르고 전체 시스템의 영향도를 최소화한 수준에서 배포를 진행할 수 있다.

서비스 별로 독립된 배포 구조는 확장성에 있어서도 많은 장점을 가지고 오는데, 부하가 많은 특정 서비스에 대해서만 확장이 가능하여 조금 더 유연한 확장 모델을 가질 수 있다. 모노리틱 아키텍쳐의 경우에는 특정 서비스의 부하가 많아서 성능 확장이 필요할 때, 전체 서버의 수를 늘리거나 각 서버의 CPU 수를 늘려줘야 하지만, 마이크로 서비스 아키텍쳐의 경우에는 부하를 많이 받는 서비스 컴포넌트 만 확장을 해주면 된다.

### 단점
다른 컴포넌트의 데이타를 API 통신을 통해서만 가지고 와야 하기 때문에 성능상 문제를 야기할 수 있고, 또한 이 기종 데이타 베이스간의 트렌젝션을 묶을 수 없는 문제점을 가지고 있다.



## API Gateway
마이크로 서비스 아키텍쳐 설계시 많이 언급되는 컴포넌트이다. 프록시처럼 API들 앞에서 모든 API대한 end-point를 통합하고 추가적인 기능을 제공하는 미들웨어로 SOA의 ESB(Enterprise Service Bus)의 경량화 버전이다. 

* 미들웨어(middleware)는 응용 소프트웨어가 운영 체제로부터 제공받는 서비스 이외에 추가적으로 이용할 수 있는 서비스를 제공하는 컴퓨터 소프트웨어

### ESB vs APIgateway
SOA 프로젝트의 실패중의 하나가 ESB로 꼽히는 경우가 많은데, 이는 ESB를 Proxy나 Gateway처럼 가벼운 연산만이 아니라, 여러개의 서비스를 묶는 로직에 무겁게 사용했기 때문이다. (사용하면 안된다는 것이 아니라 잘 사용해야 한다는 것이다.) ESB는 메세지를 내부적으로 XML로 변환하여 처리하는데, XML 처리는 생각하는것 보다 파싱에 대한 오버헤드가 매우 크다.  또한 ESB의 고유적인 버스나 게이트웨이로써의 특성이 아니라 타 시스템을 통합 하기 위한 EAI적인 역할을 ESB를 이용해서 구현함으로써 많은 실패 사례를 만들어 내었다. 그래서 종종 ESB는 Enterprise Service Bus가 아니라 EnterpriSe nightmare Bus로 불리기도 한다. 

이러한 개념적인 문제를 해결하기 위해서 나온 제품군이 apigateway라는 미들웨어 제품군들인데, ESB와 기본적인 특성은 유사하나 기능을 낮추고 EAI의 통합 기능을 제거하고 API 처리에만 집중한 제품군들로, 클라우드상에서 작동하는 PaaS (Platform As A Service)형태의 서비스로는 apigee.com이나 3scale.com 등이 있고, 설치형 제품으로는 상용 제품인 CA社의 Layer7이나 오픈소스인 Apache Service Mix, MuleSoft의 ESB 제품 그리고 WSO2의 API Platform 등이 있다.

Apigateway 부분에 마이크로 서비스 아키텍쳐의 다른 부분 보다 많은 부분을 할애한 이유는, 컴포넌트를 서비스화 하는 부분에 까지는 대부분 큰 문제가 없이 적응을 하지만 apigateway의 도입 부분의 경우, 내부적인 많은 잡음이 날 수 있고, 또한 도입을 했더라도 잘못된 설계나 구현으로 인해서 실패 가능성이 비교적 높은 모듈이기 때문이다. 마이크로 서비스 아키텍쳐의 핵심 컴포넌트이기도 하지만, 도입을 위해서는 팀의 상당 수준의 높은 기술적인 이해와 개발 능력을 필요로 한다.


### 주요 기능
Apigateway가 마이크로 서비스 아키텍쳐 상에서 수행하는 주요 기능은 다음과 같다.

#### EndPoint 통합 및 토폴로지 정리
마이크로 서비스 아키텍쳐의 문제점 중의 하나는 각 서비스가 다른 서버에 분리 배포 되기 때문에, API의 End point 즉, 서버의 URL이 각기 다르다는 것이다. API를 사용하는 클라이언트에서 서버간의 통신이나, 서버간의 API 통신의 경우 p2p(Point to Point)형태로 토폴로지가 복잡해지고 거미줄 모양의 서비스 컴포넌트간의 호출 구조는 향후 관리의 문제를 일으킬 수 있다. 하나의 end point를 변경하였을 때, 제대로 관리가 되지 않을 경우가 있다. 이러한 토폴로지상의 문제점을 해결하기 위해서 중앙에 서비스 버스와 같은 역할을 하는 채널을 배치 시켜서, 전체 토폴로지를 p2p에서 hub & spoke 방식으로 변환 시켜서, 서비스간 호출을 단순화 시킬 수 있다.


#### Orchestration
여러개의 서비스를 묶어서 하나의 새로운 서비스를 만드는 개념이다. 이는 마이크로 서비스 아키텍쳐가 서비스 자체가 작은 덩어리(fine grained) 형태로 잘게 쪼게졌기 때문에 가능한 일인데, 사실 orchestration을 api gateway 계층에서 하는 것은 gateway 입장에서 부담이 되는 일이다. 실제로 과거의 SOA 시절에 많은 ESB(Enterprise Service Bus) 프로젝트가 실패한 원인 중의 하나가 과도한 orchestration 로직을 넣어서 전체적인 성능 문제를 유발한 경우가 많았다. 그래서 orchestration 서비스의 활용은 마이크로 서비스 아키텍쳐에 대한 높은 이해와 api gateway 자체에 대한 높은 수준의 기술적인 이해를 필요로 한다.

실제로 넷플릭스의 경우 마이크로 서비스 아키텍쳐를 사용하면서, 여러개의 서비스들을 gateway 계층을 통해서 orchestration 하는 모델을 사용하고 있다. 


#### 공통 기능 처리 (Cross cutting function handling)
또한 API에 대한 인증 (Authentication)이나, Logging과 같은 공통 기능에 대해서 서비스 컴포넌트 별로 중복 개발해야 하는 비효율성을 유발할 수 있다. api gateway에서 이러한 공통 기능을 처리하기 되면, api 자체는 비지니스 로직에만 집중을 하여 개발에 있어서의 중복등을 방지 할 수 있다.

#### mediation(중재)
이외에도 XML이나 네이티브 메세지 포맷을 json등으로 상호 변환해주는 message transformation 기능이나, 프로토콜을 변환하는 기능, 서비스간의 메세지를 라우팅해주는 기능등 여러가지 고급 mediation 기능을 제공을 하지만, api gateway를 최대한 가볍게 가져간다는 설계 원칙 아래서 가급 적이면 고급적인 mediation 기능을 사용할 때는 높은 수준의 설계와 기술적인 노하우를 동반해야 한다.



### Conway’s Law (컨웨이의 법칙)
마이크로 서비스 아키텍쳐의 흥미로운 점중의 하나는 아키텍쳐 스타일의 조직 구조나 팀 운영 방식에 영향을 준다는 것인데, 마이크로 서비스 아키텍쳐는 컨웨이의 법칙에 근간을 두고 있다.

컨웨이의 법칙은
"모든 시스템은 그 조직의 의사소통 구조와 동일하게 만들어진다."
"소프트웨어의 구조는 그 소프트웨어를 만드는 조직의 구조와 일치한다"
라는 이론이다.

마이크로 서비스 아키텍쳐는 각 컴포넌트를 팀에 배치해서 책임지고 개발하는 것을 근간으로 하며, 팀간의 의존성을 제거해서 각 팀이 컴포넌트 개발을 독립적으로할 수 있는 구조로 잡혀있다.

## 마이크로 서비스 아키텍쳐의 문제점


해당 내용은 다음 글을 참고 하였습니다.
https://bcho.tistory.com/948
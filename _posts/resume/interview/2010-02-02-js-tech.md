---
layout: post
title: JS!
categories: Interview
---

## 웹페이지 렌더링

- 웹페이지의 마크업 요소들은 브라우저에 내장된 파서를 통해 돔 트리를 해석하여 오브젝트 모델들로 전환. (+스타일 구조체)
- 브라우저 내의 렌더링 엔진은 노드들과 스타일 정보를 가지는 렌더트리를 생성한다. 이때 실제 화면에 보여지는 요소들로만 구성된다. (display:none 제외)
- 렌더트리를 기반으로 브라우저의 뷰포트(Viewport) 내에서 각 노드들의 정확한 위치와 크기를 계산하여 화면의 정확한 위치에 표시된다. 이를 렌더트리 레이아웃(배치)이라고 한다.
- 따라서, viewport 크기가 달라질 경우 매번 계산을 다시해야한다.
- 레이아웃이 계산되면, 각 노드들은 정해진 스타일 및 위치값대로 화면에 그린다.
- 처리해야 하는 스타일이 복잡할수록 Paint 단계에 소요되는 시간이 늘어나게 된다.
- 단색 background-color의 경우 paint 속도가 빠르지만, 그라데이션이나 그림자 효과등은 painting 소요시간이 비교적 더 오래 소요됨.
- 마지막으로 합성!
- 렌더트리와 각 요소들의 크기와 위치를 다시 계산하면 레이아웃 과정이 다시 진행된다.

## 브라우저 엔진: 게코(ff) / 웹킷(chromium)

- 시각적으로 처리되는 렌더 트리: 형상 트리 (frame tree) / 렌더 트리 (render tree)
- 렌더 트리의 각 요소: 형상 (frame) / 렌더 객체 (render object)
- 배치: 리플로 (reflow) / 배치 (layout)

## 클로저

- 함수 자신이 포함하는 스코프의 변수들!을 추적하는 함수.
- 자신을 감싸고 있는 바깥 함수의 변수에 접근할 수 있는 내부의 함수.
- 만들어진 환경을 기억한다.
- 클로져에 의해 참조되기 때문에 가비지컬렌션 작동하지 않음. 메모리 누수가능
- 함수가 중첩되어 있으면 중첩될 때마다 부모 함수의 스코프가 자식 함수의 스코프에 포함된다.
- 함수 안에서 새로운 함수를 만들어서 변환하는 경우, 예외적으로 변수 접근이 가능하다.
- 값을 복사하지 않고 참조하고 있기 때문에 외부변수의 값을 변경 할 수도 있다.
- 값을 복사하지 않고 참조하고 있기 때문에 외부변수의 변경된 값을 바라볼 수 있다.
- 이전의 환경을 기억하려면 클로저 환경을 만들어 주어야 한다.
- 사용 예) 콜백함수 / 외부환경 종료 혹은 변경 / 지역변수
- 콜백함수로써 자신이 포함된 함수가 종료되더라도 그의 환경에 접근이 가능하다.
- 클로저는 함수가 선언될 때의 환경을 기억하고 있으므로, 콜백함수는 클로저라고 할 수 있다.
- 만들어진 환경이 종료되는 상황. 에를들면 for문이 끝나버림.
- 이경우 클로저 영역을 생성해주면 끝나버려도 그 만들어진 환경을 기억할 수 있다.
- 또, 내부에서만 사용되는 지역변수 감추기

```js
function callback(cb) {
  cb();
}
function add(x, y) {
  let sum = x + y;
  callback(function () {
    console.log(sum);
  });
}
add(3, 5);

////

function outerFunc() {
  const name = "jh";
  function print(text) {
    console.log(text);
  }
  return {
    innerFunc1: function () {
      const age = 30;
      print(`name :${name}`);
      print(`age :${age}`);
    },
  };
}

const out = outerFunc();
out.innerFunc1();
```

## 프리미티브(원시값 6가지)

- 객체가 아니면서 메서드도 가지지 않는 데이터.
- 6종류: string, number, bigint, boolean, undefined, symbol (null 제외)
- 모든 원시 값은 불변하여 변경할 수 없다.
- 이미 생성한 원시 값은 객체, 배열, 함수와는 달리 변형할 수 없다.
- 참고) JavaScript에서 안전한 최대 정수. (2^53 - 1)

## falsy value(8가지)

- 문맥에서 false로 평가되는 값.
- false "" 0 -0 null undefined NaN 0n

## 자바스크립트의 구동 원리의 목적

- 자바스크립트가 어떻게 구성되어 있고
- 구성 요소들이 서로 어떻게 맞물려 돌아가는지를 알아본다.
- 이를 이해함으로써 더 좋은 코드와 앱을 작성할 수 있다.
- 자바스크립트의 API를 이용해 블록킹이 없는, 더 나은 앱을 작성할 수 있게 될 것이다.

## 자바스크립트의 구동 원리

- V8엔진(메모리힙 + 콜스택): 메모리할당이 이루어지는 곳 & 코드가 실행되면서 스택 프레임이 쌓이는 곳
- 단일 쓰레드(single-threaded): 콜스택이 하나이다. 코드가 실행되면서 스택프레임이 쌓이는 공간이 하나이다. 프레임 하나씩만 처리 가능하다. 한번의 하나의 일만 할 수 있다.
- 콜스택에 실행할 함수가 있는 동안 다른 일을 할 수가 없다.
- 특정 코드 실행이 늦어지면? 블록킹된(blocked) 상태
- 이 상태에서 브라우저는 렌더링을 할 수도 없고 다른 코드를 수행할 수도 없다.
- 브라우저가 콜스택 내에 처리할 태스크가 너무 많아지기 시작하면 한참 동안 반응을 하지 않을 수 있다.
- 작업이 오래 걸리면 응답이 없다고 페이지 닫을거냐고 물어본다.
- 비동기 콜백: UI를 막지 않고 브라우저가 응답없음 상태에 빠지게 하지 않으면서도 무거운 코드를 수행한다.

## 자바스크립트 프로그램의 구성 요소

- 하나만 ‘지금' 실행되고
- 나머지는 ‘나중에' 실행한다.
- ‘지금' 완료!할 수 없는 작업은 비동기적으로 수행한다.
- 동기/비동기는 완료여부를 신경쓴다
- 블로킹/논블로킹은 작업을 기다린다 기다리지 않는다

## 브라우저가 제공하는 웹 API

- 콜백 큐(callback queue)를 이용
- 브라우저가 제공하는 웹 API: DOM(element event), AJAX, setTimeout 등
- 이벤트 루프 & 콜백 큐

## 이벤트루프

- 이벤트루프는 하나의 단순한 임무만 갖고 있다.
- 콜스택과 콜백큐(매크로큐 & 마이크로큐 & 애니메이션 프레임)를 감시한다.
- 만약 콜스택이 비어있으면 큐에서 첫 번째 이벤트를 가져다가 콜스택에 밀어 넣는다. 이벤트가 실행된다.
- 잡큐: 틱의 끝에 부착되어 있는 큐 (매크로큐실행마다 마이크로큐가 모두 실행됨)
- 이러한 반복을 틱(tick)이라고 한다.
- setTimeout의 경우 ms 이후에 실행될 것이라기 보다는 ms 이후에 큐에 추가될 것이라는 의미이다.
- 큐에는 이 보다 먼저 추가된 이벤트들도 존재할 수 있기 때문에 우리의 콜백은 실제로 실행되기 전에 다른 이벤트들이 끝날 때까지 기다려야 할 수도 있다.

## 자바스크립트 엔진

- 자바스크립트 코드를 실행하는 프로그램 혹은 인터프리터
- 코드를 바이트코드로 컴파일하는 저스트인타임(just-in-time) 컴파일로러로 구현
- v8은 jit컴파일로, 코드실행 시에 자바스크립트 코드를 머신 코드로 컴파일

## 메모리관리

- 메모리누수 대처법
- 가비지컬렉션: 객체나 문자열등이 생겨날때 메모리가 할당되며 더이상 사용되지 않을때(추정) 자동으로 메모리가 반환된다.
- 메모리관리를 신경쓰지 않아도 될까? 노노
- 가비지컬렉터는 어떤 메모리를 가리키는 모든 변수가 스코프를 벗어나게 됐을 때 처럼 더 이상 접근 불가능한 메모리를 수집한다.
- 객체는 만약 그것을 가리키는 참조가 하나도 없는 경우 가비지컬렉션 대상이 된다.
- 어떤 메모리 영역을 가리키는 변수는 아직 존재하지만 그것을 그 이후로 절대로 접근하지 않는 경우는 찾지 못한다.
- 가비지컬렉터는 예측이 어렵다.
- 가비지칼렉션이 정확히 언제 작동할지 알수 없다.
- 메모리누수(memory leaks): 전에는 프로그램에서 사용했다가 더 이상 필요하지 않지만, 아직 OS나 자유메모리 풀에 반환되지 않은 메모리 조각들을 말합니다.
- 잊혀진 타이머(setTimeout) 혹은 콜백함수: 가비지컬렉터는 이 핸들러나 그 내부의 것들을 가져가지 않는다.
- 코드를 컴파일하면 컴파일러는 원시 데이터타입을 검사해서 얼마나 많은 메모리가 필요할지 미리 계산한다.
- 메모리도 스택 구조를 가진다.
- 동적할당(런타임에 크기가 정해짐)하는 경우 힙 공간으로부터 할당받는다.

---
layout: post
title: 햇갈려!
categories: Interview
---


## ts
처음 Typescript를 사용했을 때 길어지는 코드를 보며 생산성이 저하된다는 생각을 했습니다. 그만큼 자바스크립트 코드는 짧고 간결했기 때문입니다. 하지만 typescript를 조금 더 사용해보며 런타임이 아닌 트랜스파일링 시점에서 에러를 잡아주고, 직관적으로 타입을 알 수 있는 코드는 장기적으로 생산성을 훨씬 올려준다는 것을 경험하게 되었습니다.


## 모듈로더
모듈 로더는 JavaScript 모듈을 런타임에 로드할 수 있게 만드는 구현체라고 생각하시면 됩니다. 즉, AMD의 모듈 로더는 RequireJS이고 ES6 방식의 모듈 로더는 네이티브 브라우저가 될 수 있겠죠. SystemJS는 모든 모듈을 로드할 수 있는 만큼 ES6, CommonJS, AMD 방식의 모듈 로더입니다.

## 웹팩
- 엔트리: 의존성 시작점 
- 아웃풋: 번들된 결과물
- 로더: js로 변경. 전처리기(es5문법변환, 스타일시트 동적으로 추가, css를 js로 변경)
- 플러그인: 번들된 결과물처리. 난독화하거나 특정 텍스트 추출
- 바벨을 태울때 node_modules를 제외하면 트랜스퍼되지 않음. 패키지가 es6로 작성되어 있으면 브라우저에 해석을 못하는 문제가 발생하기도 함

## 웹 서버로 요청

- 사용자는 주소창에 www.google.com을 입력한다.
- 브라우저는 해당 도메인을 HTTP 규약에 맞춰 데이터 패킷을 준비한다.
- 준비된 패킷은 랜선 혹은 AP를 통해 해당 지역의 Tier 3 ISP 까지 전달된다.
- 이때 클라이언트는 빠른 응답을 위해 Cache Server에 캐싱 해 놓은 결과가 있는지 먼저 확인하고 만약 캐시된 데이터가 있으면 더 진행하지 않고 이를 다시 클라이언트에 되돌려준다.
- ISP는 DNS를 겸하기도 하기 때문에 요청으로 들어온 www.google.com의 IP 주소를 확인한다.
- 만약 해당 DNS에 정보가 없다면 다른 DNS 서버에 해당 도메인이 있는지 확인한다.
- 216.58.220.142 가 www.google.com 의 IP 주소임을 브라우저가 알게 된다.
- 브라우저는 해당 IP 주소로 HTTP Request를 보낸다.
- Google의 WAS(Web Application Server)는 요청을 받아서 DB작업 필요하다면 이를 처리한다.
- 사용자 요청에 맞는 컨텐츠를 Status Code같은 내용과 함께 HTTP Response로 돌려 보낸다.
- 다시 수많은 Router들과 ISP를 거쳐 사용자의 브라우저에 컨텐츠가 도달한다.

## 웹 서버로부터 응답 받고 브라우저가 하는 일

- 처음 브라우저가 응답을 받으면, 브라우저가 가지고있는 파서를 이용해 HTML문서를 브라우저가 이해할 수 있는 DOM 트리 형식으로 파싱한다.
- CSS를 파싱하여 스타일 구조체의 형식으로 만든다. 이를 CSSOM이라고 한다.
- DOM과 CSSOM을 실제 화면에 표현하기 위한 데이터 구조인 렌더링 트리로 변환한다.
- 해당 렌더링 트리를 그리고 화면에 표시한다.

## rest

자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것

## http method

- head: 웹서버 정보확인, 헬스체크, 버젼확인, 최종 수정일자 확인등의 용도
- post: 자원 생성
- put: 전체 자원 수정
- patch: 일부 내용 교체
- trace: 루프백 호출을 위해 테스트용으로 사용
- options 지원되는 메소드 종류 확인

## http code

- 301 Moved Permanently(영구이동): 308에러코드와 동일. URL변경으로 리디렉션을 할 때 사용
- 302 Found(임시이동): 307에러코드와 동일하지만 차이는 302는 예상안되고 307은 예상된다.
- 304 Not Modified: 캐시목적
- 307 Temporary Redirect: (http -> https)

## cors 허용

- SOP: same-origin policy 동일출처정책
- CORS: Cross-Origin Resource Sharing 교차 출처 리소스 공유
- 기본 자바스크립트를 사용해 보내는 크로스 오리진 요청의 경우 기본적으로 쿠키나 HTTP 인증 같은 쿠키와 같은 자격 증명(credential)이 함께 전송되지 않는다.
- Access-Control-Allow-Origin는 \* 모든 출처를 허용한다는 의미기 때문에, 다른 출처에서 리소스를 요청할 때 CORS 정책 위반으로 인한 제약을 받지 않는다.
- 자격증명이 있는 경우 특정 origin으로 적용 필요하다.
- Access-Control-Allow-Credentials: true

## 쿠키 & 세션

HTTP 프로토콜은 모든 요청 간 의존관계가 없습니다. 계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 단점이 있습니다. 이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 합니다. HTTP 프로토콜에서 상태를 유지하기 위한 기술로 쿠키와 세션이 존재합니다.

- 쿠키는 웹브라우저(클라이언트)에서 관리하고 있다가, 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송. 데이터교환 목적.
- 세션은 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술로, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다. 서버자원사용
- Web Storage 쿠키의 제한점을 보완하기 위하여 html5에서 등장

## js async & defer!!

- async(DOMContentLoaded 후)와 defer(DOMContentLoaded 전) 스크립트는 다운로드 시 페이지 렌더링을 막지 않는다는 공통점
- 브라우저는 defer 속성이 있는 스크립트(이하 defer 스크립트 또는 지연 스크립트)를 '백그라운드’에서 다운로드 합니다. 따라서 지연 스크립트를 다운로드 하는 도중에도 HTML 파싱이 멈추지 않습니다. 그리고 defer 스크립트 실행은 페이지 구성이 끝날 때까지 지연 됩니다.지연 스크립트는 페이지 생성을 절대 막지 않습니다. 지연 스크립트는 DOM이 준비된 후에 실행되긴 하지만 DOMContentLoaded 이벤트 발생 전에 실행됩니다.
- async 속성이 붙은 스크립트(이하 async 스크립트 또는 비동기 스크립트)는 페이지와 완전히 독립적으로 동작합니다. 페이지 구성이 끝난 후에 async 스크립트 다운로딩이 끝난 경우, DOMContentLoaded는 async 스크립트 실행 전에 발생할 수 있습니다,
- 동적 스크립트는 기본적으로 ‘async’ 스크립트처럼 행동합니다.

## 버전닝(Semantic Versioning)

- ~p 틸드 패치
- ^m 캐럿 마이너

## 브라우저

- 화면크기: innerHeight
- 문서 가시적 크기: body.clientHeight
- 문서 스크롤 포함한 크기: body.offsetHeight

## 엘리먼트

- 엘리먼트 패딩만 포함 clientWidth (엘리먼트 크기)
- 앨리먼트 마진만 제외 offsetWidth (패딩 보더 포함한 엘리먼트 전체 크기)
- 보이는것 이상의 스크롤로 감싸진 영역 scrollWidth (숨겨진 영역 포함)

## 애니메이션

- 자연스러운 움직임: 초당 60프레임 (16.67ms)
- 자바스크립트는 메인스레드, css애니메이션 속성은 컴포지터 스레드

## 렌더링

- Style: 현재 버전의 CSS를 어떤 DOM 요소에 적용해야 할지 계산합니다.
- Layout: 각 요소의 너비나 위치를 갱신에 화면 상에 배치합니다.
- Paint: 각 요소에 배경색, 글자 색과 같이 픽셀을 채우는 과정입니다.
- Composite: 이전 과정에서 생성된 레이어를 병합합니다. 위 과정의 처리 시간이 16.7ms 을 초과하는 횟수가 늘어날수록 전체 렌더링 시간이 지연됩니다. 결국 앞서 나온 애니메이션 예제와 같이 여행자가 인지할만큼 반응이 느려지는 결과를 가져옵니다.

## reflow & repaint

- reflow란? 생성된 DOM 노드의 레이아웃(너비, 높이 등) 변경 시 영향받는 모든 노드(자식, 부모)의 수치를 다시 계산하여 렌더 트리를 재생성하는 작업입니다.
- repaint란? reflow 과정이 끝난 후 재생성된 렌더 트리를 다시 그리는 작업으로 수치와 상관없는 background-color, visibility, outline 등의 스타일 변경시에는 reflow 과정이 생략 된 repaint 작업만 수행합니다.

reflow를 피하거나 최소화하는 방법

1. 클래스 변화에 따른 스타일 변화를 원할 경우, 최대한 DOM 구조 상 끝단에 위치한 노드에 추가합니다.
2. 애니메이션이 들어간 엘리먼트는 가급적 position: fixed 또는 position: absolute로 지정합니다.
3. JS를 통해 스타일변화를 주어야 할 경우, 가급적 한번에 처리합니다.
4. 인라인 스타일을 최대한 배제합니다. (개별말고 한번에)
5. 테이블 레이아웃을 피하는 것이 좋습니다. (레이아웃)
6. CSS 하위선택자는 필요한 만큼 정리하는 것이 좋습니다. (css 재계산 최소화)
7. requestAnimationFrame 사용(60프레임 보장)

## 이미지 배율

같은 면적에서 해상도가 높아지면 이미지는 압축되어 사이즈가 작게 보인다.

- mdpi: 중간밀도 1x
- hdpi: 고밀도 1.5x

## 동기 /비동기 & 클로킹 / 논블로킹

- Blocking/NonBlocking은 호출한 입장에서의 호출되는 함수가 바로 리턴하는지 하지않는지/하는지
- Sync/Async는 처리되는 방식은 함수완료여부를 신경쓰는지/쓰지않는지

- Blocking: 호출되는 함수가 바로 리턴하지 않는다.
- NonBlocking: 호출되는 함수는 바로 리턴한다.
- Synchronous: 호출하는 함수는 작업 완료 여부를 신경쓴다.
- Asynchronous: 호출하는 함수는 작업 완료 여부를 신경쓰지 않는다.

## 프로토타입 객체의 속성

Prototype Object는 일반적인 객체와 같으며 기본적인 속성으로 constructor와 **proto**를 가지고 있습니다.

- constructor: 생성자로써, 자신을 만들어낸 객체와 연결된 속성
- **proto**: 상위 객체. 객체를 만들어내기 위해 사용된 객체원형에 대한 숨겨진 연결. 자신을 만들어낸 객체의 원형(Prototype Link)
- prototype: 자기 자신. 자신을 통해 만들어질 객체의 원형(Prototype Object)

## 클로저

클로저는, `함수 자신이 포함하는 스코프의 변수들!을 추적하는 함수`입니다. 함수가 중첩되어 있으면 중첩될 때마다 부모 함수의 Scope가 자식 함수의 스코프 체인(스코프 프로퍼티)에 포함됩니다.

- 자바스크립트 함수는, 호출되었을 때 실행되기 위한 코드뿐만 아니라, 더 많은 정보를 포함하고 있기 때문에 만들어진 환경을 기억한다고 할 수 있습니다. (이때, 메모리 소모)
- 자바스크립트 함수는, 해당 스코프에 선언되어 어떤 변수더라도, 내부적으로 보관합니다.
- 따라서 스코프 내에 포함된 어떤 변수라도 참조할 수 있고
- 값을 복사하지 않고 참조하고 있기 때문에 외부변수의 값을 변경 할 수도 있습니다.
- 클로저를 통해 내부 변수를 참조하는 동안에는 해당 변수가 차지하는 메모리를 GC가 회수하지 않으므로 클로저 사용이 끝나면 참조를 제거하는 것이 좋습니다.
- 클로저는 함수내의 지역변수를 감추는 은폐의 역할을 가능하게 합니다.
- 복잡한 코드를 쉽고 간결한 코드를 작성할 수 있습니다. (객체반환x, 함수반환o)
- 자바스크립트에서 클로저가 많이 사용되는 부분은 이벤트 그리고 비동기식 호출의 경우라고 할 수 있습니다.

클로저는 `자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수`라고 정의 할 수 있습니다. 외부함수를 실행하면서 생성되는 지역변수 객체는 스코프체인에 들어가게 되고, 내부함수의 스코프 체인으로 참조됩니다. 외부함수는 종료되었지만 여전히 내부함수 스코프 체인으로 참조되므로 가비지 컬렉션의 대상이 되지 않아 여전히 접근이 가능 한 것입니다.

## 캐시!!

- no-store: 캐시를 전혀 하지 않겠다.
- max-age=<seconds>: 일정기간(시간, 초)동안 캐시를 적용하겠다. (캐시유효시간 지정)
- no-cache: 캐시가 유효한지 항상 확인한다. 캐시를 할 건데, 항상 서버에 한번 물어보겠다.
- must-revalidate
  캐시는 사용하기 이전에 기존 리소스의 상태를 반드시 확인해야 하며 만료된 리소스는 사용되어서는 안된다.
- Vary: 헤더 이름은 쉼표로 구분되며 캐시 된 응답을 사용할 수 있는지 여부를 결정할 때 사용. \*은 각 요청에 대해서 유일하며 캐시 할 수 없는 요청으로 간주한다. (= Cache-Control: no-store 를 사용 하는것이 객체를 저장하면 안된다는 의미로 좀더 명확하게 표시되고 읽을 수 있다. )
- Pragma는 HTTP/1.0 의 Pragma 헤더는 요청-응답 체인에 다양한 영향을 줄 수 있는 구현관련 헤더이다. 이것은 HTTP/1.0 버전에서 HTTP/1.1 버전의 Cache-Control 헤더가 생기기 전 그것과 동일한 역할을 하는 대용 헤더로 사용되었습니다.
- Expires 헤더는 응답이 더 이상 신선하지 않다고 판단할 날짜/시간을 포함합니다.
- (Server) Last-Modified & (Client) If-Modified-Since: 서버는 파일의 수정시간을 내려주고 클라이언트는 이후에 수정된거 있어? 라고 물어본다. 있으면 200, 없다면 304. 시간을 비교하는 것이기 때문에 부정확하다. 오차가 존재한다.
- (Server) ETag & (Client) If-None-Match: 서버가 특정 버전의 리소스를 식별하는 식별자를 내려주고 클라이언트는 서버에게 ETag를 다시 전달하여, ETag가 달라졌는 지 검사해서 다를 경우에만 컨텐츠를 새로 내려준다.

## 브라우저 웹서버 동작!!

- 호스트 dns
- tcp
- http https
- 렌더링

## location

- hostname: 도메인 이름
- host: 도메인 + 포트까지

---
layout: post
title: 햇갈려!
categories: Interview
---

# http

## 웹 서버로 요청

- 사용자는 주소창에 www.google.com을 입력한다.
- 브라우저가 URL을 해석한다. (문법에 맞지 않으면 검색엔진으로 요청됨)

```
scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]
```

- 브라우저 캐시 확인 & 로컬 host파일 에서 도메인 확인
- DNS(Domain Name Server) 조회하여 IP를 얻는다.

```
IP: 리소스들에게 접근하기 위해서는 해당하는 리소스가 어디있는지 알아야한다. 클라이언트가 인터넷에 연결된 기기를 식별하기 위해 기기들이 가지고 있는 유일한 번호이다.

DNS 순서(역트리): 루트네임서버 -> 최상위도메인(국가명) -> 2단계네임서버
```

- ARP를 통해 네트워크 상에서의 할당받은 IP의 물리적인 주소인 mac 어드레스를 얻는다

```
ARP: 주소 결정 프로토콜(Address Resolution Protocol, ARP)은 네트워크 상에서 IP 주소를 물리적 네트워크 주소로 대응(bind)시키기 위해 사용되는 프로토콜이다. 여기서 물리적 네트워크 주소는 이더넷 또는 토큰링의 48 비트 네트워크 카드 주소를 뜻한다.

MAC 주소: 네트워크 상에서 서로를 구분하기 위하여 Device 마다 할당된 물리적인 주소. 네트워크 세그먼트의 데이터 링크 계층에서 통신을 위한 네트워크 인터페이스에 할당된 고유 식별자이며 네트워크 노드는 여러 개의 NIC를 가질 수 있으며, 각 NIC는 고유한 MAC 주소를 가진다.
```

- 대상과 TCP 통신을 통해 Socket을 연다. (HTTP의 기본값은 80, HTTPS의 기본값은 443. 3Way Hand-Shaking)

```
3Way Handshake: TCP Socket 연결을 하여, 데이터를 전송하기 위해서 발생한다. 4Way는 응답을 기다리고 난 후 통신 종료를 알림. fin

1. 클라이언트는 서버에게 통신을 시작한다는 것을 알린다. syn
2. 서버는 클라이언트에게 응답함과 동시에 클라이언트에게 통신을 시작함을 알린다. syn + ack
3. 클라이언트는 서버에게 응답한다. ack (연결 성립 establish)

```

- HTTPS인 경우 TLS(Transport Layer Security) handshake가 추가된다.
- HTTP 프로토콜로 요청한다.
- HTTP 서버가 응답한다.
- 브라우저가 그린다. 서버가 리소스(HTML, CSS, JS, Image 등)를 브라우저에 제공하면 브라우저는 Rendering Engine을 통해 아래 프로세스를 수행한다.

## 웹 서버로부터 응답 받고 브라우저가 하는 일

- 처음 브라우저가 응답을 받으면, 브라우저가 가지고있는 파서를 이용해 HTML문서를 브라우저가 이해할 수 있는 DOM 트리 형식으로 파싱한다.
- CSS를 파싱하여 스타일 구조체의 형식으로 만든다. 이를 CSSOM이라고 한다.
- DOM과 CSSOM을 실제 화면에 표현하기 위한 데이터 구조인 렌더링 트리로 변환한다.
- 해당 렌더링 트리를 그리고 화면에 표시한다.

```
1. DOM트리 생성
2. 스타일 구조체 생성
3. 렌더트리 생성 (스타일 재계산)
4. 레이아웃 처리 -> (위치 크기 등의 렌더트리가 변경되어 좌표재계산) 리플로우
5. 페인트 -> 리페인트
6. 합성
```

## 강제 동기식 레이아웃

스타일 재계산이 이루어지는 경우, DOM을 수정하게 되면, 직전 레이아웃은 효력이 없어지며 reflow가 일어난다. 브라우저가 열심히 스타일을 계산해 위치를 정하고 있는데 스타일 정보를 조회하거나 변경하는 경우를 강제 동기식 레이아웃이라고 한다. (Forced Synchronous Layout) 이것이 반복됨(레이아웃 스레싱)으로서 성능 저하가 유발된다.

- 이 때문에 항상 스타일 읽기를 일괄 처리하고 먼저 수행한 다음(이때 브라우저가 이전 프레임의 레이아웃 값을 사용할 수 있음) 쓰기를 수행해야 한다.

## 서버로부터 이미지 다운로드 후에 브라우저에서 일어나는 일

브라우저에서 URL 정보를 이용해 서버에 요청을 보내면 마크업 데이터가 브라우저에 도착합니다. 이때 xxx.gif라는 이미지 파일을 다운로드하는 태그를 만났을 때 브라우저의 처리 절차는 다음과 같습니다.

1. Expires 정보 확인
   브라우저가 xxx.gif 파일을 서버에 요청하기 전에 사용자 PC에 저장된 Expires 정보(만료 날짜)를 확인합니다. Expires 정보가 있고 설정한 기한이 남았다면 사용자 PC의 xxx.gif 파일을 사용하게 됩니다. 이 단계가 네트워크 통신 단계의 Cache Read 단계입니다.

2. If-Modified-Since 정보 확인
   Expires 정보가 없거나 기한이 지났으면 If-Modified-Since 정보(마지막으로 수정한 날짜)가 있는지 확인합니다. If-Modified-Since 정보가 없으면 서버에 요청해 이미지를 받게됩니다. 이때 상태 코드는 '200 OK'입니다. If-Modified-Since 정보가 있으면 If-Modified-Since 정보를 서버에 보냅니다.

3. If-Modified-Since 정보와 Last-Modified 정보 비교
   서버는 브라우저가 보낸 If-Modified-Since 정보를 Last-Modified 정보(서버에 저장된 마지막 수정 날짜)와 비교합니다. 수정한 날짜가 같다면 상태 코드 '304 Not Modified'를 보내 사용자 PC에 있는 파일을 사용하게 합니다. 날짜가 다르다면 서버에서 파일을 보냅니다. 이때 상태 코드는 200 OK 입니다.

이 과정에서 알 수 있듯이 사용자 PC에 캐시 파일이 있고 Expires 정보가 유효하다면 해당 파일을 서버에 요청하지 않고 캐시에 저장된 파일을 이용합니다. 이러면 동적인 이미지 등을 제외한 나머지 정적인 요소(이미지, 스타일시트, 자바스크립트 등)는 별도로 서버에 요청하지 않기 때문에 로딩 속도를 크게 향상 시킬 수 있습니다.

사용자가 서비스를 처음 방문했을 때는 캐시가 없는 상태이기 때문에 큰 효과를 거둘 수 없겠지만, 캐시를 올바르게 설정했다면 그 이후에는 웹 서비스의 응답 속도를 개선하는 데 큰 도움을 줄 것입니다.

## 캐시

- max-age=seconds: 일정기간(시간, 초)동안 캐시를 적용하겠다. (캐시유효시간 지정)
- no-store: 캐시를 전혀 하지 않겠다. 캐시가 그 응답의 사본을 만드는 것을 금지한다.
- no-cache: 응답은 로컬 캐시 저장소에 저장될 수 있다. 다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없다. 캐시가 유효한지 항상 확인한다. 캐시를 할 건데, 항상 서버에 한번 물어보겠다.
- must-revalidate: 만료된 캐시만 서버에 확인한다. 캐시는 사용하기 이전에 기존 리소스의 상태를 반드시 확인해야 하며 만료된 리소스는 사용되어서는 안된다.
- age 헤더! 캐시 응답 때 나타나는데, max-age 시간 내에서 얼마나 흘렀는지 초 단위로 알려줍니다. 위 예제에서 max-age= 3600을 설정한 경우, 1분이 지나면 Age: 60 이 캐시 응답 헤더에 포함됩니다.
- expires 헤더!는 Cache-Control과 별개로 응답에 Expires라는 헤더를 줄 수도 있습니다. Expires: Thu, 26 Jul 2018 07:28:00 GMT 응답 컨텐츠가 언제 만료되는지를 나타내며, Cache-Control의 max-age가 있는 경우 이 헤더는 무시됩니다.
- Expires 헤더는 응답이 더 이상 신선하지 않다고 판단할 날짜/시간을 포함합니다.
- Vary: 헤더 이름은 쉼표로 구분되며 캐시 된 응답을 사용할 수 있는지 여부를 결정할 때 사용. \*은 각 요청에 대해서 유일하며 캐시 할 수 없는 요청으로 간주한다. (= Cache-Control: no-store 를 사용 하는것이 객체를 저장하면 안된다는 의미로 좀더 명확하게 표시되고 읽을 수 있다. )
- Pragma는 HTTP/1.0 의 Pragma 헤더는 요청-응답 체인에 다양한 영향을 줄 수 있는 구현관련 헤더이다. 이것은 HTTP/1.0 버전에서 HTTP/1.1 버전의 Cache-Control 헤더가 생기기 전 그것과 동일한 역할을 하는 대용 헤더로 사용되었습니다.
- (Server) Last-Modified & (Client) If-Modified-Since: 서버는 파일의 수정시간을 내려주고 클라이언트는 이후에 수정된거 있어? 라고 물어본다. 있으면 200, 없다면 304. 시간을 비교하는 것이기 때문에 부정확하다. 오차가 존재한다.
- (Server) ETag & (Client) If-None-Match: 서버가 특정 버전의 리소스를 식별하는 식별자를 내려주고 클라이언트는 서버에게 ETag를 다시 전달하여, ETag가 달라졌는 지 검사해서 다를 경우에만 컨텐츠를 새로 내려준다.

응답 헤더에 Last-Modified, Etag, Expires, Cache-Control:max-age 항목이 존재 한다면 복사본을 생성하고 값을 저장 )

## HTTP 요청 줄이기

- 이미지스프라이팅: 큰 이미지에 좌표값을 지정한다
- 도메인 샤딩: 커넥션 수를 늘린다
- 압축: 전송되는 데이터용량을 줄인다.
- 데이터 URI스킴 사용: 소스코드 내 삽입하여 base64인코딩으로 이미지를 적용한다. 단점은 캐시되지 않고 파일 용량 증가

```html
<img src="data:image/png;base64, iVBORw0KGgoAAAANSUhE~~" />
```

- HTML구조와 CSS스타일 렌더링시, 자바스크립트를 만나면 js완료전가지 렌더링이 블록(렌더링 블로킹)된다. 스크립트 삽입 위치에 따라 스크립트 실행순서와 브라우저렌더링에 영향을 줄 수 있다. (defer는 외부자원비동기로딩 html파싱후 스크립트 실행 / async는 외부자원비동기로딩 받는 즉시 스크립트 실행)

## rest(Representational State Transfer)

클라이언트와 서버 간에 `데이터를 주고받기 위한 URL 규칙`입니다. 리소스 자체를 전송하는 것이 아닌 리소스 표현을 전송합니다. 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것

- 자원URI + 행위Method + 표현Json
- 동사보다는 명사를
- 대문자보다는 소문자로
- 밑줄보다는 하이픈을

## http method

- head: 헤더정보만 반환. 웹서버 정보확인, 헬스체크, 버젼확인, 최종 수정일자 확인등의 용도. 요청에 대한 유효성, 접근성을 확인할 때 사용
- post: 자원 생성
- put: `전체` 자원 수정
- patch: `일부` 내용 교체
- trace: 루프백 호출을 위해 테스트용으로 사용
- options 지원되는 메소드 종류 확인. 통신에 대한 정보제공
- connect: SSL tunneling 에 사용되는 method

## http code

- 301 Moved Permanently(영구이동): 308에러코드와 동일. URL변경으로 리디렉션을 할 때 사용
- 302 Found(임시이동): 307에러코드와 동일하지만 차이는 302는 예상안되고 307은 예상된다.
- 304 Not Modified: 캐시목적
- 307 Temporary Redirect: (http -> https)

## cors 허용

- SOP: same-origin policy 동일출처정책
- CORS: Cross-Origin Resource Sharing 교차 출처 리소스 공유
- 기본 자바스크립트를 사용해 보내는 크로스 오리진 요청의 경우 기본적으로 쿠키나 HTTP 인증 같은 쿠키와 같은 자격 증명(credential)이 함께 전송되지 않는다.
- Access-Control-Allow-Origin는 \* 모든 출처를 허용한다는 의미기 때문에, 다른 출처에서 리소스를 요청할 때 CORS 정책 위반으로 인한 제약을 받지 않는다.
- 자격증명이 있는 경우 특정 origin으로 적용 필요하다.
- Access-Control-Allow-Credentials: true

## 쿠키 & 세션

HTTP 프로토콜은 모든 요청 간 의존관계가 없습니다. 계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 단점이 있습니다. 이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 합니다. HTTP 프로토콜에서 상태를 유지하기 위한 기술로 쿠키와 세션이 존재합니다.

- 쿠키는 웹브라우저(클라이언트)에서 관리하고 있다가, 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송. 데이터교환 목적.
- 세션은 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술로, 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다. 서버자원사용
- Web Storage 쿠키의 제한점을 보완하기 위하여 html5에서 등장

### 세션

- 클라이언트 정보를 서버에 저장.
- 로그인 정보처럼 페이지를 이동하더라도 계속 유지되어야 하는 정보를 저장한다.
- 브라우저마다 별도 세션 가진다.
- 브라우저 종료할때까지 유지된다.
- 세션아이디를 주고 받기도 한다.
- 단점은, 서버의 메모리를 사용하는 것이기 때문에 서버자원 문제 및 서버에 있는 정보 처리가 요구되어 속도가 느려질 수 있다.
- 세션아이디만 쿠키에 저장해서 사용하면 비교적 보안에 좋다.

### 쿠키

- 서버와 클라이언트 간의 지속적인 데이터 교환 목적으로 사용한다.
- 브라우저에 파일 형태로 저장한다.
- 파일로 저장되기 때문에 브라우저 종료해도 정보는 남아 있다
- 서버 요청시마다 함께 전송되며 문자열만 저장 가능하다. (4KB)
- 서버통신에 필요없는 데이터를 전송하게되면 데이터가 낭비된다.
- 팝업창 일정기간 보이지 않기, 서버통신에 필요한 인증과 관련된 정보나 세션에 저장된 토큰값을 저장하는데 활용된다.

### 웹 스토리지(로컬스토리지 / 세션스토리지)

- 쿠키의 제한점을 보완하기 위하여 등장하였다.
- 용량도 커졌고 서버로는 전달되지 않고 브라우저 로컬에만 저장되어 보안이 보장된다.
- 윈도우객체안에 들어있다.
- 자바스크립트 객체저장이 가능하다.

### 로컬스토리지

- 삭제하기 전까지 브라우저에 계속 저장되어 있다. (10MB)

### 세션스토리지

- 세션 유지기간에만 사용하능한 스토리지로 브라우저를 종료하면 자동 소멸한다. (5MB)

# Web

## 가상돔

일반적으로 dom에 접근하여 여러번의 속성 변화, 여러번의 스타일 변화를 수행하면 그에따라 여러번의 Reflow, Repaint가 발생하게 됩니다. 하지만 Virtual DOM은 이렇게 변화가 일어나 Reflow, Repaint가 필요한 것들을 한번에 묶어서 dom에 전달하게 됩니다. 따라서 처리되는 Reflow, Repaint의 규모가 커질 수는 있지만 한번만 연산을 수행하게 됩니다. 이를 통해 여러번 Reflow, Repaint를 수행하며 연산이 반복적으로 일어나는 부분이 줄어들어 성능이 개선됩니다. 돔을 쉽게 조작하고, 실제 돔을 변경하면서의 불필요한 렌더링을 최소화시킵니다.

## 리엑트 생명주기

- counstructor
- `componentWillMount`(v17 deprecated)
- render
- componentDidMount
- `componentWillReceiveProps(nextProps)`(v17 deprecated -> getDerivedStateFromProps)
- shouldComponentUpdate(nextProps, nextState)
- `componentWillUpdate`(v17 deprecated -> getSnapshotBeforeUpdate)
- render
- componentDidUpdate(prevProps, prevState)
- componentWillUnmount

## ts

처음 Typescript를 사용했을 때 길어지는 코드를 보며 생산성이 저하된다는 생각을 했습니다. 그만큼 자바스크립트 코드는 짧고 간결했기 때문입니다. 하지만 typescript를 조금 더 사용해보며 런타임이 아닌 트랜스파일링 시점에서 에러를 잡아주고, 직관적으로 타입을 알 수 있는 코드는 장기적으로 생산성을 훨씬 올려준다는 것을 경험하게 되었습니다.

## 모듈로더

모듈 로더는 JavaScript 모듈을 런타임에 로드할 수 있게 만드는 구현체라고 생각하시면 됩니다. 즉, AMD의 모듈 로더는 RequireJS이고 ES6 방식의 모듈 로더는 네이티브 브라우저가 될 수 있겠죠. SystemJS는 모든 모듈을 로드할 수 있는 만큼 ES6, CommonJS, AMD 방식의 모듈 로더입니다.

## 웹팩

- 엔트리: 의존성 시작점
- 아웃풋: 번들된 결과물
- 로더: js로 변경. 전처리기(es5문법변환, 스타일시트 동적으로 추가, css를 js로 변경)
- 플러그인: 번들된 결과물처리. 난독화하거나 특정 텍스트 추출
- 바벨을 태울때 node_modules를 제외하면 트랜스퍼되지 않음. 패키지가 es6로 작성되어 있으면 브라우저에 해석을 못하는 문제가 발생하기도 함

## 브라우저

- 화면크기: innerHeight
- 문서 가시적 크기: body.clientHeight
- 문서 스크롤 포함한 크기: body.offsetHeight

## 엘리먼트

- 엘리먼트 패딩만 포함 clientWidth (엘리먼트 크기)
- 앨리먼트 마진만 제외 offsetWidth (패딩 보더 포함한 엘리먼트 전체 크기)
- 보이는것 이상의 스크롤로 감싸진 영역 scrollWidth (숨겨진 영역 포함)

## 애니메이션

- 자연스러운 움직임: 초당 60프레임 (16.67ms)
- 자바스크립트는 메인스레드, css애니메이션 속성은 컴포지터 스레드

## 렌더링

- Style: 현재 버전의 CSS를 어떤 DOM 요소에 적용해야 할지 계산합니다.
- Layout: 각 요소의 너비나 위치를 갱신에 화면 상에 배치합니다.
- Paint: 각 요소에 배경색, 글자 색과 같이 픽셀을 채우는 과정입니다.
- Composite: 이전 과정에서 생성된 레이어를 병합합니다. 위 과정의 처리 시간이 16.7ms 을 초과하는 횟수가 늘어날수록 전체 렌더링 시간이 지연됩니다. 결국 앞서 나온 애니메이션 예제와 같이 여행자가 인지할만큼 반응이 느려지는 결과를 가져옵니다.

## reflow & repaint

- reflow란? 생성된 DOM 노드의 레이아웃(너비, 높이 등) 변경 시 영향받는 모든 노드(자식, 부모)의 수치를 다시 계산하여 렌더 트리를 재생성하는 작업입니다.
- repaint란? reflow 과정이 끝난 후 재생성된 렌더 트리를 다시 그리는 작업으로 수치와 상관없는 background-color, visibility, outline 등의 스타일 변경시에는 reflow 과정이 생략 된 repaint 작업만 수행합니다.

reflow를 피하거나 최소화하는 방법

1. 클래스 변화에 따른 스타일 변화를 원할 경우, 최대한 DOM 구조 상 끝단에 위치한 노드에 추가합니다.
2. 애니메이션이 들어간 엘리먼트는 가급적 position: fixed 또는 position: absolute로 지정합니다.
3. JS를 통해 스타일변화를 주어야 할 경우, 가급적 한번에 처리합니다.
4. 인라인 스타일을 최대한 배제합니다. (개별말고 한번에)
5. 테이블 레이아웃을 피하는 것이 좋습니다. (레이아웃)
6. CSS 하위선택자는 필요한 만큼 정리하는 것이 좋습니다. (css 재계산 최소화)
7. requestAnimationFrame 사용(60프레임 보장)

## 이미지 배율

같은 면적에서 해상도가 높아지면 이미지는 압축되어 사이즈가 작게 보인다.

- mdpi: 중간밀도 1x
- hdpi: 고밀도 1.5x

## 동기 /비동기 & 클로킹 / 논블로킹

- Blocking/NonBlocking은 호출한 입장에서의 호출되는 함수가 바로 리턴하는지 하지않는지/하는지
- Sync/Async는 처리되는 방식은 함수완료여부를 신경쓰는지/쓰지않는지

- Blocking: 호출되는 함수가 바로 리턴하지 않는다.
- NonBlocking: 호출되는 함수는 바로 리턴한다.
- Synchronous: 호출하는 함수는 작업 완료 여부를 신경쓴다.
- Asynchronous: 호출하는 함수는 작업 완료 여부를 신경쓰지 않는다.

## location

- hostname: 도메인 이름
- host: 도메인 + 포트까지

## Canvas & SVG

- Canvas(비트맵 jpg-pixel): 성능이 중요한 경우 활용, 빠른 대용량 데이터 처리에 적합, 동적인 데이터. 픽셀수가 많은 경우
- SVG(백터 ai-shape): 디자인 및 요소별 커스터마이징 가능, 고품질 다양한 해상도에 적합, 정적인 데이터. 픽셀수가 적은 경우

# JS

## 프로토타입 객체의 속성

Prototype Object는 일반적인 객체와 같으며 기본적인 속성으로 constructor와 **proto**를 가지고 있습니다.

- constructor: 생성자로써, 자신을 만들어낸 객체와 연결된 속성
- **proto**: 상위 객체. 객체를 만들어내기 위해 사용된 객체원형에 대한 숨겨진 연결. 자신을 만들어낸 객체의 원형(Prototype Link)
- prototype: 자기 자신. 자신을 통해 만들어질 객체의 원형(Prototype Object)

## 클로저

클로저는, `함수 자신이 포함하는 스코프의 변수들!을 추적하는 함수`입니다. 함수가 중첩되어 있으면 중첩될 때마다 부모 함수의 Scope가 자식 함수의 스코프 체인(스코프 프로퍼티)에 포함됩니다.

- 자바스크립트 함수는, 호출되었을 때 실행되기 위한 코드뿐만 아니라, 더 많은 정보를 포함하고 있기 때문에 만들어진 환경을 기억한다고 할 수 있습니다. (이때, 메모리 소모)
- 자바스크립트 함수는, 해당 스코프에 선언되어 어떤 변수더라도, 내부적으로 보관합니다.
- 따라서 스코프 내에 포함된 어떤 변수라도 참조할 수 있고
- 값을 복사하지 않고 참조하고 있기 때문에 외부변수의 값을 변경 할 수도 있습니다.
- 클로저를 통해 내부 변수를 참조하는 동안에는 해당 변수가 차지하는 메모리를 GC가 회수하지 않으므로 클로저 사용이 끝나면 참조를 제거하는 것이 좋습니다.
- 클로저는 함수내의 지역변수를 감추는 은폐의 역할을 가능하게 합니다.
- 복잡한 코드를 쉽고 간결한 코드를 작성할 수 있습니다. (객체반환x, 함수반환o)
- 자바스크립트에서 클로저가 많이 사용되는 부분은 이벤트 그리고 비동기식 호출의 경우라고 할 수 있습니다.

클로저는 `자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수`라고 정의 할 수 있습니다. 외부함수를 실행하면서 생성되는 지역변수 객체는 스코프체인에 들어가게 되고, 내부함수의 스코프 체인으로 참조됩니다. 외부함수는 종료되었지만 여전히 내부함수 스코프 체인으로 참조되므로 가비지 컬렉션의 대상이 되지 않아 여전히 접근이 가능 한 것입니다.

## 호이스팅

let 로 선언된 변수는 스코프의 시작에서 변수의 선언까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠진다.

변수는 선언 단계 > 초기화 단계 > 할당 단계 에 걸쳐 생성되는데 var 으로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 하지만, let 로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.

```js
console.log(foo); // undefined
var foo;

console.log(bar); // Error: Uncaught ReferenceError: bar is not defined
let bar;
```

## this value

this 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.

- 메소드 호출 패턴
- 함수 호출 패턴
- 생성자 호출 패턴
- call / apply 호출 패턴

## 자바스크립트 함수는 일급 객체(First Class)이다.

1. 러터럴에 의해 생성
2. 변수나 배열의 요소(원소), 객체의 프로퍼티 등에 할당 가능
3. 함수의 인자로 전달 가능
4. 함수의 러턴값으로 리턴 가능
5. 동적으로 프로퍼티를 생성 및 할당 가능

## js async & defer

- defer: 즉시
- async: 스크립트 관련 돔 파싱 후

- async(DOMContentLoaded 후)와 defer(DOMContentLoaded 전) 스크립트는 다운로드 시 페이지 렌더링을 막지 않는다는 공통점
- 브라우저는 defer 속성이 있는 스크립트(이하 defer 스크립트 또는 지연 스크립트)를 '백그라운드’에서 다운로드 합니다. 따라서 지연 스크립트를 다운로드 하는 도중에도 HTML 파싱이 멈추지 않습니다. 그리고 defer 스크립트 실행은 페이지 구성이 끝날 때까지 지연 됩니다.지연 스크립트는 페이지 생성을 절대 막지 않습니다. 지연 스크립트는 DOM이 준비된 후에 실행되긴 하지만 DOMContentLoaded 이벤트 발생 전에 실행됩니다.
- async 속성이 붙은 스크립트(이하 async 스크립트 또는 비동기 스크립트)는 페이지와 완전히 독립적으로 동작합니다. 페이지 구성이 끝난 후에 async 스크립트 다운로딩이 끝난 경우, DOMContentLoaded는 async 스크립트 실행 전에 발생할 수 있습니다,
- 동적 스크립트는 기본적으로 ‘async’ 스크립트처럼 행동합니다.

# 프로그래밍

## 버전닝(Semantic Versioning)

- ~p 틸드 패치
- ^m 캐럿 마이너

## 프로젝트 설계

- 덕패턴: 함께 작업이 이루어지는 파일들을 하나로 합쳐 사용
- 코로케이션: 함께 수정되는 파일들을 같이 두는 것

## 프로그래밍 패러다임

| 명령형imperative | 선언형declarative |
| 어떻게(How) | 무엇을(What) |
| 우리가 그것을 이루는 방법 | 우리가 이루고자 하는 것 |
| 목표보다는 알고리즘 명시 | 알고리즘보다는 목표 |
| 절차지향, 객체지향 | 함수형 |

### 명령형

1. 횡단보도까지 약 99m 이동(성남대로331번길),
2. 횡단보도를 이용하여 경기성남분당경찰서 방면으로 횡단,
3. 횡단보도까지 1개의 횡단보도를 지나 약 612m 이동,
4. 횡단보도를 이용하여 메르세데스벤츠코리아더클래스효성분당전시장 방면으로 횡단,
5. 네이버까지 약 50m 이동(불정로).

### 선언형

1. 출발: 경기도 성남시 분당구 성남대로 333,
2. 도착: 네이버 주소는 경기도 성남시 분당구 불정로 6.

## 객체지향 프로그래밍 4가지 특징

- 추상화
- 캡슐화
- 상속
- 다형성

### 객체 지향 설계 5대 원칙

- SRP (Single Responsibility Principle) 단일 책임 원칙
- OCP (Open Closed Principle) 개방 폐쇄 원칙
- LSP (Liskov Substitution Principle) 리스코프 치환 원칙
- ISP (Interface Segregation Principle) 인터페이스 분리 원칙
- DIP (Dependency Inversion Principle) 의존 역전 원칙

## Apache와 Nginx 비교

| Apache | Nginx |
| 프로세스 중심의 접근법| 이벤트 중심의 접근 방식 |
| 각 요청에 대해 새로운 Thread 필요| 하나의 스레드에서 여러개의 요청을 처리 |
| 요청당 쓰레드 또는 프로세스가 처리하는 구조| 비동기 이벤트 기반으로 요청 |
| 모듈이 다양함| 모듈이 다양하지 않음 |
| PHP모듈 등 직접 적재 가능| 많은 접속자들 대응 가능 |
| 안정성, 확장성, 호환성 유세| 성능 우세 |
| 전통적인 파일기반 방식의 정적 컨텐츠 | 이벤트 처리/비동기식/논블로킹 방식 처리로 인해 정적 컨텐츠 제공시 고속 처리가 가능 |
| 동적 컨텐츠는 서버 내에서 처리 | 동적 컨텐츠를 처리 하지 않는다 |
| 리눅스, BSD, UNIX , Window | 리눅스, BSD, UNIX, Window 부분지원 |

## TDD와 BDD

- TDD는 테스트 자체에 집중하여 검증
- BDD는 비즈니스 요구사항에 집중하여 테스트 케이스를 검증

# CSS

## media query

```css
@media only screen and (min-width: 321px) {
}
```

## position

offset에 대한 기준을 변경한다.

- staic: 위치를 지정하지 않는다. offset은 무시된다.
- relative: 원래 위치로부터 offset으로 위치를 계산한다.
- absolute: 원래 위치 static이 아닌 가장 가까운 조상의 위치를 기준으로 하여offset으로 위치를 계산한다.
- fixed: 원래 위치와 상관없이 위치를 지정한다. 상위요소에 영향을 받지 않는다. 고정된 위치를 설정하며 브라우저의 상대위치가 기준이 된다.

- Absolute Position(브라우저 또는 상위요소를 기준으로 배치하는 방법)
- Relative Position(자기자신을 기준으로 배치하는 방법)
- Fixed Position(스크린을 기준으로 배치하는 방법)

## dispaly & visibility

### display(리플로우)

- block: 아래 위로 블럭처럼 쌓는다.
- inline: 옆으로만 쌓는다.
- none: 나타내지 않는다. 요소박스를 생성하지 않는다.

### visibility(리페인트 대상)

- visible: 보인다. 볼 수 있다.
- hidden: 보이지 않는다. 볼 수 없다. 요소박스는 생성되었다.
- collapse: table의 행과 열을 숨긴다.

Reflow Repaint가 일어나지 않는 transform, opacitiy와 같은 속성도 있습니다. 따라서 left, right, width, height 보다 transform을, visibility/display 보다 opacitiy를 사용하는 것이 성능 개선에 도움이 됩니다.

## 성능 저하 최소화하기

1. 클래스 변경을 통해 스타일을 변경할 경우, 최대한 말단의 노드의 클래스를 변경한다. 최대한 말단에 있는 노드를 변경함으로써, 리플로우의 영향을 최소화한다.

2. 인라인 스타일을 사용하지 않는다. 스타일 속성을 통해 스타일을 설정하면, 리플로우가 발생한다. 엘리먼트의 클래스가 변경될 때 엘리먼트는 하나의 리플로우만 발생시킨다. 인라인 스타일은 HTML 이 다운로드될 때, 레이아웃에 영향을 미치면서 추가 리플로우를 발생시킨다. 코드 가독성이점 추가.

3. 애니메이션이 들어간 엘리먼트는 가급적 position: fixed 또는 position: absolute로 지정하기(영향을 주는 노드 줄이기). Javascript + Css를 조합하여 애니메이션이 많거나 레이아웃 변화가 많은 요소의 경우 position을 absolute 또는 fixed를 사용하여 영향을 받는 주변 노드들을 줄일 수 있다. fixed와 같이 영향을 받는 노드가 전혀 없는 경우 reflow과정이 전혀 필요가 없어지기 때문에 Repaint 연산비용만 들게 된다. absolute 또는 fixed 위치인 엘리먼트는 다른 엘리먼트의 레이아웃에 영향을 미치지 않는다. (리플로우가 아닌 리페인트가 발생하는데, 이것은 훨씬 적은 비용이 든다.) 다른 요소에는 영향을 끼치지 않으므로 페이지 전체가 아닌 해당 요소만 reflow가 발생한다.

4. 부드러운 애니메이션이 성능을 저하시킨다. 한 번에 1px 씩 엘리먼트를 이동하면 부드러워 보이지만, 성능이 떨어지는 디바이스는 말썽일 수 있다. 엘리먼트를 한 프레임당 4px 씩 이동하면 덜 부드럽게 보이겠지만, 리플로우 처리의 1/4만 필요하다.

5. 레이아웃을 위한 <table> 은 피한다. <table> 은 점진적으로 렌더링되지 않고, 모두 불려지고 계산된 다음에서야 렌더링이 된다. 또한, 작은 변경만으로도 테이블의 다른 모든 노드에 대한 리플로우가 발생한다. 레이아웃 용도가 아닌 데이터 표시 용도의 <table> 을 사용하더라고, table-layout: fixed 속성을 주는 것이 좋다. table-layout: fixed 를 사용하면, 열 너비가 머리글 행 내용을 기반으로 고정되어 계산되기 때문이다.

6. CSS 에서 JavaScript 표현식을 사용하지 않는다. IE 와 FF 는 모두 CSS 에서 Javascript 를 실행할 수 있다. IE 에서는 표현 기법과 HTC 동작 방법이 있고, FF 에서는 XBL 을 사용하는 방법이 있다. (이 방법은 CSS 에서 Javascript 를 직접 실행하지는 않지만, 그 효과는 동일하다.) 문서가 리플로우될 때마다 JavaScript 표현식이 다시 계산된다.

7. CSS 하위 셀렉터를 최소화한다. 사용하는 규칙이 적을수록 리플로우가 빠르다.

8. gulp-uncss, grunt-uncss 와 같은 도구로 스타일 정의 및 파일 크기를 줄인다.

9. 숨겨진 엘리먼트를 변경한다. display: none; 으로 숨겨진 엘리먼트는 변경될 때, 리페인트나 리플로우를 일으키지 않는다. 그렇기 때문에 엘리먼트를 표시하기 전에 엘리먼트를 변경한다. (display: none 속성이 설정된 노드는 화면에 어떠한 공간도 차지하지 않기 때문에 Render Tree를 만드는 과정에서 제외된다.) visibility invisible은 레이아웃 공간을 차지하기 때문에 reflow의 대상이 되지만 display none은 Layout 공간을 차지하지 않아 Render Tree에서 아예 제외된다.

10. 합성만을 발생시키는 요소 사용하기. 스타일 속성 중 position, width, height 등과 같이 기하적 변화를 유발하는 속성을 변경하면 레이아웃이 발생한다. transform을 사용한 엘리먼트는 `레이어로 분리`되기 때문에 영향받는 엘리먼트가 제한되어 레이아웃과 페인트를 줄일 수 있다. 그리고 `합성만 발생`시키기 때문에 애니메이션에서 사용 시 렌더링 속도가 향상할 수 있다. 때에 따라 하드웨어가 지원될 경우 GPU를 사용할 수 있으므로 성능이 빠르다. 예를 들어 left, top을 사용하면 모든 프레임마다 엘리먼트와 배경이 합성되어 많은 시간이 걸리므로, transform: translate()를 사용해야 한다.

11. Java Script 를 통해 리스트를 추가하는 경우, DOM Fragment 를 통해 추가한다.

12. 캐쉬를 활용한 Reflow 최소화. (변수에 담아놓고 사용)

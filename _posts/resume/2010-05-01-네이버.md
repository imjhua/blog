---
layout: post
title: 네이버
categories: Resume
---

https://creator-advisor.naver.com/
크리에이터 어드바이저

## TODO
### 인터뷰 프론트 엔드 기술

- 실행컨텍스트
  https://poiemaweb.com/js-execution-context
- 차트
  https://hanjungv.github.io/2017-06-23-1_JS_billboard.1/
- 모빅스?

### 인터뷰 백앤드 엔드 기술

- restapi
- 노드란
- 노드 타입스크립트
- 백앤드 캐시처리

### 코딩테스트 개선

- 리버스 100만자리 성능
- 데이터 인피니티처리



## 인터뷰 질문

### 브라우저 렌더링
//

### 웹서버 통신

IP.
리소스들에게 접근하기 위해서는 해당하는 리소스가 어디있는지 알아야한다. 클라이언트가 인터넷에 연결된 기기를 식별하기 위해 기기들이 가지고 있는 유일한 번호이다.

IPv4 & IPv6.

- IPv4: 8bit씩 네부분의 32bit, 10진수로 표현 (2011년 2월에 IP가 모두 소진)
- IPv6: 16bit씩 8부분의 128bit, 16진수표현

네트워크주소와 호스트주소.
주소의 클래스별 구분과 서브넷마스크를 통해 두개의 주소를 구분한다.

- 네트워크주소: 네트워크와 또 다른 네트워크를 구분
- 호스트주소: 같은 네트워크 속에서 기기를 식별하는데 사용

라우터.
네트워크는 라우터(게이트웨이)라는 장치를 통해서 형성되고 라우터는 목적에 맞는 데이터의 이동경로를 적당히 결정해 준다. 다른 네트워크연결을 라우팅이라고 한다.

홉(hop).
인터넷(또는 목적지)에 도달할 때까지 거치는 게이트웨이 개수이다. 일반적으로 네트워크에서 홉 수가 많으면(즉 게이트웨이 수가 많으면) 네트워크 부하가 발생해 전송 속도가 저하될 수 있다.

DNS.
IP는 위에서 설명한것처럼 12개의 숫자로 이루어져 있다. 하지만 사용자들은 의미도 없는 12개의 숫자를 항상 외우고 다니지 않는다. 따라서 특정 단어(google, facebook)와 실제 IP 주소를 매핑시켜주는 시스템이 필요하고 그것이 DNS이다.

루트네임서버 -> 최상위도메인(국가명) -> 2단계네임서버

- Root네임 서버: 1단계 네임 서버만 관리
- 1단계 네임 서버: com, net, org 등은 2단계 네임 서버만 관리
- 2단계 네임서버: redhat, naver, samsung 등은 www서버, ftp, mail서버등을 관리

DNS가 동작하는 과정은 다음과 같다.

1. 일단 로컬에 있는 DNS서버에 캐싱해둔걸 먼저 살핀다.
2. 없다면 최상위 도메인에서부터 차례로 트리를 탐색한다.
3. 일치하는 도메인을 찾았다면 IP주소를 반환한다. (Recursive Query)

로컬네임서버.
/etc/resolv.conf에 저장된 네임 서버를 로컬 네임 서버라고 한다. 자신의 캐시 DB를 가진다.

로컬 네임서버가 작동하는 순서.

1. PI의 웹 브라우저 주소창에 www.nate.com을 입력한다.
2. PC가 리눅스일 경우 /etc/resolv.conf 파일을 열어서 'nameserver 네임서버IP'부분을 찾아 로컬 네임 서버 컴퓨터를 알아낸다.
3. 로컬 네임 서버에 www.nate.com의 IP주소를 물어본다.
4. 로컬 네임 서버는 자신의 캐시 DB를 검색해 www.nate.com의 정보가 들어있는지 확인한다.
5. 로컬 네임서버가 'ROOT'서버에게 www.nate.com의 주소를 물어본다.
6. ROOT네임서버도 www.nate.com의 주소를 모르므로, 'com 네임 서버'의 주소를 알려주면서 'com 네임 서버'에게 물어보라고 한다.
7. 로컬 네임서버가 'com 네임 서버'에 www.nate.com의 주소를 물어본다.
8. 'com 네임 서버'도 www.nate.com 의 주소를 모르므로, 'nate.com'을 관리하는 네임서버의 주소를 알려주면서 'nate.com'네임 서버에게 물어보라 한다.
9. 로컬 네임서버가 'nate.com' 네임서버에 'www.nate.com'의 주소를 물어본다.
10. 'nate.com'네임서버는 네이트에서 구축한 네임 서버이므로 ㅇㅇㅇ.nate.com이라는 이름을 가진 컴퓨터의 목록은 모두 있다. www.nate.com의 IP 주소도 알기 때문에 IP주소를 알려준다.
11. 로컬 네임 서버는 www.nate.com의 IP주소를 요구한 PI에 IP주소를 알려 준다.
12. PC는 획득한 IP 주소로 접속을 시도한다.


### 사용자들이 브라우저에 주소를 입력하면 어떻게 화면에 웹사이트가 표시되는 것일까?

1. 브라우저에 도메인 네임 입력
2. DNS서버에 IP주소를 요청
3. 해당 IP주소 응답
4. 해당 IP주소 웹서버에 데이터 요청
5. 요청한 페이지 데이터 응답
6. 요청받은 데이터 브라우저 렌더링

브라우저에 도메인이 입력.
브라우저는 도메인이 캐시에 들어있는지 확인한다. 만약 Browser Cache에서 못 찾으면, OS에 저장된 DNS Cache를 찾는다. 만약 OS Cache에서도 못 찾으면, Router DNS Server(현재 접속한 NameServer 주소)에 직접 조회한다.

DNS서버에 IP 주소를 요청.
Router DNS Server에 조회해서 없다면, Root DNS부터 조회를 하여 결과를 가져온다.

수신한 IP주소에 해당하는 웹서버에 접속.
Http Request를 위해, TCP Socket을 개방하고, 연결한다. 이 과정에서 3-Hand-Shaking이 일어난다. TCP 연결에 성공하면, Http Request가 TCP Socket을 통해 보내진다. 이에 대한 응답으로, 웹 페이지의 정보가 사용자의 PC로 들어온다.

3Way Handshake: TCP Socket 연결을 하여, 데이터를 전송하기 위해서 발생한다
1. 클라이언트는 서버에게 통신을 시작한다는 것을 알린다. syn
2. 서버는 클라이언트에게 응답함과 동시에 클라이언트에게 통신을 시작함을 알린다. syn + ack
3. 클라이언트는 서버에게 응답한다. ack (연결 성립 establish)

4 Way Handshake: 연결 종료
1. 클라이언트는 서버에게 통신을 종료한다는 것을 알린다. fin
2. 서버는 클라이언트에게 응답하고 남은 처리가 끝날때까지 기다린다. ack
3. 서버는 클라이언트에게 통신을 종료한다는 것을 알린다. fin
4. 클라이언트는 서버에게 응답한다. ack


### 웹 캐시
캐싱 기본 개념.
캐싱(Caching)은 애플리케이션의 처리 속도를 높여준다. 이미 가져온 데이터나 계산된 결과값의 복사본을 저장함으로써 처리 속도를 향상시키며, 이를 통해 향후 요청을 더 빠르게 처리할 수 있다. 대부분의 프로그램이 동일한 데이터나 명령어에 반복해서 엑세스하기 때문에 캐싱은 효율적인 아키텍처 패턴이다.

웹 캐시(WEB Cache).
사용자(client)가 웹 사이트(server)에 접속할 때, 정적 컨텐츠(이미지, JS, CSS 등)를 특정 위치(client, network 등)에 저장하여, 웹 사이트 서버에 해당 컨텐츠를 매번 요청하여 받는것이 아니라, 특정 위치에서 불러옴으로써 사이트 응답시간을 줄이고, 서버 트래픽 감소 효과를 볼 수 있다.

브라우저캐시
ETag HTTP 응답 헤더는 특정 버전의 리소스를 식별하는 식별자입니다. 웹 서버가 내용을 확인하고 변하지 않았으면, 웹 서버로 full 요청을 보내지 않기 때문에, 캐쉬가 더 효율적이게 되고, 대역폭도 아낄 수 있습니다.

### HTTP 헤더를 통한 브라우저 캐싱
- 모든 브라우저는 HTML 페이지, 자바스크립트 파일 및 이미지와 같은 웹 문서의 임시 저장을 위해 HTTP 캐시 (웹 캐시)의 구현을 제공하고있다.
- HTTP 헤더 지시문을 제공하여 브라우저가 응답을 캐싱할 수 있는 시기와 지속 기간을 지시할 때 사용된다.
- 리소스가 로컬 캐시로부터 빠르게 로드되기 때문에 점점 하드웨어 성능이 급격하고 있는 최근, 잘 활용한다면 엄청 강력한 속도를 제공 한다.
- 요청이 네트워크를 통해 전송되지 않기 때문에 왕복 시간(RTT, Round Trip Time)이 발생하지 않는다.
- 애플리케이션 서버 및 파이프라인의 다른 구성 요소에 대한 부하가 줄어든다.



## 서버사이드렌더링
- Rendering : 어떠한 웹 페이지 접속시, 그 페이지를 화면에 그려주는 것(요청받은 내용을 브라우저 화면에 표시하는것)
- 로더가(Loader)가 서버로부터 정보들을 불러옴
- 파싱(Phasing)을 통해 문서를 DOM 트리 만듦
- DOM트리가 구축되는 동안 브라우저는 렌더 트리를 구축	
- css 설정/레이아웃 위치 지정
- 렌더링 트리가 그려짐
- 전통적인 웹 어플리케이션은 서버사이드렌더링 방식을 사용(전통 웹 방식 != SSR)

(즉, 브라우저에 나타나는 형태 그대로를 HTML로 만들어 제공하고, 브라우저는 HTML을 표시하는 방식이었다. 이런 방식을 사용하다가 일부 HTML과 Script만 브라우저로 전달하고, 브라우저에서 Script를 실행시켜 서버에서 데이터를 조회하여 HTML을 생성하는 방식을 사용하게 되었다.)

- 요청시마다 서버에서 처리 한 후 새로고침으로 페이지에 대한 응답(View)(새로고침이 일어나며 서버에 새로운 페이지에 대한 요청을 하는 방식)(서버 측에서 HTML&View를 생성하여 응답하는 방식) ex) 마치 필요한 물건이 있을 때 마다 마트(서버)에 사러가는 것과 비슷
- 웹에서 많은 정보와 기능이 많아지면서 싱글페이지어플리케이션(SPA)개념이 생김

서버사이드렌더링(Server-Side-Rendering)의 장점
- SSR의 경우 view를 서버에서 렌더링하여 가져오므로 첫 로딩이 매우 짧음(view를 보기까지)
- 물론 js파일을 모두 다운로드하고 적용하기 전까지는 그 어떤 인터렉션에도 반응하지는 않지만, 사용자 입장에서는 로딩이 매우 빠르다고 느껴짐.
- SEO(Search Engine Optimization) 검색엔진 최적화에 유리함(js 라이브러리/프레임워크를 사용하면서 고질적인 문제는 seo이다. 그냥 미리 그려지지 않고 빈 껍데기만 제공된다면 검색엔진이 당연하게도 내용을 검색하는데 어려움이 있음 but, SSR은 서버에서부터 페이지를 제공할 때 컨텐츠가 담겨있기 때문에 SEO에 대한 걱정을 덜 수 있음)
	

서버사이드렌더링(Server-Side-Rendering)의 단점
- 장점을 제공하는 만큼 사용하는데에 있어서 어려움과 번거로움 
(서버사이드 렌더링을 구현하게 된다면, 프로젝트의 구조가 많이 복잡해지게 됩니다. 
- 단순히 렌더링만 하는것은 그렇게 큰 문제는 아니지만, 리액트 라우터, 리덕스 등의 라이브러리와 함께 연동해서 사용하면서, 서버에서 데이터를 가져와서 렌더링을 해줘야하는 경우엔 조금 어려워질수도 있습니다.)
- view 변경 시 서버에 계속 요청을 해야하므로 서버에 부담이 큼, 정보가 많은 B2C 웹 서비스 등에는 서버 부담이 큼(요청 시 마다 새로고침이 일어나며 페이지를 로딩할 때마다 서버로부터 리소스를 전달받아 해석하고 화면에 렌더링 하는 방식이기 때문이다. 예를들어 현재 주소에서 동일한 주소를 가리키는(갖고있는) 버튼을 눌렀을때, 설정페이지에서 필요한 데이터를 다시 가져올 수 없다.

이것은 사용자와 인터랙션이 많은 요즘 웹앱에게 충분하지 않는 방법일 수 있다. 렌더링을 서버쪽에서 하는 것은 그 만큼 렌더링을 위한 서버 자원이 사용되는 것이고, 불필요한 트래픽도 낭비되는 것이다.

- 서버사이드 렌더링을 구현하게 된다면, 프로젝트의 구조가 많이 복잡해지게 됩니다. 단순히 렌더링만 하는것은 그렇게 큰 문제는 아니지만, 리액트 라우터, 리덕스 등의 라이브러리와 함께 연동해서 사용하면서, 서버에서 데이터를 가져와서 렌더링을 해줘야하는 경우엔 조금 어려워질수도 있습니다.

(대안)동일한 페이지는 특정기간 동안 캐싱하여 성능을 최적화 할 수 있음

(대안)비동기식 렌더링

(써드파티 라이브러리를 통하여 비동기식으로 작동하게끔 코드를 작성 할 수 있습니다.
- .rapscallion: renderToString 을 비동기로 해주며, Promise 기반으로 작동하고, 컴포넌트 단위로 캐싱을 할 수 있습니다
- hypernova: airbnb 에서 만든 도구로서, 렌더링을 위한 서버를 따로 열어서 cluster 를 사용하여 여러 프로세스를 생성하여 렌더링을하고, 운영서버에서 렌더링서버로 결과물을 요청을 하는 방식으로 작동합니다.
- react-router-server: react-router v4 를 위해 만들어진 서버사이드 렌더링 라이브러리로서, Promise 비동기식 렌더링을 지원해주고, 깔끔한 방식으로 데이터를 불러올 수도 있습니다.)

(대안)메타태그(서버쪽에서 라우트에 따라 필요한 메타태그만 넣어주는 것. 그러면, 크롤러에선 해당 페이지에 대한 기본 정보는 얻어 갈 수 있게 된다.)



### xxx
- SEO 검색엔진 최적화: 서버사이드렌더링

- 웹브라우저 작동원리

- 브라우저 최적화
  https://estrella-kim.github.io/frontend_performance_optimization
- 웹서버 통신
  https://owlgwang.tistory.com/1
- 브라우저 캐시 304
- 네트워크
- dns
- 스프라이트 기법 이미지배율
- 브라우저 레이아웃 페인팅 리플로우 리드로우
- 이벤트 루프
- 유저에이전트
  https://developer.mozilla.org/ko/docs/Web/HTTP/User_agent%EB%A5%BC_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80_%EA%B0%90%EC%A7%80
  https://zinee-world.tistory.com/512
  https://blog.outsider.ne.kr/449
- 모빅스
- 최신브라우저
  https://d2.naver.com/helloworld/5237120

## 자바스크립트엔진(콜스택/힙/테스크큐) & 브라우저 API(이벤트루프)
- 싱글스레드기반 호출스택, 순차적으로 하나씩만 처리
- 스택은 선형구조(LIFO - Last In First Out)
- 호출 스택의 각 단계를 스택 프레임(Stack Frame)이라고 합니다. 그리고 보통 예외가 발생했을 때 콘솔 로그 상에서 나타나는 스택 트레이스(Stack Trace)가 오류가 발생하기까지의 스택 트레이스들로 구성됩니다. 
- 동적으로 생성된 객체(인스턴스)는 힙(heap)에 할당. 
- 자바스크립트에서 비동기로 호출되는 함수(자바스크립트 엔진이 아닌 브라우저 APIs(Web API) 영역에 따로 정의되어 있는 함수들)들은 Call Stack에 쌓이지 않고 Task Queue에 들어 갑니다. 
- 비동기 콜백은 즉시 호출 스택에 쌓이지 않고 Event Queue에서 기다렸다가 호출 스택이 비어있는 시점에 실행
- 브라우저는 호출 스택이 비워질 때마다 작업 큐에서 가장 오래된 작업을 꺼내와서 해당 작업에 대한 콜백을 실행시킵니다. 브라우저는 이 과정을 끊임없이 반복하는데, 이를 이벤트 루프(event loop)라고 부릅니다.
- 이벤트 루프의 기본 역할은 큐와 스택 두 부분을 지켜보고 있다가 스택이 비는 시점에 콜백을 실행시켜 주는 것입니다.

## 블로킹/논블로킹 & 동기/비동기

호출 및 처리 방식에서의 구분.
- Blocking/NonBlocking은 호출한 입장에서의 호출되는 함수가 바로 리턴하는지 하지않는지/하는지
- Sync/Async는 처리되는 방식은 함수완료여부를 신경쓰는지/쓰지않는지

관심사의 구분.
비슷한 동작인것만 같은 Blocking/NonBlocking 과 Synchronous/Asynchronou를 각자의 관심사로 구분할 수 있습니다.

- Blocking: 호출되는 함수가 바로 리턴하지 않는다.
- NonBlocking: 호출되는 함수는 바로 리턴한다.
- Synchronous: 호출하는 함수는 작업 완료 여부를 신경쓴다.
- Asynchronous: 호출하는 함수는 작업 완료 여부를 신경쓰지 않는다.

## nodejs
Nodejs는 브라우저 아닌 환경에서도 자바스크립트를 사용할 수 있게 하는 자바스크립트 런타임입니다. 서버사이드에서도 사용합니다. 노드를 통해 데스크탑 윈도우 프로그램도 만들 수 있습니다. 아톰에디터도 노드로 만들어져 있습니다.

노드는 웹서버가 아닙니다. 이 자체로는 아무것도 하지 않습니다. 따라서 HTTP서버를 직접 작성해야 합니다. `그냥 단지 코드를 실행할 수 있는 런타임`일 뿐입니다.


------------



Analytics 프론트엔드 개발 경력사원 모집 (빅데이터 활용 개발)
https://recruit.navercorp.com/naver/job/detail/developer?annoId=20003584&classId=&jobId=&entTypeCd=&searchTxt=%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C

[조직소개]

- 국내 최대 빅데이터를 처리하는 경험을 통해 빅데이터 전문가로 자연스럽게 성장할 수 있습니다.
- 최신 빅데이터 분석 기술들을 사용해 보고 평가하여 실서비스에 적극적으로 적용해 볼 수 있습니다.
- 서비스 적용에 그치지 않고, 내부에 가치있는 경험들을 잘 정리하여 외부 커뮤니티에 전파할 수 있습니다.

[역할]

- 신규 오픈하는 분석 서비스 프론트엔드 개발

[필요역량]

- 프론트엔드 분야 경력 3년 이상
- javascript에 대한 전문적 지식과 경험을 가지고 계신 분
- HTML, CSS를 이해하고 사용가능하신 분

[우대사항]

- ES6(ES2015) 이상의 스펙 사용 가능하신 분
- React, Redux, MobX 사용 가능하신 분
- Webpack/Babel을 이용한 빌드 환경 구축이 가능하신 분
- chart 라이브러리 사용 가능하신 분

[채용하고 싶은 사람]

- 새로운 기술을 접하는데 어려움이나 거부감이 없으신 분
- 동료를 배려하고 같이 성장하고자 하시는 분
- 다양한 직군의 다양한 사람과의 커뮤니케이션이 원활하신 분
- 책임감이 있게 업무를 진행하실 있는 분

## 지원동기
네이버는 명실공히 국내 최대 빅데이터 기업입니다. 뉴스, 블로그, 카페, 지식인 등 주요 서비스에 쌓인 데이터만 해도 엄청난 규모인데다 매일매일 데이터가 폭증 수준으로 불어나고 있습니다. 데이터로부터 가치를 추출하고 결과를 분석하여 생활의 질을 향상시키는데 기여하고 싶습니다. 데이터 대시보드의 UI와 UX를 고민하며 기획한 경험이 있습니다. 이곳에서 사용자를 이해하며 제품을 개발하는데 좋은 밑거름이 될 것입니다. 스스로의 역량을 펼치며 기업과 함께 성장 하겠습니다. 

## 입사 후 기여방안
지금까지 중견기업, 스타트업, 프리랜서, 글로벌프로젝트 등의 다양한 환경에서 개발을 하였습니다. 다양한 환경에서 다양한 개발을 하며 깨달은 것은, 개인의 역량도 중요하지만 함께 일하는 사람들과의 신뢰를 기반으로한 소통이라는 점 입니다. 팀원들간의 협업, 팀과 팀간의 협업을 통해 한가지 목표를 바라보고 달려가는 것이 가장 중요한 부분이라고 생각합니다. 팀원과 신뢰를 바탕으로 스스로의 역량을 펼쳐 고객의 가치 있는 삶을 위한 서비스를 제공하겠습니다. 

왜 프론트엔드 개발자는 끊임없이 공부해야 하는가? 
배웠던 기술들을 사용하면서 편하게 개발할 수 없는가? 
포기하고 적당히 하는 순간 빠르게 변하는 웹 세계에서 뒤쳐지는 것이다.
- 능동적인 멋진 삶: 주어진 일만 하는 것이 아닌 제품에 대한 고민을 하며 함께 성장하기를 원한다.
- 일에 대한 성취감: 본인의 직업을 통해 유저에게 좋은 경험을 전하는 일을 무엇보다 중요하게 생각한다.
- 함께 하는 삶: 회사, 일하는 동료와 함께 성장하고 싶다.



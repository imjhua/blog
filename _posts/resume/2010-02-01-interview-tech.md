---
layout: post
title: 기술 면접 질문
categories: Resume
---


## 클로저란?

## 웹 최적화

## 세션 스토리지 쿠키 차이

웹사이 정보를 저장하기위한 클라이언트 로컬 저장공간. 각각의 목적과 차이!

### 세션

- 클라이언트 정보를 서버에 저장.
- 브라우저마다 별도 세션 가진다.
- 로그인 정보처럼 페이지를 이동하더라도 계속 유지되어야 하는 정보 저장한다.
- 브라우저 종료할때까지 유지된다.
- 세션아이디를 주고 받기도 한다.
- 단점은, 서버의 메모리를 사용하는 것이기 때문에 서버자원문제 및 정보가 서버에 있기 때문에 처리가 요구되어 속도가 느려질 수 있다.
- 세션아이디만 쿠키에 저장해서 사용하면 비교적 보안에 좋다.

### 쿠키

- 서버와 클라이언트 간의 지속적인 데이터 교환 목적으로 사용한다.
- 브라우저에 파일 형태로 저장한다.
- 서버 요청시마다 함께 전송되며 문자열만 저장 가능하다. (4KB)
- 서버통신에 필요없는 데이터를 전송하게되면 데이터가 낭비된다.
- 파일로 저장되기 때문에 브라우저 종료해도 정보는 남아 있으며 팝업창 일정기간 보이지 않기, 서버통신에 필요한 인증과 관련된 정보나 세션에 저장된 토큰값을 저장하는데 활용된다.

### 웹 스토리지(로컬스토리지 / 세션스토리지)

- 쿠키의 제한점을 보완하기 위하여 등장하였다.
- 용량도 커졌고 서버로는 전달되지 않고 브라우저 로컬에만 저장되어 보안이 보장된다.
- 윈도우객체안에 들어있다.
- 자바스크립트 객체저장이 가능하다.

### 로컬스토리지

- 삭제하기 전까지 브라우저에 계속 저장되어 있다. (10MB)

### 세션스토리지

- 세션 유지기간에만 사용하능한 스토리지로 브라우저를 종료하면 자동 소멸한다. (5MB)

## 클로저

외부함수의 맥락(context)에 접근 가능한 내부함수 좀 더 포괄적으로는 함수 선언시 생성되는 유효 범위

- 현재함수 외부에서 선언된 변수를 참조할 수 있다.
- 함수는 외부함수가 무언가를 리턴한 이후에도 이 외부함수에서 선언된 변수를 참조할 수 있다.
- 자바스크립트 함수 값은 호출되었을 때, 실행되기 위한 코드 뿐만 아니라 더 많은 정보를 포함하고 있기 때문에 리턴된 이후에도 외부함수의 변수 참조가 가능하다.
- 자바스크립트 함수는 해당 스코프에서 선언되어 참조할 수 있는 어떤 변수더라도 내부적으로 보관한다.
- 즉, 함수 자신이 포함하는 스코프의 변수들을 추적하는 함수를 클로저라고 한다.

- 함수는 파라미터와 외부함수의 변수뿐만 아니라 해당 스코프 내에 포함된 어떤 변수라도 참조할 수 있다.
- 클로저는 외부변수의 값을 변경할 수 있다.
- 실제로 외부변수의 값을 복사하지 않고 참조를 저장하기 때문이다.
- 클로저 안에 정의된 함수는 만들어진 환경을 기억한다.
- 클로저는 각자의 환경을 가지는데 이 환경을 기억하기 위해서는 당연히 메모리가 소모될 것이다.
- 클로저를 통해 내부 변수를 참조하는 동안에는 내부 변수가 차지하는 메모리를 GC가 회수하지 않는다.
- 클로저 사용이 끝나면 참조를 제거하는 것이 좋다.

### 장점

- 클로저는 함수내의 지역변수를 감추는 은폐의 역할을 가능하게 하며, 이는 곧 다른 언어의 private 키워드와 비슷한 역할을 합니다. 자바스크립트는 private 변수, 즉 외부에서 접근할 수 없는 변수 형태를 선언을 통해 사용할 수는 없습니다. 하지만 동일한 기능을 클로저를 통해 구현할 수 있습니다.
- 무분별한 전역변수의 사용을 억제하고 발생가능한 변수간의 충돌을 막을 수 있으며 이는 곧 이벤트 및 애니메이션의 효과적인 함수 사용을 가능하게 합니다. 이런 클로저(Closure)를 활용하여 개발한다면 `복잡한 코드를 쉽고 간결`하고 한단계 더 높은 개발코드를 작성할 수 있습니다.
- 자바스크립트에서 클로저를 활요할 수 있는 부분은 대부분으로 가장 많이 사용되는 부분은 이벤트 그리고 비동기식 호출의 경우라고 할 수 있습니다.

### 단점

- 기본적으로 메모리와 퍼포먼스 저하라는 문제가 발생할 수도 있습니다.

### 참고

- 클로저는 new 연산자를 사용해 인스턴스를 만들 경우 발생한다
- 익명함수를 사용할 경우 역시 클로저는 생성된다
- Function 생성자를 사용해 함수를 만들경우 클로저는 생성되지 않는다.

## 호이스팅

자바스크립트 엔진이 실행 컨텍스트를 생성하면서 스코프를 정의할 때 기술된 순서에 상관없이 선언부에 대한 처리를 해석할때 우선순위가 최우선으로 끌어올려서 먼저 해석하게 된다. 코드작성순서에 상관없이 선언구문을 최우선으로 해석한다.

## 리엑트

지금까지는 모든 것을 해결해주는 프레임워크가 대세였지만, 앞으로는 필요한 모듈만 가져다 사용하는 시대가 올 것으로 예상된다

- 재사용 가능한 UI 컴포넌트. 
- 모듈의 단위가 컴포넌트 인다. 컴포넌트 단위로 코드를 재사용 할 수 있다.
- 직관적인 html jsx 마크업개발자와 협업
- 컴포넌트당 클래스를 사용하므로 css캡슐화
- 화면 갱신 상태에 의존 셀렉터 필요 없음
- 재사용성이 없는 컴포넌트를 각각의 파일로 작성하는 이유는? 가독성


Portal 컴포넌트는 논리적으로 하위 컴포넌트지만 시각적으로는 상위 컴포넌트여야 할 때 사용한다.
React에서는 합성, Composition을 통해 컴포넌트를 재사용할 수 있다.
Composition을 지원하는 컴포넌트의 경우 PureComponent를 사용하면 성능이 나쁠 수 있다.
Composition을 지원하는 컴포넌트를 최적화 하고 싶으면 특수화를 적용한다.

* 컴포넌트 제대로 만들기: https://hyunseob.github.io/2019/06/02/react-component-the-right-way/




### 하나의 컴포넌트 파일에서 구조

- 외부 라이브러리 및 모듈 import
- component function 선언
- useSelector나 useState를 통하여 state 초기화 및 store값 가져오기
- useEffect를 통한 component의 lifecycle 구현
- return을 통한 JSX 구현
- 컴포넌트의 propTypes, defaultProps 작성
- 컴포넌트 export

### HOC에 대하여

HOC는 하나의 부품처럼 특정 컴포넌트에 기능 하나를 추가해주는 역할을 한다.

### action에 맞추어 status를 관리하고 response를 저장한다는 의미

component 에서 action의 상태에 따른 후 처리를 대응하기 위함.

1. component에서 어떠한 액션과 관련있는지 알고 싶다.
2. 액션의 상태 및 결과(success, response)에 대해서 후처리를 component에서 하고 싶다.

## REST API에 대한 이해 (자원+행위+표현)

REST(Representational State Transfer) API는 클라이언트와 서버 간에 `데이터를 주고받기 위한 URL 규칙`. 자원을 이름(URI: 자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다. 하이퍼 미디어(링크) 기반으로 특정 리소스나 데이터를 접근하기 위한 방식으로써 URL에 명시적으로 어떤 데이터를 담고 있는지 나타내어야 합니다. REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.

RESTful은 리소스와 행위를 명시적이고 직관적으로 분리합니다.

- 자원(RESOURCE): URI
- 행위(Verb): HTTP METHOD
- 표현(Representations): 상태 또는 정보 전달 JSON, XML, TEXT, RSS 등

### PUT과 PATHC

- PUT: 자원의 전체 교체, 자원내 모든 필드 필요. 만약 전체가 아닌 일부만 전달할 경우, 전달한 필드외 모두 null or 초기값 처리되니 주의
- PATCH: 자원의 부분 교체, 자원내 일부 필드 필요

## CORS

CORS(Cross-Origin Resource Sharing)는 현대 프런트엔드 프레임워크를 사용할 때 반드시 알아두면 좋은 브라우저의 기본 동작 방식입니다. 브라우저 보안상 브라우저에서는 특정 도메인에서 다른 도메인의 데이터를 접근하지 못하게 막는다.

## 동일 출처 정책(same-origin policy)

불러온문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 중요한 보안 방식입니다. 이것은 잠재적 악성 문서를 격리하여, 공격 경로를 줄이는데 도움이 됩니다.

동일 출처 정책(same-origin policy) 때문에 CORS 같은 상황이 발생 하면 외부서버에 요청한 데이터를 브라우저에서 보안목적으로 차단합니다. 그로 인해 정상적으로 데이터를 받을 수 없습니다.

### 서버에서 cross-origin HTTP 요청을 허가 해주는 방법

- Access-Control-Allow-Origin response 헤더를 추가 모든 클라이언트에 요청에 대한 cross-origin HTTP 요청을 허가하는 헤더를 추가한다.
- 미들웨어 CORS 추가: 허락하고자 하는 요청 주소를 추가한다.

cors이란 도메인 또는 포트가 다른 서버의 자원을 요청하면 발생하는 이슈이다.
서버와 클라이언트가 분리되어 있는 앱에서는 cross-origin HTTP 요청을 서버에서 승인해주는 것이 좋다.

## React 장단점

### 장점

- 리엑트의 장점은 단방향 데이터 플로우이다. 스테이트 관리 패턴. 스테이트가 꼬이지 않고 명료하게 나타난다. 단순 뷰레이어가 아닌 새 패턴의 한 부분이다.
- React는 JavaScript 객체 형태의 Virtual DOM 을 사용하여 어플리케이션의 성능을 향상시킴 (JavaScript Virtual DOM 처리가 실제 DOM 보다 빠르기 때문)
- Component 의 가독성이 매우 높고 간단하여 쉬운 유지보수, 간편한 UI 수정 및 재사용 용이
- React는 프레임워크가 아닌 라이브러리기 때문에 다른 프레임워크와 혼용 가능

### 단점

- VIEW ONLY , VIEW 이외의 기능은 써드파티 라이브러리(Third party library, =패키지, 모듈로 불리기도함)를 이용하거나 직접 구현해야함
- IE8 이하 지원하지 않음 (IE8 이하 버전을 지원해야 할 경우 v0.14 버전을 사용 해야함)
  React는 inline-template 과 JSX 를 사용하는데, 일부 개발자들에게는 적응이 안 될 수 있음

스테이트 관리를 잘 해야한다. 상황에 맞게 써야지 무턱대로 사용하면 불피요한 상태를 계속 관리하게 되어 더 복잡하다. 컴포넌트를 컨테이너와 프레젠테이셔널 로 나눌 수 있는데, 이도 관리의 용이함을 위해서다. 코드공유와 코드재사용성을 고민하자.

## React - Redux

Redux는 React에서 컴포넌트간의 State전달 및 관리를 편리하게 해 주는 라이브러리. Redux는 Flux라는 아키텍처를 조금 손봐서 React에서 사용하기 적합하게 만들었다.

React까지 필요하지 않는 기능에도 State를 맡기면 더러워지거나 오버 엔지니어링을 했던 시행착오. 규모나 상황에 따라 Redux는 선택적으로 사용하는 것이 맞다. 어떤 컴포넌트에 어떤 State를 공유할것인지에 대해 고민해야 한다.

어떤 곳에서는 오히려 React의 깔끔한 구조를 깨뜨리기도 한다. 굳이 필요하지 않다면 전체적인 프로젝트의 복잡성을 낮추는데 도움이 된다.

## oAuth 로그인

Oauth는 외부서비스의 인증 및 권한부여를 관리하는 범용적인 프로토콜입니다. OAuth는 인증뿐만 아니라 권한도 관리합니다. 사용자의 권한에 따라 접근할 수 있는 데이터가 다르도록 설정이 가능합니다.

그외 인증 방법

- 세션/쿠키, JWT를 이용한 인증
- Access Token + Refresh Token을 이용한 인증
- SNS 로그인은 간단하게 봤을 때 OAuth2.0 + 서버 인증(세션/쿠키 , 토큰기반 인증)으로 구성

(사용자 <-> 어플리케이션 서버) 인증 절차였던 세션/쿠키, 토큰 기반 인증 방식을 완전히 대체하는게 아니라는 점입니다. 즉 SNS 로그인 기능을 넣더라도 결국은 세션/쿠키 방식이나 토큰을 활용해 인증을 거쳐야 합니다.

### Authorization Code Grant 방식을 예

- Resource Owner: User, 즉 일반 사용자를 칭합니다.
- Client: 우리가 관리하는 어플리케이션 서버(User와 혼동될 수 있는데 아닙니다!)
- Authorization Server: 권한을 관리하는 서버입니다. Access Token, Refresh Token을 발급, 재발급 해주는 역할을 합니다.
- Resource Server: OAuth2.0을 관리하는 서버(Google, Facebook, Naver 등) 의 자원을 관리하는 서버입니다. 주의할 점은 우리가 만드는 서버의 자원을 관리하는 곳이 아닙니다. Oauth 2.0 관리 서버의 자체 API를 의미합니다.

## 미들웨어 thunk의 단점

이전엔 리덕스 redux-thunk를 쓰면서 액션쪽에 비동기통신 코드가 번잡하게 들어감에 따라 파악하기 힘듭니다. 만들면서 맘에 들지 않았던 부분은 action이 dispatch만 하는것이 아니라 로직을 담고 작업을 수행한다는 단점이 있습니다.

정리하면 action이 본인의 역할 이외에 다른 영역까지 넘어간 부분이 뭔가 찝찝하고도 구린듯한 느낌 thunk의 다른 단점도 있겠지만 종합하면 redux의 철학을 보존하면서 사용하지 못한 것 같다.

thunks는 좋은 시작점은 될 수 있겠지만, 확장에 쓰이기는 어렵습니다.

## 미들웨어란

미들웨어는, 액션이 디스패치(dispatch) 되어서 리듀서에서 이를 처리하기전에 사전에 지정된 작업들을 설정합니다. 미들웨어를 액션과 리듀서 사이의 중간자라고 이해할 수 있습니다.

리듀서가 액션을 처리하기전에, 미들웨어가 할 수있는 작업들은 여러가지가 있는데요. 단순히 전달받은 액션을 콘솔에 기록을 할 수도 있고, 전달받은 액션에 기반하여 액션을 아예 취소시켜버리거나, 다른 종류의 액션들을 추가적으로 디스패치 할 수도 있습니다.

thunk 미들웨어는 객체 대신 함수를 생성하는 액션 생성함수를 작성 할 수 있게 해줍니다. 리덕스에서는 기본적으로는 액션 객체를 디스패치합니다. 일반 액션 생성자는, 다음과 같이 파라미터를 가지고 액션 객체를 생성하는 작업만합니다. 만약에 특정 액션이 몇초뒤에 실행되게 하거나, 현재 상태에 따라 아예 액션이 무시되게 하려면, 일반 액션 생성자로는 할 수가 없습니다. 하지만, redux-thunk 는 이를 가능케합니다.

redux-thunk 는 일반 액션 생성자에 날개를 달아줍니다. 보통의 액션생성자는 그냥 하나의 액션객체를 생성 할 뿐이지만 redux-thunk 를 통해 만든 액션생성자는 그 내부에서 여러가지 작업을 할 수 있습니다. 이 곳에서 네트워크 요청을 해도 무방하죠. 또한, 이 안에서 액션을 여러번 디스패치 할 수도 있습니다.

### 디자인 패턴 나열

#### 생성

객체 생성과 관련된 패턴으로 객체 생성과 조합을 캡슐화 해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.

종류) 추상 / 빌더 / 팩토리 메서드 / 프로토타입 / 싱글톤

#### 구조

클래스나 객체를 조합해 더 큰 구조를 만드는 패턴으로 예를 들어 서로다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴입니다.

종류) 어탭터 / 브릿지 / 컴포지트 / 데코레이터 / 퍼사드 / 플라이웨이트 / 프록시

#### 행위

클래스와 객체들이 상호작용하는 방법 및 역할을 분담하는 방법과 관련된 패턴으로 객체나 클래스 사이의 알고리즘이나 책임분배를 담당합니다. 한 객체가 혼자 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체사이의 결합도를 최소화하는 것에 중점을 두고 있습니다.

종류) 책임연쇄 / 커맨드 / 인터프리터 / 이터레이터 / 미디에이터 / 머멘토 / 옵저버 / 스테이트 / 스트래티지 / 템플릿 / 비지터

## js 기술면접

https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Korean/questions/javascript-questions.md

## 함수형 프로그래밍

https://velog.io/@kyusung/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9A%94%EC%95%BD

## React

Virtual DOM으로 변경된 부분만 다시 랜더링
데이터가 업데이트되면, 전체 UI 를 Virtual DOM 에 리렌더링 한다.
이전 Virtual DOM 에 있던 내용과 현재의 내용을 비교한다.
바뀐 부분만 실제 DOM 에 적용이 된다.

리엑트 면접 준비
https://velog.io/@kyusung/react-summary

!! 내가 무엇을 얻었는지
!! 무엇을 배웠는지

- React를 이용해 재사용성을 갖춘 디자인 시스템 구축하기
  !! 간결하고 명료하게 더 높은 생산성 가돌것ㅇ
  !! 언제 쓰이는지
  !! 의도 잃지 않기
  !! 내 시간과 에너지는 소중하기 때문에 효율적으로
  !! 프론트테스트 어려워 그래서 스텝별 테스트 페이지 작성

## 기술면접

### React 란?

### React 의 장점

### React 의 미래

- 전부터 React를 계속 다루었고, 프론트엔드 영역에 그동안 다양한 언어들( Jquery, Backbone, AngularJS)이 존재 하였지만 앞으로의 10년, 가능성

## 자바스크립트 객체지향 프로그래밍

OOP 객체지향 프로그래밍의 4가지 특징

- 추상화
- 캡슐화
- 상속
- 다형성

객체는 속성(필드)과 메소드(동작)로 구성된다.

자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다.

자바스크립트를 객체지향적인 언어라고 말할 수 있는 가장 중요한 이유 중 하나는 프로토타입 상속(prototypal inheritance) 이라는 확장과 재사용을 가능하게 해주기 때문입니다.

## 자바스크립트에서는 함수를 일급 객체(First Class)라고 부른다.

1. 러터럴에 의해 생성
2. 변수나 배열의 요소(원소), 객체의 프로퍼티 등에 할당 가능
3. 함수의 인자로 전달 가능
4. 함수의 러턴값으로 리턴 가능
5. 동적으로 프로퍼티를 생성 및 할당 가능

## SPA

장점들:

- 전체 페이지 새로고침으로 인해 페이지 탐색 사이에 하얀 화면이 보이지 않아 앱이 더 반응적으로 느껴지게 됩니다.
- 동일한 애셋을 페이지 로드마다 다시 다운로드할 필요가 없으므로 서버에 대한 HTTP 요청이 줄어듭니다.
- 클라이언트와 서버 사이의 고려해야 할 부분을 명확하게 구분합니다. 서버 코드를 수정하지 않고도 다양한 플랫폼(예: 모바일, 채팅 봇, 스마트워치)에 맞는 새로운 클라이언트를 쉽게 구축할 수 있습니다. - 또한 API 규약이 깨지지 않는 한도 내에서 클라이언트와 서버에서 기술 스택을 독립적으로 수정할 수 있습니다.

단점들:

- 여러 페이지에 필요한 프레임워크, 앱 코드, 애셋로드로 인해 초기 페이지로드가 무거워집니다.
- 모든 요청을 단일 진입점으로 라우트하고 클라이언트 측 라우팅이 그 한곳에서 인계받을 수 있도록 서버를 구성하는 추가 단계가 필요합니다.
- SPA는 콘텐츠를 렌더링하기 위해 JavaScript에 의존하지만 모든 검색 엔진이 크롤링 중에 JavaScript를 실행하지는 않으며 페이지에 빈 콘텐츠가 표시될 수 있습니다. 이로 인해 의도치 않게 앱의 검색 엔진 최적화(SEO)가 어려워집니다. 그러나 대부분의 경우 앱을 제작할 때 검색 엔진에서 모든 콘텐츠 색인할 필요는 없으므로 SEO가 가장 중요한 요소는 아닙니다. 이를 극복하기 위해, 앱을 서버 측 렌더링하거나 Prerender와 같은 서비스를 사용하여 "브라우저에서 JavaScript를 렌더링하고, 정적 HTML을 저장한 다음, 크롤러에게 반환합니다".

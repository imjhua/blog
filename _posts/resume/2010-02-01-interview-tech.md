---
layout: post
title: 기술 면접 질문
categories: Resume
---

## TODO

### 인터뷰 프론트 엔드 기술

- 실행컨텍스트
  https://poiemaweb.com/js-execution-context

## 웹워커

Background Thread에서 스크립트를 실행하는 방법이다. UI Thread와는 별개의 Thread를 실행시켜 사용자 인터페이스(UI)를 방해하지 않고 작업을 수행할 수 있다.

## 실행컨텍스트(EC: Execution Context)

실행 컨텍스트는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 갖는다. 전역EC와 함수별 EC를 가질수 있다. 3가지 프로퍼티를 가진다.

1. Variable Object (VO / 변수객체)
2. Scope Chain (SC)
3. this value

### 변수객체(VO: Variable Object)

VO는 아래의 정보를 담는 객체이다.

- 변수
- 매개변수(parameter)와 인수 정보(arguments)
- 함수 선언(함수 표현식은 제외)

Variable Object는 실행 컨텍스트의 프로퍼티이기 때문에 값을 가지고 이 값은 다른 객체(전역GO/함수AO)를 가킨다. 전역컨텍스트, 함수컨텍스트의 경우, 가리키는 객체가 다르다. 이유는 각각의 내용이 다르기 때문이다. 예로 전역 코드에는 매개변수가 없지만 함수에는 매개변수가 있다.

- 전역객체 GO: 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(Global Object / GO)를 가리킨다. 전역 객체는 전역에 선언된 전역 변수와 전역 함수를 프로퍼티로 소유한다.
- 활성객체 AO: 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체인 arguments object가 추가

### 스코프 체인(SC: Scope Chain)

스코프 체인(Scope Chain)은 일종의 리스트로서 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 저장하고 있다. 다시 말해, 스코프 체인은 해당 전역 또는 함수가 참조할 수 있는 변수, 함수 선언 등의 정보를 담고 있는 전역 객체(GO) 또는 활성 객체(AO)의 리스트를 가리킨다.

- 스코프 체인은 식별자 중에서 객체(전역 객체 제외)의 프로퍼티가 아닌 식별자, 즉 변수를 검색하는 메커니즘이다. 식별자 중에서 변수가 아닌 객체의 프로퍼티(물론 메소드도 포함된다)를 검색하는 메커니즘은 프로토타입 체인(Prototype Chain)이다.

### this value

this 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.

- 메소드 호출 패턴
- 함수 호출 패턴
- 생성자 호출 패턴
- apply 호출 패턴

## TODO

- 차트
  https://hanjungv.github.io/2017-06-23-1_JS_billboard.1/
- 모빅스?

## js 기술면접

https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Korean/questions/javascript-questions.md

## 웹서버 통신

https://owlgwang.tistory.com/1

## 브라우저 성능 최적화

https://estrella-kim.github.io/frontend_performance_optimization

## 브라우저 렌더링

https://d2.naver.com/helloworld/5237120

- Rendering : 어떠한 웹 페이지 접속시, 그 페이지를 화면에 그려주는 것(요청받은 내용을 브라우저 화면에 표시하는것)
- 로더가(Loader)가 서버로부터 정보들을 불러옴
- 파싱(Phasing)을 통해 문서를 DOM 트리 만듦
- DOM트리가 구축되는 동안 브라우저는 렌더 트리를 구축
- css 설정/레이아웃 위치 지정
- 렌더링 트리가 그려짐
- 전통적인 웹 어플리케이션은 서버사이드렌더링 방식을 사용(전통 웹 방식 != SSR)

## 서버사이드렌더링

- 요청시마다 서버에서 처리 한 후 새로고침으로 페이지에 대한 응답(View)(새로고침이 일어나며 서버에 새로운 페이지에 대한 요청을 하는 방식)(서버 측에서 HTML&View를 생성하여 응답하는 방식)
- 웹에서 많은 정보와 기능이 많아지면서 싱글페이지어플리케이션(SPA)개념이 생김

장점.

- SSR의 경우 view를 서버에서 렌더링하여 가져오므로 첫 로딩이 매우 짧음(view를 보기까지)
- 물론 js파일을 모두 다운로드하고 적용하기 전까지는 그 어떤 인터렉션에도 반응하지는 않지만, 사용자 입장에서는 로딩이 매우 빠르다고 느껴짐.
- SEO(Search Engine Optimization) 검색엔진 최적화에 유리함(js 라이브러리/프레임워크를 사용하면서 고질적인 문제는 seo이다. 그냥 미리 그려지지 않고 빈 껍데기만 제공된다면 검색엔진이 당연하게도 내용을 검색하는데 어려움이 있음 but, SSR은 서버에서부터 페이지를 제공할 때 컨텐츠가 담겨있기 때문에 SEO에 대한 걱정을 덜 수 있음)

단점.

- 장점을 제공하는 만큼 사용하는데에 있어서 어려움과 번거로움
  (서버사이드 렌더링을 구현하게 된다면, 프로젝트의 구조가 많이 복잡해지게 됩니다.
- 단순히 렌더링만 하는것은 그렇게 큰 문제는 아니지만, 리액트 라우터, 리덕스 등의 라이브러리와 함께 연동해서 사용하면서, 서버에서 데이터를 가져와서 렌더링을 해줘야하는 경우엔 조금 어려워질수도 있습니다.)
- view 변경 시 서버에 계속 요청을 해야하므로 서버에 부담이 큼, 정보가 많은 B2C 웹 서비스 등에는 서버 부담이 큼(요청 시 마다 새로고침이 일어나며 페이지를 로딩할 때마다 서버로부터 리소스를 전달받아 해석하고 화면에 렌더링 하는 방식이기 때문이다. 예를들어 현재 주소에서 동일한 주소를 가리키는(갖고있는) 버튼을 눌렀을때, 설정페이지에서 필요한 데이터를 다시 가져올 수 없다.

이것은 사용자와 인터랙션이 많은 요즘 웹앱에게 충분하지 않는 방법일 수 있다. 렌더링을 서버쪽에서 하는 것은 그 만큼 렌더링을 위한 서버 자원이 사용되는 것이고, 불필요한 트래픽도 낭비되는 것이다.

(대안)동일한 페이지는 특정기간 동안 캐싱하여 성능을 최적화 할 수 있음

(대안)비동기식 렌더링

(써드파티 라이브러리를 통하여 비동기식으로 작동하게끔 코드를 작성 할 수 있습니다.

(대안)메타태그(서버쪽에서 라우트에 따라 필요한 메타태그만 넣어주는 것. 그러면, 크롤러에선 해당 페이지에 대한 기본 정보는 얻어 갈 수 있게 된다.)

- 서버사이드 렌더링을 구현하게 된다면, 프로젝트의 구조가 많이 복잡해지게 됩니다. 단순히 렌더링만 하는것은 그렇게 큰 문제는 아니지만, 리액트 라우터, 리덕스 등의 라이브러리와 함께 연동해서 사용하면서, 서버에서 데이터를 가져와서 렌더링을 해줘야하는 경우엔 조금 어려워질수도 있습니다.

- rapscallion: renderToString 을 비동기로 해주며, Promise 기반으로 작동하고, 컴포넌트 단위로 캐싱을 할 수 있습니다
- hypernova: airbnb 에서 만든 도구로서, 렌더링을 위한 서버를 따로 열어서 cluster 를 사용하여 여러 프로세스를 생성하여 렌더링을하고, 운영서버에서 렌더링서버로 결과물을 요청을 하는 방식으로 작동합니다.
- react-router-server: react-router v4 를 위해 만들어진 서버사이드 렌더링 라이브러리로서, Promise 비동기식 렌더링을 지원해주고, 깔끔한 방식으로 데이터를 불러올 수도 있습니다.)

## 웹 캐시

캐싱 기본 개념.
캐싱(Caching)은 애플리케이션의 처리 속도를 높여준다. 이미 가져온 데이터나 계산된 결과값의 복사본을 저장함으로써 처리 속도를 향상시키며, 이를 통해 향후 요청을 더 빠르게 처리할 수 있다. 대부분의 프로그램이 동일한 데이터나 명령어에 반복해서 엑세스하기 때문에 캐싱은 효율적인 아키텍처 패턴이다.

웹 캐시(WEB Cache).
사용자(client)가 웹 사이트(server)에 접속할 때, 정적 컨텐츠(이미지, JS, CSS 등)를 특정 위치(client, network 등)에 저장하여, 웹 사이트 서버에 해당 컨텐츠를 매번 요청하여 받는것이 아니라, 특정 위치에서 불러옴으로써 사이트 응답시간을 줄이고, 서버 트래픽 감소 효과를 볼 수 있다.

브라우저캐시.
ETag HTTP 응답 헤더는 특정 버전의 리소스를 식별하는 식별자입니다. 웹 서버가 내용을 확인하고 변하지 않았으면, 웹 서버로 full 요청을 보내지 않기 때문에, 캐쉬가 더 효율적이게 되고, 대역폭도 아낄 수 있습니다.

### HTTP 헤더를 통한 브라우저 캐싱

- 모든 브라우저는 HTML 페이지, 자바스크립트 파일 및 이미지와 같은 웹 문서의 임시 저장을 위해 HTTP 캐시 (웹 캐시)의 구현을 제공하고있다.
- HTTP 헤더 지시문을 제공하여 브라우저가 응답을 캐싱할 수 있는 시기와 지속 기간을 지시할 때 사용된다.
- 리소스가 로컬 캐시로부터 빠르게 로드되기 때문에 점점 하드웨어 성능이 급격하고 있는 최근, 잘 활용한다면 엄청 강력한 속도를 제공 한다.
- 요청이 네트워크를 통해 전송되지 않기 때문에 왕복 시간(RTT, Round Trip Time)이 발생하지 않는다.
- 애플리케이션 서버 및 파이프라인의 다른 구성 요소에 대한 부하가 줄어든다.

### 사용자들이 브라우저에 주소를 입력하면 어떻게 화면에 웹사이트가 표시되는 것일까?

1. 브라우저에 도메인 네임 입력
2. DNS서버에 IP주소를 요청
3. 해당 IP주소 응답
4. 해당 IP주소 웹서버에 데이터 요청
5. 요청한 페이지 데이터 응답
6. 요청받은 데이터 브라우저 렌더링

[브라우저에 도메인이 입력]
브라우저는 도메인이 캐시에 들어있는지 확인한다. 만약 Browser Cache에서 못 찾으면, OS의 hosts파일 찾고, 없으면 OS의 저장된 DNS Cache를 찾는다. 만약 OS Cache에서도 못 찾으면, Router DNS Server(현재 접속한 NameServer 주소)에 직접 조회한다.

[DNS서버에 IP 주소를 요청]
Router DNS Server에 조회해서 없다면, Root DNS부터 조회를 하여 결과를 가져온다.

[수신한 IP주소에 해당하는 웹서버에 접속]
Http Request를 위해, TCP Socket을 개방하고, 연결한다. 이 과정에서 3Way Hand-Shaking이 일어난다. TCP 연결에 성공하면, Http Request가 TCP Socket을 통해 보내진다. 이에 대한 응답으로, 웹 페이지의 정보가 사용자의 PC로 들어온다.

- 3Way Handshake: TCP Socket 연결을 하여, 데이터를 전송하기 위해서 발생한다.

1. 클라이언트는 서버에게 통신을 시작한다는 것을 알린다. syn
2. 서버는 클라이언트에게 응답함과 동시에 클라이언트에게 통신을 시작함을 알린다. syn + ack
3. 클라이언트는 서버에게 응답한다. ack (연결 성립 establish)

- 4 Way Handshake: 연결 종료.

1. 클라이언트는 서버에게 통신을 종료한다는 것을 알린다. fin
2. 서버는 클라이언트에게 응답하고 남은 처리가 끝날때까지 기다린다. ack
3. 서버는 클라이언트에게 통신을 종료한다는 것을 알린다. fin
4. 클라이언트는 서버에게 응답한다. ack

## IP

리소스들에게 접근하기 위해서는 해당하는 리소스가 어디있는지 알아야한다. 클라이언트가 인터넷에 연결된 기기를 식별하기 위해 기기들이 가지고 있는 유일한 번호이다.

IPv4 & IPv6.

- IPv4: 8bit씩 4부분의 32bit, 10진수로 표현 (2011년 2월에 IP가 모두 소진)
- IPv6: 16bit씩 8부분의 128bit, 16진수표현

[네트워크주소와 호스트주소]
주소의 클래스별 구분과 서브넷마스크를 통해 두개의 주소를 구분한다.

- 네트워크주소: 네트워크와 또 다른 네트워크를 구분
- 호스트주소: 같은 네트워크 속에서 기기를 식별하는데 사용

* 참고 Prefix

Prefix 표기란 서브넷 마스크 맨 앞의 비트부터 1의 개수를 표기하는 방식을 말한다. 즉 맨 앞에 비트부터 공통 비트 개수를 표기하는 방식이다. 예를 들어 서브넷 마스크가 255.255.255.0인 경우 맨 앞의 비트부터 1이 24개가 있으므로 /24로 표기한다. (네트워크주소: 255.255.255 / 호스트주소: 0~255 이며, 이때 prefix가 24인 이유는 8비트.8비트.8비트.8비트 에서 마지막만 호스트 주소이므로 나머지 8비트.8비트.8비트는 24비트이므로)

- 클래스 A: IP 1~126.xxx.xxx.xxx 국가이상의 큰 통신망에서 사용한다.
- 클래스 B: IP 128~191.0~255.xxx.xxx 학교등 중대규모 통신망에서 사용한다.
- 클래스 C: IP 192~223.0~255.0~255.xxx 소규모회사나 ISP업체의 통신망에서 사용한다.
- 클래스 D: IP 224~239.0~255.0~255.0~255 멀티캐스트시에만 특수 사용하는 클래스
- 클래스 E: IP 240~255.0~255.0~255.0~255 연구용, 테스트용으로 존재하는 클래스이고 사용되지 않는다.

## TCP/IP의 개념

어디서 출발하는지, 어디로 향하는 지에대해 최적의 경로를 선택하는 것이 IP를 통해서 이루어진다면 그 전에 어떻게 데이터를 전송할 것인가에 대한 규약이 필요하다. 어떻게 패킷을 분할하고 조합할 것인가에 대한 규약중 가장 자주 사용되는 것이 TCP이다.

| OSI 계층 | TCP/IP 모델 | . |
| Application <br/> Presentation <br/> Setting | Application | |
| Transport(TCP) | Host-to-Host Transport | 어떻게 전송? |
| Network(IP) | Internet | |
| Data Link | Network Interface| |
| Physical | Hardware | |

네트워크에서 전달하는 데이터의 최소단위를 패킷이라고 하는데 이 패킷은 이쪽 네트워크에서 저쪽 네트워크로 날로 던지지 않는다. 패킷이 전달되기 위해서는 포장하는 과정을 거쳐야하는데 TCP는 패킷을 어떻게 포장할것인가에 대한 약속이다. 패킷은 일련의 순서로 포장되어 보내지고, 받을 때는 반대로 해석된다.

- TCP/IP는 네트워크를 상호연결시켜 정보를 전송 할 수있도록하는 기능을 가진 다수의 프로토콜이 모여있는 프로토콜 집합
- 인터넷은 데이터 링크 계층을 지원하는 네트워크를 TCP/IP 프로토콜을 이용하여 상호연결하는 네트워크
- 인터넷 상의 서로 다른 운영체제를 쓰는 컴퓨터간 데이터 전송을 가능하게 하는 정보전송을 위한 인터넷 표준 프로토콜

## 라우터 / 홉 / DNS

[라우터]
네트워크는 라우터(게이트웨이)라는 장치를 통해서 형성되고 라우터는 목적에 맞는 데이터의 이동경로를 적당히 결정해 준다. 다른 네트워크연결을 라우팅이라고 한다.

[홉(hop)]
인터넷(또는 목적지)에 도달할 때까지 거치는 게이트웨이 개수이다. 일반적으로 네트워크에서 홉 수가 많으면(즉 게이트웨이 수가 많으면) 네트워크 부하가 발생해 전송 속도가 저하될 수 있다.

[DNS]
IP는 위에서 설명한것처럼 12개의 숫자로 이루어져 있다. 하지만 사용자들은 의미도 없는 12개의 숫자를 항상 외우고 다니지 않는다. 따라서 특정 단어(google, facebook)와 실제 IP 주소를 매핑시켜주는 시스템이 필요하고 그것이 DNS이다.

- 순서(역트리): 루트네임서버 -> 최상위도메인(국가명) -> 2단계네임서버

* Root네임 서버: 1단계 네임 서버만 관리
* 1단계 네임 서버: com, net, org 등은 2단계 네임 서버만 관리
* 2단계 네임서버: redhat, naver, samsung 등은 www서버, ftp, mail서버등을 관리

DNS가 동작하는 과정은 다음과 같다.

1. 일단 로컬에 있는 DNS서버에 캐싱해둔걸 먼저 살핀다.
2. 없다면 최상위 도메인에서부터 차례로 트리를 탐색한다.
3. 일치하는 도메인을 찾았다면 IP주소를 반환한다. (Recursive Query)

로컬네임서버.
/etc/resolv.conf에 저장된 네임 서버를 로컬 네임 서버라고 한다. 자신의 캐시 DB를 가진다.

[로컬 네임서버가 작동하는 순서]
응답은 전달받는것이 아닌 조회가능한 서버의 정보를 얻어 로컬네임서버가 직접 질의한다.

1. PI의 웹 브라우저 주소창에 www.nate.com을 입력한다.
2. PC가 리눅스일 경우 hosts파일을 뒤지고 없으면 /etc/resolv.conf 파일을 열어서 'nameserver 네임서버IP'부분을 찾아 로컬 네임 서버 컴퓨터를 알아낸다.
3. 로컬 네임 서버에 www.nate.com의 IP주소를 물어본다.
4. 로컬 네임 서버는 자신의 캐시 DB를 검색해 www.nate.com의 정보가 들어있는지 확인한다.
5. 로컬 네임서버가 'ROOT'서버에게 www.nate.com의 주소를 물어본다.
6. ROOT네임서버도 www.nate.com의 주소를 모르므로, 'com 네임 서버'의 주소를 알려주면서 'com 네임 서버'에게 물어보라고 한다.
7. 로컬 네임서버가 'com 네임 서버'에 www.nate.com의 주소를 물어본다.
8. 'com 네임 서버'도 www.nate.com 의 주소를 모르므로, 'nate.com'을 관리하는 네임서버의 주소를 알려주면서 'nate.com'네임 서버에게 물어보라 한다.
9. 로컬 네임서버가 'nate.com' 네임서버에 'www.nate.com'의 주소를 물어본다.
10. 'nate.com'네임서버는 네이트에서 구축한 네임 서버이므로 ㅇㅇㅇ.nate.com이라는 이름을 가진 컴퓨터의 목록은 모두 있다. www.nate.com의 IP 주소도 알기 때문에 IP주소를 알려준다.
11. 로컬 네임 서버는 www.nate.com의 IP주소를 요구한 PI에 IP주소를 알려 준다.
12. PC는 획득한 IP 주소로 접속을 시도한다.

- HTTPS인 경우 TLS(Transport Layer Security) handshake가 추가된다.
- TLS는 SSL(Secure Sockets Layer)이 표준화 되면서 바뀐 이름이다. HTTPS로 통신을 하게 되면 TCP socket 통신과정 전에 아래와 그림과 같은 통신이 추가 된다.

* 참고) HTTP 연결 이 후에 서버는 연결을 close 할 수도 있고, 클라이언트가 보낸 헤더가 요청한 경우 추가 요청을 위해 연결을 유지 할 수도 있다.

* 304 Not Modified 응답에선 서버는 Payload가 없고 웹 브라우저는 캐시에서 HTML을 검색한다. HTML을 파싱한 후 웹 브라우저와 서버는 GET / HTTP/1.1 요청이 아닌 HTML페이지에서 참조하는 모든 자원(Image, CSS, favicon.ico 등)에 대해 이 프로세스를 반복한다. 만약 HTML이 다른 Domain의 resource를 참조하는 경우 웹 브라우저는 다른 도메인을 확인하는 단계로 돌아가고 해당 도메인에 대해 모든 단계를 수행한다. Host 요청의 header는 해당 서버의 이름으로 설정된다.

## HTTP와 HTTPS

[HTTP(HyperText Transfer Protocol) 프로토콜]
웹상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고 받을 수 있는 프로토콜. 텍스트 교환이다.

- 동작순서: TCP -> HTTP

[HTTPS(Hypertext Transfer Protocol over Secure Socket Layer) 프로토콜]
HTTPS는 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer)프로토콜을 이용하여 웹브라우저(클라이언트)와 서버가 데이터를 주고 받는 통신 규약. 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전으로 HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다. 따라서 데이터의 적절한 보호를 보장한다. HTTPS의 기본 TCP/IP포트는 443이다. 모든사이트가 HTTPS를 안쓰는 이유는? 암호화에 따른 속도저하때문.

SSL 프로토콜은 암호화 중심 프로토콜로 정착시킨 기술로 정보 암호화시 공개키 암호화 방식을 사용하여, 공개키(Pubilc Key)와 개인키(Private Key) 두가지 키를 이용하는 암호화 방법을 사용한다. https 란 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer) 프로토콜을 이용하여 데이터를 전송하고 있다는 것을 의미.

- 동작순서: TCP -> SSL -> HTTP

공개키암호화 방식을 통해 데이터를 암호화하므로 HTTPS를 지원하는 서버에 요청(Request)을 하려면 공개키가 필요하다는 것을 알 수 있다. 그러면 그 공개키는 공개키 저장소(CA:Certificate Authority)에 있다는 것은 알겠는데 어떻게 공개키 저장소에서 가져올까? 추가적으로 공개키는 누구나 얻을 수 있고 공개키를 알면 서버가 주는 데이터(Response)는 알 수 있는데 보안상에 의미가 있을까? 보안상의 의미는 없다. 대신 얻을 수 있는 이점은 해당 서버로부터 온 응답임을 확신할 수 있다. 왜? 공개키로 해독이 가능했으니까 반드시 해당 서버의 개인키로 암호화했다는 것을 보장하기 때문이다.

[CA를 통해 공개키를 획득]

1. 기업이 HTTPS를 적용하기 위해서 공개키와 개인키를 만든다.
2. CA 기업을 선택 후 기업에 내 공개키를 관리해달라고 요청한다.
3. 이때 CA 기업만의 공개키와 개인키가 있다.
4. CA 기업은 CA기업의 이름과 A서버의 공개키, 공개키의 암호화 방법 등의 정보를 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.
5. 이제 클라이언트 입장에서, 예를 들어 A서버로 index.html 파일을 달라고 요청했습니다. 그러면 HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게되겠지요.
6. 여기서 중요합니다. 세계적으로 신뢰할 수 있는 CA 기업의 공개키는 브라우저가 이미 알고 있습니다!
7. 브라우저가 CA 기업 리스트를 쭉 탐색하면서 인증서에 적혀있는 CA기업 이름이 같으면 해당 CA기업의 공개키를 이미 알고 있는 브라우저는 해독할 수 있겠죠? 그러면 해독해서 A서버의 공개키를 얻었습니다.
8. 그러면 A서버와 통신할 때는 A서버의 공개키로 암호화해서 Request를 날리게 되겠죠.

## CDN

콘텐츠를 담고있는 서버(Origin Server)들은 모든 사용자의 요청에 일일이 응답해야 한다. 이는 막대한 트래픽을 유발하고, 트래픽이 과도하게 증가하거나 부하가 끊임없이 들어오는 경우 장애가 발생할 확률도 크다. CDN을 사용함으로써 서버의 트래픽 부하 및 비용을 줄이고 사용자에게 빠른 서비스 제공도 가능하다. 장애 확률도 낮춰 줄 수 있다.

[장점]

1. 웹사이트 로딩 속도 개선
2. 인터넷 회선 비용 절감
3. 컨텐츠 제공의 안정성
4. 웹사이트 보안 개선

[CDN의 작동원리]

1. 최초 요청은 서버로 부터 컨텐츠를 가져와 고객에게 전송하며 동시에 CDN캐싱장비에 저장한다.
2. 두번째 이후 모든 요청은 CDN 업체에서 지정하는 해당 컨텐츠 만료 시점까지 CDN캐싱장비에 저장된 컨텐츠를 전송한다.
3. 자주사용하는 페이지에 한해서 CDN장비에서 캐싱이 되며, 해당 컨텐츠 호출이 없을 경우 주기적으로 삭제된다.
4. 서버가 파일을 찾는 데 실패하는 경우 CDN 플랫폼의 다른 서버에서 콘텐츠를 찾아 엔드유저에게 응답을 전송한다.
5. 콘텐츠를 사용할 수 없거나 콘텐츠가 오래된 경우, CDN은 서버에 대한 요청을 프록시로 작동하여 향후 요청에 대해 응답할 수 있도록 새로운 콘텐츠를 저장한다.

- GSLB(Global Server Load Balancing): 사용자에게 콘텐츠 전송 요청(Delivery Request)을 받았을 때, 최적의 네트워크 환경을 찾아 연결하는 기술. 물리적으로 가장 가깝거나 여유 트래픽이 남아 있는 곳으로 접속을 유도하는 기술로 DNS(도메인 이름을 IP주소로 변환하는 서비스) 서비스의 발전된 형태라고 할 수 있다.

### httpd

HTTPD(HTTP daemon) 서버는 요청 / 응답을 처리하는 서버이다. 가장 일반적인 HTTPD 서버는 Linux의 경우 Apache 또는 Nginx이고 Windows의 경우 IIS이다.

- 데몬(daemon, 발음: 데이먼/'deɪmən/ 또는 디먼 /'dimən/)은 사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다.

## nodejs

Nodejs는 브라우저가 아닌 환경에서도 자바스크립트를 사용할 수 있게 하는 자바스크립트 런타임입니다. 서버사이드에서도 사용합니다. 노드를 통해 데스크탑 윈도우 프로그램도 만들 수 있습니다. 아톰에디터도 노드로 만들어져 있습니다. 노드는 웹서버가 아닙니다. 이 자체로는 아무것도 하지 않습니다. 따라서 HTTP서버를 직접 작성해야 합니다. `그냥 단지 코드를 실행할 수 있는 런타임환경`일 뿐입니다.

- 런타임 환경(영어: runtime environment): 컴퓨터가 실행되는 동안 프로세스나 프로그램을 위한 소프트웨어 서비스를 제공하는 가상 머신의 상태이다.

NodeJs는 HTTP 서버 라이브러리를 포함하고 있는데, 이는 웹 서버를 실행시키기 위한 Apache 같은 서버 프로그램이 필요하지 않다는 것이다. 이에 Apache와 같은 서버 운용정책에 종속 적이지 않고, 다양하게 개발하는 것이 가능하다. 정책이 없는 만큼 복잡하기에 위에 적은 Express가 존재한다. NodeJS의 특징 중의 하나는 단일 쓰레드 환경을 도입한 것이다. 이에 동시접속자가 많아도 'Non-blocking I/O'와 'Event Loop'를 통해 느려지지 않게 서비스를 구성할 수 있다.

Node.js®는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다. Node.js는 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적입니다. Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.

## 블로킹/논블로킹 & 동기/비동기

호출 및 처리 방식에서의 구분.

- Blocking/NonBlocking은 호출한 입장에서의 호출되는 함수가 바로 리턴하는지 하지않는지/하는지
- Sync/Async는 처리되는 방식은 함수완료여부를 신경쓰는지/쓰지않는지

비슷한 동작인것만 같은 Blocking/NonBlocking 과 Synchronous/Asynchronou를 각자의 관심사로 구분할 수 있습니다.

- Blocking: 호출되는 함수가 바로 리턴하지 않는다.
- NonBlocking: 호출되는 함수는 바로 리턴한다.
- Synchronous: 호출하는 함수는 작업 완료 여부를 신경쓴다.
- Asynchronous: 호출하는 함수는 작업 완료 여부를 신경쓰지 않는다.

## 비동기 호출

콜백호출 단점. 우선 가독성이 매우 떨어진다. 만약 비동기 처리가 예제처럼 3개로 끝나지 않는다면 끝없이 옆으로 누운 피라미드를 그리게 될 것. 에러처리를 한다면 모든 콜백에서 각각 에러 핸들링을 해주어야 한다. 콜백의 깊이만큼이나 복잡해지는 에러처리... 만약 에러 처리 없이 진행한다면 콜백 함수가 호출되지 않아도 왜- 어디서- 에러가 발생했는지 알아내기가 쉽지 않다.

프로미스 단점. 이러한 불편함을 해소하기 위해 ES6에서 비동기 흐름을 컨트롤하는 방법으로 Promise 객체가 등장한다. MDN: Promise 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다. 하지만 Promise 패턴도 만능은 아니다. 잘못 사용하면 여전히 then이 깊어질 수 있고, if 문 분기와 특정 에러 핸들링은 여전히 어렵다. 또한 코드가 then 체이닝에 갇혀야 한다.

이후 Async await 등장. MDN: 암시적으로 Promise를 사용하여 결과를 반환합니다.
비동기 함수를 사용하는 코드의 구문과 구조는, 표준 동기 함수를 사용하는것과 많이 비슷합니다.

## Event Loop

위에서 웹 서비스는 Non-Blocking I/O 시스템을 사용해야한다고 하였다. 하지만 브라우저를 비롯한 JavaScript는 단일 스레드 기반의 언어이다. 스레드가 하나라는 말은 곧 동시에 하나의 작업만 처리할 수 있다는 의미이다. 이 문제를 해결하기 위해 등장하는 개념이 Event Loop이다. 자바스크립트는 Event Loop를 이용하여 비동기 방식으로 동시성을 지원한다. 이와 같은 동시성은 JavaScript 엔진이 아닌 브라우저나 Node.js가 담당한다.

## 자바스크립트엔진(콜스택/힙/테스크큐) & WEB API(이벤트루프)

- 싱글스레드기반 호출스택, 순차적으로 하나씩만 처리
- 스택은 선형구조(LIFO - Last In First Out)
- 호출 스택의 각 단계를 스택 프레임(Stack Frame)이라고 합니다. 그리고 보통 예외가 발생했을 때 콘솔 로그 상에서 나타나는 스택 트레이스(Stack Trace)가 오류가 발생하기까지의 스택 트레이스들로 구성됩니다.
- 동적으로 생성된 객체(인스턴스)는 힙(heap)에 할당.
- 자바스크립트에서 비동기로 호출되는 함수(자바스크립트 엔진이 아닌 브라우저 APIs(Web API) 영역에 따로 정의되어 있는 함수들)들은 Call Stack에 쌓이지 않고 Task Queue에 들어 갑니다.
- 비동기 콜백은 즉시 호출 스택에 쌓이지 않고 Event Queue에서 기다렸다가 호출 스택이 비어있는 시점에 실행
- 브라우저는 호출 스택이 비워질 때마다 작업 큐에서 가장 오래된 작업을 꺼내와서 해당 작업에 대한 콜백을 실행시킵니다. 브라우저는 이 과정을 끊임없이 반복하는데, 이를 이벤트 루프(event loop)라고 부릅니다.
- 자바스크립트는 Event Loop를 이용하여 비동기 방식으로 동시성을 지원한다.
- 이벤트 루프의 기본 역할은 큐와 스택 두 부분을 지켜보고 있다가 스택이 비는 시점에 콜백을 실행시켜 주는 것입니다.

## 하이브리드앱(앱설치유무, 카메라, 앨범, 좌표 등)

하이브리드앱의 장점.

- 네이티브API와 브라우저 API를 이용한 다양한 개발이 가능
- 웹 기술을 사용해 앱을 개발 가능 (UI를 통합하여 단일 코드로 개발 가능)
- 한번의 개발로 다수의 플랫폼에 대응 가능

하이브리드앱의 단점.

- 네이티브 기능에 접근하기 위해 결국 네이티브 지식이 필요
- 웹뷰에서 앱을 실행하는 경우이기에 앱의 성능이 곧 브라우저의 성능
- UI프레임워크 도구를 사용하지 않는다면 개발자가 UI를 제작해야 함

## 에셋 비율 PPI

화소밀도의 단위인 PPI, Pixels Per Inch는 말그대로 디스플레이에서 1inch² 당 들어가는 픽셀의 단위입니다. 1인치당 픽셀이 몇 개로 이루어졌는지를 나타내는 디스플레이 장치의 해상도 밀도 단위입니다. 스마트폰이 진화하면서 스크린 사이즈는 비슷하지만 PPI가 높아지기 시작합니다. 같은 면적에서 해상도가 높아지면 이미지는 압축되어 사이즈가 작게 보입니다.

- 10PPI면 정사각형의 한 면 1inch(2.54cm)에 10개의 픽셀이 있고, 총 10x10 = 100개의 픽셀로 이루어져 있다는 뜻입니다.
- 20PPI면 정사각형의 한 면 1inch(2.54cm)에 20개의 픽셀이 있고, 총 20x20 = 200개의 픽셀로 이루어져 있다는 뜻입니다.

20PPI의 해상도가 더 높다고 할수 있습니다. 따라서 를 같은 면적(10PPI의 면적)에서 해상도가 높아지면(20x20) 이미지는 압축되어 사이즈가 작게 보입니다.

도트 퍼 인치(Dots per inch, DPI)는 1인치당 점이 몇 개가 들어갔는지를 말합니다. 프린터의 성능 등 출력물에 대한 해상도를 나타낼 때 쓰는 단위입니다. 인쇄와 디스플레이 해상도의 측정 단위이며, 특히 1 제곱인치 (2.54 제곱센티미터) 공간 안에 만들어진 점이나 화소의 수를 말한다.

- 10DPI면 정사각형의 한 면 1inch(2.54cm)에 10개의 점이 있고, 총 10x10 = 100개의 점으로 이루어져 있다는 뜻입니다.

“저밀도” 화면은 “중간 밀도” 또는 “고밀도” 화면에 비해 물리적 공간안의 픽셀 수가 더 적습니다. 아래는 디자이너가 알아야 하는 비율을 정리한 표입니다. 1x를 기본으로 디자인하고 각 환경별로 다음과 같은 배수가 필요하다는 점만 기억하면 됩니다.

<p>Low density (120dpi) (0.75x): ldpi<br>
Medium density (160dpi) (baseline) : mdpi<br>
High density (240dpi) (1.5x) : hdpi<br>
Extra High density (320dpi) (2x) : xhdpi<br>
Extra Extra High density (480dpi) (3x) : xxhdpi<br>
Extra Extra Extra High density (480dpi) (4x) : xxhdpi</p>

결론, 이미지크기와 선명도의 차이는?
토대가 되는 A4사이즈는 PPI가 DPI로써 선명도로만 영향을 주는거고, 디스플레이에서는 모니터 화면 자체에 픽셀이 고정되어 있기 때문에 웹이나 포토샵에서는 inch 당 픽셀 개수에 맞게 사진이 줄어드는 것입니다.

## MVC(Model, View, Controller)

화면과 데이터 처리를 분리해서 재사용이 가능하도록 하는 구조

- 모델: 데이터 혹은 데이터를 처리하는 영역
- 뷰: 결과 화면을 만들어 내는 데 사용하는 자원
- 컨트롤러: 웹의 요청(request)을 처리하는 존재로 뷰와 모델 사이의 중간 통식 역할

모델 2 방식은 개발자와 웹 퍼블리셔의 영역을 분리할 수 있으며, 컨트롤러의 URI를 통해서 뷰를 제어하기 때문에, 뷰의 교체나 변경과 같은 유지보수에 유용하게 사용될 수 있다.

MVC1.
Controller와 View가 요청과 응답을 함께 관리 합니다. 개발 속도가 빠르고 쉬우나 단, View(프리젠테이션 로직)과 Controller(비즈니스 로직)을 모두 포함하기 때문에 페이지가 너무 복잡해 질 수 있습니다. 또 로직이 혼재되어 있기 때문에 개발자와 디자이너의 분리된 작업이 어렵습니다. 유지보수 하기 어려워지고 정교한 Presentation 레이어를 구현하는데도 어렵습니다.(유효성 체크, 에러 처리등)

MVC2.
Controller와 View가 분리되어 요청과 응답을 각각 관리 합니다. View가 보여주는 역할을 명확히 분담하기 때문에 UI레이어가 단순해지고 Presentation 레이어의 정교한 개발이 가능합니다.

## 클로저

내부 함수의 [[Scopes]] 프로퍼티는 자신의 실행 환경(Lexical Enviroment)과 자신을 포함하는 외부 함수의 실행 환경과 전역 객체를 가리키는데 이때 자신을 포함하는 외부 함수의 실행 컨텍스트가 소멸하여도 [[Scopes]] 프로퍼티가 가리키는 외부 함수의 실행 환경(Activation object)은 소멸하지 않고 참조할 수 있다. 이것이 클로저이다.

- 스코프체인: 변수검색 메커니즘
- 프로토타입체인: 객체의 프로퍼티를 검색하는 메커니즘

클로저는, 함수 자신이 포함하는 스코프의 변수들!을 추적하는 함수입니다.함수가 중첩되어 있으면 중첩될 때마다 부모 함수의 Scope가 자식 함수의 스코프 체인에 포함됩니다.

- 자바스크립트 함수는, 호출되었을 때 실행되기 위한 코드뿐만 아니라, 더 많은 정보를 포함하고 있기 때문에 만들어진 환경을 기억한다고 할 수 있습니다. (이때, 메모리 소모)
- 자바스크립트 함수는, 해당 스코프에 선언되어 어떤 변수더라도, 내부적으로 보관합니다.
- 따라서 스코프 내에 포함된 어떤 변수라도 참조할 수 있고
- 값을 복사하지 않고 참조하고 있기 때문에 외부변수의 값을 변경 할 수도 있습니다.

- 클로저를 통해 내부 변수를 참조하는 동안에는 해당 변수가 차지하는 메모리를 GC가 회수하지 않으므로 클로저 사용이 끝나면 참조를 제거하는 것이 좋습니다.

- 클로저는 함수내의 지역변수를 감추는 은폐의 역할을 가능하게 합니다.
- 복잡한 코드를 쉽고 간결한 코드를 작성할 수 있습니다. (객체반환x, 함수반환o)
- 자바스크립트에서 클로저가 많이 사용되는 부분은 이벤트 그리고 비동기식 호출의 경우라고 할 수 있습니다.

```js
function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + "px";
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById("size-12").onclick = size12;
document.getElementById("size-14").onclick = size14;
document.getElementById("size-16").onclick = size16;
```

## Canvas & SVG

- Canvas: 성능이 중요한 경우 활용, 빠른 대용량 데이터 처리에 적합, 동적인 데이터
- SVG: 디자인 및 요소별 커스터마이징 가능, 다양한 해상도에 적합, 정적인 데이터

## 세션 스토리지 쿠키 차이

웹 사이트 정보를 저장하기위한 클라이언트 로컬 저장공간. 각각의 목적과 차이!

### 세션

- 클라이언트 정보를 서버에 저장.
- 브라우저마다 별도 세션 가진다.
- 로그인 정보처럼 페이지를 이동하더라도 계속 유지되어야 하는 정보 저장한다.
- 브라우저 종료할때까지 유지된다.
- 세션아이디를 주고 받기도 한다.
- 단점은, 서버의 메모리를 사용하는 것이기 때문에 서버자원 문제 및 서버에 있는 정보 처리가 요구되어 속도가 느려질 수 있다.
- 세션아이디만 쿠키에 저장해서 사용하면 비교적 보안에 좋다.

### 쿠키

- 서버와 클라이언트 간의 지속적인 데이터 교환 목적으로 사용한다.
- 브라우저에 파일 형태로 저장한다.
- 파일로 저장되기 때문에 브라우저 종료해도 정보는 남아 있다
- 서버 요청시마다 함께 전송되며 문자열만 저장 가능하다. (4KB)
- 서버통신에 필요없는 데이터를 전송하게되면 데이터가 낭비된다.
- 팝업창 일정기간 보이지 않기, 서버통신에 필요한 인증과 관련된 정보나 세션에 저장된 토큰값을 저장하는데 활용된다.

### 웹 스토리지(로컬스토리지 / 세션스토리지)

- 쿠키의 제한점을 보완하기 위하여 등장하였다.
- 용량도 커졌고 서버로는 전달되지 않고 브라우저 로컬에만 저장되어 보안이 보장된다.
- 윈도우객체안에 들어있다.
- 자바스크립트 객체저장이 가능하다.

### 로컬스토리지

- 삭제하기 전까지 브라우저에 계속 저장되어 있다. (10MB)

### 세션스토리지

- 세션 유지기간에만 사용하능한 스토리지로 브라우저를 종료하면 자동 소멸한다. (5MB)

## 호이스팅

자바스크립트 엔진이 실행 컨텍스트를 생성하면서 스코프를 정의할 때, 즉 기술된 순서에 상관없이 선언부에 대한 처리를 해석할때, 우선순위가 최우선으로 끌어올려서 먼저 해석하게 된다. 코드작성순서에 상관없이 선언구문을 최우선으로 해석한다.

1. 선언 단계(Declaration phase)
   변수 객체(Variable Object)에 변수를 등록한다. 이 변수 객체는 스코프가 참조할 수 있는 대상이 된다.
2. 기화 단계(Initialization phase)
   변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다.
3. 할당 단계(Assignment phase)
   undefined로 초기화된 변수에 실제값을 할당한다.

var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 다시 말해 스코프 체인이 가리키는 변수 객체에 변수가 등록되고 변수는 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라한다.

함수 선언식-호이스팅vs함수 표현식-할당.

- 함수선언식의 경우, 변수 객체(VO)에 함수표현식과 동일하게 함수명을 프로퍼티로 함수 객체를 할당한다는 것이다. 단, 함수선언식은 변수 객체(VO)에 함수명을 프로퍼티로 추가하고 즉시 함수 객체를 즉시 할당하지만 함수 표현식은 일반 변수의 방식을 따른다. 따라서 함수선언식의 경우, 선언문 이전에 함수를 호출할 수 있다. 이러한 현상을 함수 호이스팅(Function Hoisting)이라 한다.

## 실행컨텍스트

.

---

## 디자인 패턴

- 어댑터:
- 스트레티지:
- 옵저버:
- 싱글톤:
- 템플릿:
- 팩토리: 팩토리 메소드 패턴은 객체 생성을 직접하지 않고 하위 클래스가 어떤 객체 생성을 할지 결정하도록 위임
- 프록시:
- 아토믹:

외,

- 덕패턴: 함께 작업이 이루어지는 파일들을 하나로 합쳐 사용
- 코로케이션: 함께 수정되는 파일들을 같이 두는 것

---

## 검색엔진 최적화 SEO

- 보안 프로토콜 적용(HTTPS): 적용을 장려하는 가산점
- 문법에 맞는 HTML 작성하기
- 구체적인 페이지 제목 만들기
- 메타 태그 활용하기
- Robots.txt: 검색엔진 알고리즘이 접근하기 쉽도록 허용
- Sitemap.xml: 크롤링과정에서 색인될 수 있게 함
- Img의 alt 속성 적용: 높은 검색 순위 적용 및 이해
- 서버사이드 렌더링

---

## 자바스크립트 함수는 일급 객체(First Class)이다.

1. 러터럴에 의해 생성
2. 변수나 배열의 요소(원소), 객체의 프로퍼티 등에 할당 가능
3. 함수의 인자로 전달 가능
4. 함수의 러턴값으로 리턴 가능
5. 동적으로 프로퍼티를 생성 및 할당 가능


## 순수함수
순수 함수는 예측이 가능하고, 디버그가 쉬우며 테스트하는 것은 더욱 쉽습니다. 그들의 참조 투명성referentially transparent 덕분에, 함수 결과를 캐싱하여 반복적으로 사용 할 수 있는 메모이제이션memoization 최적화 기법이 사용 가능합니다.

## 프로그래밍 패러다임
| 명령형imperative | 선언형declarative |
| 어떻게(How) | 무엇을(What) | 
| 우리가 그것을 이루는 방법 | 우리가 이루고자 하는 것 |
| 목표보다는 알고리즘 명시 | 알고리즘보다는 목표 |
| 절차지향, 객체지향 | 함수형 |

- 명령형 프로그래밍: 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식. 알고리즘을 명시하고 목표는 명시 안함.
  - 절차지향 프로그래밍: 수행되어야 할 연속적인 계산 과정을 포함하는 방식 (C, C++)
  - 객체지향 프로그래밍: 객체들의 집합으로 프로그램의 상호작용을 표현 (C++, Java, C#)
- 선언형 프로그래밍: 어떤 방법으로 해야 하는지(How)를 나타내기보다 무엇(What)과 같은지를 설명하는 방식. 알고리즘 명시하지 않고 목표만 명시.
  - 함수형 프로그래밍: 순수 함수를 조합하고 소프트웨어를 만드는 방식 (클로저, 하스켈, 리스프)

## 함수형 프로그래밍 (선언형: 알고리즘 보다는 목표를)

함수형 프로그래밍의 컨셉
- 변경 가능한 상태를 불변상태(Immutab)로 만들어 SideEffect를 없애자.
- 모든 것은 객체이다.
- 코드를 간결하게 하고 가독성을 높여 구현할 로직에 집중 시키자.
- 동시성 작업을 보다 쉽게 안전하게 구현 하자.

함수형 프로그래밍(종종 줄여서 FP라고 부름)은 순수 함수(pure function) 를 조합하고 공유 상태(shared state), 변경 가능한 데이터(mutable data) 및 부작용(side-effects) 을 피하여 소프트웨어를 만드는 프로세스입니다. 함수형 프로그래밍은 명령형(imperative) 이 아닌 선언형(declarative) 이며 애플리케이션의 상태는 순수 함수를 통해 전달됩니다. 애플리케이션의 상태가 일반적으로 공유되고 객체의 메서드와 함께 배치되는 객체 지향 프로그래밍과는 대조됩니다.

- 명령형 프로그램은 알고리즘을 명시하고 목표는 명시하지 않는다.
- 명령형 방법을 사용하는 경우 개발자는 컴퓨터에서 목표를 이루기 위해 수행해야 하는 단계를 매우 자세히 설명하는 코드를 작성하며, 이러한 프로그래밍을 알고리즘 프로그래밍이라고도 한다.

- 선언형 프로그램은 목표를 명시하고 알고리즘을 명시하지 않는 것이다.
- 선언형인 함수형 프로그래밍 패러다임은 순수하게 함수적인 접근 방법으로 문제를 해결하는 것을 지원하기 위해 만들어졌다. 함수형 방법에는 실행할 일련의 함수로 문제를 구성하는 작업이 포함된다. 함수형 프로그래밍에서는 상태와 변경 가능한 데이터를 사용하지 않으며 대신 함수의 적용을 강조한다.

- 객체지향 프로그래밍은 프로그래머들이 프로그램을 상호작용하는 객체들의 집합
- 함수형 프로그래밍은 상태값을 지니지 않는 함수값들의 연속

[명령형]
횡단보도까지 약 99m 이동(성남대로331번길) ,
횡단보도를 이용하여 경기성남분당경찰서 방면으로 횡단,
횡단보도까지 1개의 횡단보도를 지나 약 612m 이동,
횡단보도를 이용하여 메르세데스벤츠코리아더클래스효성분당전시장 방면으로 횡단,
네이버까지 약 50m 이동(불정로).

[선언형]
출발: 경기도 성남시 분당구 성남대로 333,
도착: 네이버 주소는 경기도 성남시 분당구 불정로 6.

## 객체지향 프로그래밍 4가지 특징

- 추상화
- 캡슐화
- 상속
- 다형성

객체는 속성(필드)과 메소드(동작)로 구성된다.

자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다. 자바스크립트를 객체지향적인 언어라고 말할 수 있는 가장 중요한 이유 중 하나는 프로토타입 상속(prototypal inheritance) 이라는 확장과 재사용을 가능하게 해주기 때문입니다.

## 객체 지향 설계 5대 원칙

- SRP (Single Responsibility Principle) 단일 책임 원칙
- OCP (Open Closed Principle) 개방 폐쇄 원칙
- LSP (Liskov Substitution Principle) 리스코프 치환 원칙
- ISP (Interface Segregation Principle) 인터페이스 분리 원칙
- DIP (Dependency Inversion Principle) 의존 역전 원칙

---

## 유저에이전트

웹사이트에 접속한 사용자의 환경 디바이스정보, 운영체제, 사용하는 브라우저 등의 정보를 담고 있습니다. 브라우저와 웹 표준이 완벽하지 않아 발생하는 호환성 문제를 대응하거나 사용자의 사용환경을 파악하여 그에 맞는 컨텐츠를 제공합니다. 마케팅을 위한 용도로도 활용됩니다. 제공자 입장에서는 사용자에게 맞춰서 서비스를 제공할 수 있기 때문에 꽤 중요합니다.

## Same-Origin Policy 동일 출처 정책

브라우저 보안상 브라우저에서는 특정 도메인에서 다른 도메인의 데이터를 접근하지 못하게 막습니다. 즉, 다른 출처에서 가져온 리소스(cors)와 상호작용하는 것을 제한하는 중요한 보안 방식입니다. 이것은 잠재적 악성 문서를 격리하여, 공격 경로를 줄이는데 도움이 됩니다.

동일 출처 정책(same-origin policy) 때문에 CORS 같은 상황이 발생하면 외부서버에 요청한 데이터를 브라우저에서 보안목적으로 차단합니다. 그로 인해 정상적으로 데이터를 받을 수 없습니다.

## CORS(Cross-Origin Resource Sharing)

CORS는 교차 출처 리소스 공유로 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제입니다. 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 교차 출처 HTTP 요청을 실행합니다. 서버 단에서 데이터 접근 권한을 허용하는 정책이라고 할 수 있습니다.

Cross-Origin HTTP 요청을 허가 해주는 방법.

- Access-Control-Allow-Origin response 헤더를 추가 모든 클라이언트에 요청에 대한 cross-origin HTTP 요청을 허가하는 헤더를 추가한다.
- 미들웨어 CORS 추가: 허락하고자 하는 요청 주소를 추가한다.

cors란 도메인 또는 포트가 다른 서버의 자원을 요청하면 발생하는 이슈이다. 서버와 클라이언트가 분리되어 있는 앱에서는 cross-origin HTTP 요청을 서버에서 승인해주는 것이 좋다.

## RESTfulAPI

REST(REpresentational State Transfer)는 용어를 해석하면 대표적인 상태 전달입니다. REST란, "웹에 존재하는 모든 자원(이미지, 동영상, DB 자원)에 고유한 URI를 부여해 활용"하는 것으로, 자원을 정의하고 자원에 대한 주소를 지정하는 방법론을 의미한다고 한다. 따라서 Restful API는 REST 특징을 지키면서 API를 제공하는 것을 의미한다. (일종의 Coding Convention이랄까. 설계원칙, 가이드를 지키면서 개발을 하자는 의미인듯 싶다.)

RESTfulAPI는 HTTP프로토콜을 활용하여 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식으로 자원URI + 행위Method + 표현Json을 통해 구현합니다. 클라이언트와 서버 간에 `데이터를 주고받기 위한 URL 규칙`입니다.

- 동사보다는 명사를
- 대문자보다는 소문자로
- 밑줄보다는 하이픈을

다음과 같은 특징이 있습니다.

- Uniform (유니폼 인터페이스)
- Stateless (무상태성)
- Cacheable (캐시가능)

## PUT과 PATHC

- PUT: 자원의 전체 교체, 자원내 모든 필드 필요. 만약 전체가 아닌 일부만 전달할 경우, 전달한 필드외 모두 null or 초기값 처리되니 주의
- PATCH: 자원의 부분 교체, 자원내 일부 필드 필요

---

## HTTP 프로토콜 특징

HTTP(Hypertext Transfer Protocol)는 애플리케이션 계층의 프로토콜로입니다. html 같은 HyperText 문서를 전송하기 위한 통신 규약으로 클라이언트와 서버가 서로 통신하기 위한 프로토콜입니다. HTTP 프로토콜은 상태가 없는(stateless) 프로토콜입니다. 여기서 상태가 없다라는 말은 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다는 말입니다. 좀 더 쉽게 말해서 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없다는 말이죠.

비연결지향으로 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response를 보내면 바로 연결을 끊는다. 연결을 끊어버리기 때문에, 클라이언트의 이전 상황을 알 수가 없다. 이러한 특징을 무상태(Stateless)라고 말한다. 이러한 특징 때문에 정보를 유지하기 위해서 Cookie와 같은 기술이 등장하게 되었다.

## 웹사이트 최적화

https://hahahoho5915.tistory.com/33

- WebCache
- Code Compressing
- Image Optimizing
- Image Spriting
- Critical Rendering Path
- Webfont Optimizing
- Lazy Loading

웹 캐쉬.
client가 요청하는 Resource(html, image, js, css등)에 대해 최초 요청 시 파일을 내려받아 특정 위치에 복사본을 저장, 이후 동일한 URL의 Resource요청은 내부에 저장한 파일(캐시)을 사용하여 더 빠르게 서비스하기 위한 것 이다. 서버를 통하지 않아 응답 시간이 감소하고 네트워크 트레픽이 감소되니 잘만 사용한다면 정말 좋은일이다.

하지만 잘못 사용한다면 고객들에게 실시간으로 정보를 올바르게 주지 못하고, 오히려 고객 CS가 발생하는 등 해당 업무 프로세스와, 시스템 환경을 잘 분석하여 적용하는 것이 중요할 것이다.

웹 캐쉬의 종류.
웹 캐쉬의 종류는 어디에 적용하느냐에 따라 다음과 같이 나뉠 수 있으며 이중 중점적으로 볼 내용은 Browser Cache입니다.

1. Browser Caches

- 브라우저 또는 HTTP요청을 하는 Client Application에 의해 내부 디스크에 캐쉬
- Cache된 Resource를 공유하지 않는 한 개인에 한정된 Cache
- 브라우저의 Back버튼 또는 이미 방문한 페이지를 재 방문하는 경우 극대화

2. Proxy Caches

- Browser Cache와 동일한 원리로 동작하며 Client나 Server가아닌 네트워크 상에서 동작.
- 큰회사나 IPS의 방화벽에 설치 되며 대기시간 & 트래픽 감소, 접근정책 & 제한 우회, 사용률 기록등 수행
- 한정된 수의 클라이언트을 위하여 무한대의 웹서버의 컨텐츠를 캐쉬

3. Gateway Caches (REVERSE OR SURROGATE PROXY)

- 서버 앞 단에 설치되어 요청에 대한 캐쉬 및 효율적인 분배를 통해 가용성, 신뢰성, 성능등을 향상
- Encryption / SSL acceleration, Load balancing, Serve/cache static content, Compression등을 수행
- 무한대의 클라이언트들에게 한정된 수(또는 하나)의 웹서버 컨텐츠를 제공

브라우저 캐쉬 동작.
https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#invalidating-and-updating-cached-responses
https://goddaehee.tistory.com/171

이제 캐쉬가 일어나는 과정에서 위에서 설명한 http header들이 어떻게 사용되는지 살펴보겠습니다.

첫 요청

1. 브라우저는 서버에 index.html 파일을 요청합니다.
2. 서버는 index.html파일을 찾아보고 존재 하는 파일이라면 파일 내용을 브라우저에게 몇 가지 header값과 함께 응답합니다.
3. 브라우저는 응답 받은 내용을 브라우저에 표시하고 응답 헤더의 내용에 따라 캐쉬 정책을 수행합니다. (응답 헤더에 Last-Modified, Etag, Expires, Cache-Control:max-age 항목이 존재 한다면 복사본을 생성하고 값을 저장)

재요청.

(validation 수행)

- REQUEST: If-Modified-Since / If-None-Match
- RESPONSE: Last-Modified / Etag

(LAST-MODIFIED)

1. 브라우저는 최초 응답 시 받은 Last-Modified 값을 If-Modified-Since 라는 헤더에 포함 시켜 페이지를 요청합니다.
2. 서버는 요청 파일의 수정 시간을 If-Modified-Since값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면 200 OK와 함께 새로운 Last-Modified값을 응답 헤더에 전송합니다.
3. 브라우저는 응답 코드가 304인경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은후 Last-Modified값을 갱신합니다.

(ETAG: ENTITY TAG)
ETag HTTP 응답 헤더는 특정 버전의 리소스를 식별하는 식별자입니다. 웹 서버가 내용을 확인하고 변하지 않았으면, 웹 서버로 full 요청을 보내지 않기 때문에, 캐쉬가 더 효율적이게 되고, 대역폭도 아낄 수 있습니다.

1. 브라우저는 최초 응답 시 받은 Etag값을 If-None-Match 라는 헤더에 포함 시켜 페이지를 요청합니다.
2. 서버는 요청 파일의 Etag값을 If-None-Match값과 비교하여 동일하다 면 304 Not Modified로 응답하고 다르다면 200 OK와 함께 새로운 Etag 값을 응답 헤더에 전송합니다.
3. 브라우저는 응답코드가 304인 경우 캐쉬에서 페이지를 로드하고, 200이라면 새로 다운 받은후 Etag값을 갱신합니다.

- Etag는 서버마다 생성하는 값이 다르며 파일마다 고유한 값을 가집니다.
- LAST-MODIFED(1.0) 와 ETAG(1.1)는 validation을 체크 합니다. 이를 체크하기 위해 서버와 한번의 통신이 발생하게 되며 그로 인해 요청과 응답에서 header와 cookie등에 의한 데이터 전송(1KB)이 발생하게 됩니다.

If-None-Match.

- 서버보고 ETag가 달라졌는 지 검사하고 ETag가 다를 경우에만 컨텐츠를 새로 받는다.
  ex) If-None-Match: "0-2b800-5c466dda"
- 만약 ETag가 같다면 서버는 304 Not Modified를 응답하고 캐시를 그대로 사용하게 한다.

(Age)
Age 헤더는 캐시 응답 때 나타나는데, max-age 시간 내에서 얼마나 흘렀는지 초 단위로 알려줍니다. 위 예제에서 max-age= 3600을 설정한 경우, 1분이 지나면 Age: 60 이 캐시 응답 헤더에 포함됩니다.

(Expires)
Expires 날짜 헤더를 응답에 첨부할 수 있다.

1. 브라우저는 최초 응답 시 받은 Expires 시간을 비교하여 기간 내라면 서버를 거치지 않고 바로 캐쉬에서 페이지를 로드 합니다. 만약 기간이 만료되었다면 위에 설명한 validation 작업을 수행합니다. Cache-Control과 별개로 응답에 Expires라는 헤더를 줄 수도 있습니다. 응답 컨텐츠가 언제 만료되는지를 나타내며, Cache-Control의 max-age가 있는 경우 이 헤더는 무시됩니다.

(Cache-Control)

1. 브라우저는 최초 응답 시 받은 Cache-Control 중 max-age값(초 단위)를 GMT와 비교하여 기간 내라면 서버를 거치지 않고 캐쉬에서 페이지를 로드합니다. 만약 기간이 만료되었다면 validation 작업을 수행합니다.

- no-store: 캐시가 그 응답의 사본을 만드는 것을 금지한다.
- no-cache: 응답은 로컬 캐시 저장소에 저장될 수 있다. 다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없다.
- max-age: 신선하다고 간주되었던 문서(만료되지 않은 문서)가 서버로부터 온 이후로 흐른 시간이고, 초로 나타낸다.
- must-revalidate: 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안 된다는 것을 의미한다.

아래 두 값을 통해 캐시를 막을 수 있다.

- no-cache: no-cache는 브라우저가 서버의 응답을 캐시할지 스스로 결정할 수 있다. 하지만, 캐시된 정보가 해당 서버에서 제공한 것인지는 요청을 하게 된다.
- no-store: no-store는 브라우저가 서버의 응답을 캐시하지 못하도록 한다. 이 말은 반드시 매번 서버에 요청해야만 한다는 의미이다.

* Expires(1.0)와 Cache-Control: max-age(1.1)는 freshness를 체크합니다. 기간 내라면 서버와 통신을 하지 않고 캐쉬를 사용합니다.
* 시간은 HTTP date 형태이며 로컬 타임이 아닌 GMT를 사용합니다.
* 서버가 Last Modified Time 또는 Last Access Time을 기준으로 하여 일정 시간 이후로 Expires 또는 max-age를 설정 합니다.

## CACHING STRATEGY

캐쉬가 잘 적용되게 하기 위해서 다음과 같은 전략을 새웁니다.

1. 일관된 URL을 사용하라. 동일한 URL은 동일한 사이트라면 다른 페이지에서도 캐쉬되어 사용될 수 있습니다.
2. 자주 바뀌는 파일과 그렇지 않은 파일을 분리합니다. 그래야 각 Resource에 대해 최적의 freshness를 설정할 수 있습니다.
3. 다운가능한 파일의 내용이 바뀌면 이름(URL)을 바꿉니다. 그래야 수정된 버전(핑거프린트)을 제공할 수 있습니다.
4. SSL을 최소화 합니다. 암호화된 페이지는 캐쉬되지 않습니다.

## 웹 최적화 방안

https://estrella-kim.github.io/frontend_performance_optimization

로딩 최적화.

- 브라우저:

렌더링 최적화.

- 레이아웃 스레싱:
- 가상돔:
- 웹워커:

## HTTP 요청 줄이기

초기 커넥션당 하나의 요청으로 인하여 동시 전송이 불가하였습니다. 파이프라이닝 기법을 통해 요청을 연속적으로 발생시켜 응답을 받았는데 다수 리소스 요청시 맨 마지막요청은 대시시간이 길어지는 문제가 여전히 발생하였습니다. HTTP2에서는 멀티플렉싱 스트림 기능으로 동시에 여러 메시지를 주고 받을 수 있게 되었습니다. 또, 리소스간 의존관계(우선순위)를 설정하여 렌더링이 늦어지는 문제를 해결하였습니다.

- 이미지스프라이팅: 큰 이미지에 좌표값을 지정한다
- 도메인 샤딩: 커넥션 수를 늘린다
- 압축: 전송되는 데이터용량을 줄인다.
- 데이터 URI스킴 사용: base64인코딩으로 이미지를 적용한다.
- HTML구조와 CSS스타일 렌더링시, 자바스크립트를 만나면 js완료전가지 렌더링이 블록된다. 스크립트 삽입 위치에 따라 스크립트 실행순서와 브라우저렌더링에 영향을 줄 수 있다. (defer는 외부자원비동기로딩 html파싱후 스크립트 실행 / async는 외부자원비동기로딩 받는 즉시 스크립트 실행)

style는 head에, javascript는 body 최하단에 위치.
기본적으로, 브라우저가 페이지를 렌더링하려면 먼저 HTML 마크업을 파싱하여 DOM을 빌드해야 합니다. 하지만 브라우저가 파싱을 하다가 스크립트 파일을 만날 경우, 스크립트 파일을 요청하고 다 불러와지는 동안 구문에 대한 분석을 중단하게 되는데, 이것이 우리가 흔히 말하는 렌더링 블록킹(Rendering Blocking) 현상입니다. 당연히 렌더링이 계속해서 블록될 시 페이지의 첫 렌더링 시간은 지연될 수 밖에 없으며, 이는 곧 좋지 않은 사용자 경험으로 이어지게 됩니다. 이와 같은 이유 때문에, style과 script 파일을 지정된 곳에 위치시켜야 한다는 것이고, 좀 더 나은 페이지의 성능을 위해 간단하지만 필수적이라고 할 수 있습니다.

---

## 자바스크립트

자바스크립트는 싱글 스레드이기 때문에 이벤트 루프를 이용한 Callback 패턴을 굉장히 자주 사용

출처: https://dev-momo.tistory.com/entry/React-Hooks?category=536788 [Programming Note]

## React

- 가장 중요한것은 리엑트 상태의 불변
- 부작용(Side-Effect)없이 프로그래밍 하는 좋은 방법 중 하나는 커다란 코드를 작은 단위로 쪼개서 작성하는 것이다. (함수나 클래스를 사용하기도 하고, React에서는 컴포넌트라는 개념)

## 컴포넌트

컴포넌트의 역할을 분리해 각각 고유한 책임을 부여함으로서 재사용성을 높이고, 디버깅을 쉽게하는데 그 목적이 있다. 컴포넌트나 state를 재활용하기 위해 HOC를 많이 사용하게 된다면 Wrapper Hell을 마주하게 된다.

- Presentational 컴포넌트: 즉 보여주는데 초점을 맞춘 이 컴포넌트는 스타일 정보만을 가지며 화면을 그리는데만 집중한다. 이 컴포넌트는 보여주는데 집중하기 때문에 복잡한 비지니스 로직을 가지지 않으므로 state를 가질 필요가 없다. 따라서 함수형 컴포넌트(Functional Component)로 많이 구현을 한다.
- Container 컴포넌트: 비지니스 로직을 가지고 있으며, Presentational Component들을 가지고 화면을 그리는 최소한의 스타일 정보만 가지고 있다.

[hook 장점]

- useState라는 Hook을 사용하면 state를 재사용 할 수 있게 해줄 뿐만 아니라, 비교적 덜 무거운 함수형 컴포넌트에도 state를 사용할 수 있다. 재사용하기 쉽게 모듈화 되었고, 가독성도 훨씬 좋아진 것을 알 수 있다.
- 컴포넌트를 개발하다보면 라이프 사이클에 중복된 로직을 사용하는 경우가 상당히 빈번하다. useEffect는 componentDidMount, componentDidUpdate, 그리고 componentWillUnmount를 합친 기능을 한다.
- Class안에서 사용하는 this가 문제해결. this바인딩은 호출패턴에 따라 달라진다. + 바인딩 작업 때문에 코드가 장황해진다.

### 생명주기

- counstructor
- `componentWillMount`(v17 defrecated)
- render
- componentDidMount
- `componentwillReceiveProps(nextProps)`(v17 defrecated)
- shouldComponentUpdate(nextProps, nextState)
- `componentWillUpdate`(v17 defrecated)
- render
- componentDidUpdate(prevProps, prevState)
- componentWillUnmount

counstructor.
컴포넌트가 처음 만들어 질때 실행됩니다. 기본 state를 설정할 수 있습니다.

componentWillMount.
컴포넌트가 DOM위에 만들어지기 전에 실행 됩니다. 따라서 DOM을 처리할 수 없습니다. render가 호출되기 전이기 때문에 setState를 사용해도 render가 호출하지 않습니다. (v17 defrecated에서 삭제)

render.
화면 렌더링을 담당 합니다.

componentDidMount.
첫 렌더링 후 실행됩니다. 이 안에서 다른 js프레임웍 연동 및 setTimeout, setInterval 및 Ajax를 사용합니다.

componentwillReceiveProps(nextProps).
props를 받을 때 실행됩니다. props에 따라 state를 업데이트 할 때 사용하면 유용합니다. 이 안에서 setState할 수 있지만 추가적인 렌더링은 발생하지 않습니다. 컴포넌트가 처음 마운트 되는 시점에서는 호출되지 않습니다. (v17 defrecated - getDerivedStateFromProps로 대체됨)

shouldComponentUpdate(nextProps, nextState).
props/state가 변경되었을때 리 렌더링을 할지 말지를 결정합니다. 실제로 사용할때는 필요한 비교를 하고 값을 반환해야 합니다. 쓸데없는 렌더링을 걸러낼 수 있습니다.

shouldComponentUpdate 메쏘드를 별도로 선언하지 않았다면, 컴포넌트는 props, state 값이 변경되면 항상 리렌더링(re-render) 하도록 되어 있다.

순수컴포넌트(PureComponent): shouldComponentUpdat함수는 상태(state, props)가 변경될 때, 얕은 비교를 통하여 리렌더링의 유무를 결정합니다. 상태변화에 대한 비교없이 무조건 불필요한 리렌더링을 수행하는 일반 컴포넌트보다는 필요한 경우에만 렌더링을 수행하므로써, 성능을 개선할 수 있는 이점이 있습니다.

ex) return nextProps.id !== this.props.id (이때 JSON.stringify를 사용하여 여러 field를 편하게 비교 할 수 있습니다.)

componentWillUpdate(prevProps, prevState).
컴포넌트 업데이트 직전 실행됩니다. setState는 절대로 사용하면 안됩니다. 무한 루프에 빠질수 있습니다. (v17 defrecated - getSnapshotBeforeUpdate로 대체됨)

componentDidUpdate(prevProps, prevState).
컴포넌트 업데이트 직후 실행됩니다. setState는 절대로 사용하면 안됩니다. 무한 루프에 빠질수 있습니다.

componentWillUnmount.
컴포넌트가 DOM에서 사라진 후 실행됩니다. 컴포넌트 내부에서 타이머나 비동기 API를 사용하고 있을 때, 이를 제거하기에 유용합니다.

### 특징

- 단방향 데이터 플로우이다. 스테이트 관리 패턴. 스테이트가 꼬이지 않고 명료하게 나타난다.
- 단순 뷰레이어가 아닌 새 패턴의 한 부분이다.
- 상태가변하면 화면이 업데이트(변경)된다.
- React는 프레임워크가 아닌 라이브러리기 때문에 다른 프레임워크와 혼용 가능
- 재사용 가능한 UI 컴포넌트. 레고블럭 조립
- 모듈의 단위가 컴포넌트 인다. 컴포넌트 단위로 코드를 재사용 할 수 있다.
- 직관적인 html jsx 마크업개발자와 협업
- 컴포넌트당 클래스를 사용하므로 css캡슐화
- 화면 갱신 상태에 의존 셀렉터 필요 없음
- 목적에 맞는 컴포넌트(레이아웃으로 컨테이너/화면구성 프레젠테이셔널)구성을 통해 관리가 용이해지고 코드 공유 및 코드 재사용 가능
- Component 의 가독성이 매우 높고 간단하여 쉬운 유지보수, 간편한 UI 수정 및 재사용 용이
- React는 JavaScript 객체 형태의 Virtual DOM 을 사용하여 어플리케이션의 성능을 향상시킴 (JavaScript Virtual DOM 처리가 실제 DOM 보다 빠르기 때문)

### 단점

- 라이프사이클 잘 이해하고 사용해야 함. 꼬일 수 있음.
- 스테이트 관리 잘 해야함. 스테이트 관리를 잘 해야한다. 상황에 맞게 써야지 무턱대로 사용하면 불피요한 상태를 계속 관리하게 되어 더 복잡하다.
- VIEW ONLY , VIEW 이외의 기능은 써드파티 라이브러리(Third party library, =패키지, 모듈로 불리기도함)를 이용하거나 직접 구현해야함
- IE8 이하 지원하지 않음 (IE8 이하 버전을 지원해야 할 경우 v0.14 버전을 사용 해야함)
- React는 inline-template 과 JSX 를 사용하는데, 일부 개발자들에게는 적응이 안 될 수 있음

### React - Redux

Redux는 React에서 컴포넌트간의 State전달 및 관리를 편리하게 해 주는 라이브러리. Redux는 Flux라는 아키텍처를 조금 손봐서 React에서 사용하기 적합하게 만들었습니다.

React까지 필요하지 않는 기능에도 State를 맡기면 더러워지거나 오버 엔지니어링을 했던 시행착오. 규모나 상황에 따라 Redux는 선택적으로 사용하는 것이 맞다. 어떤 컴포넌트에 어떤 State를 공유 할 것인지에 대해 고민해야 합니다.

어떤 곳에서는 오히려 React의 깔끔한 구조를 깨뜨리기도 하는데 굳이 필요하지 않다면 전체적인 프로젝트의 복잡성을 낮추는데 도움이 됩니다.

### 미들웨어 thunk의 단점

미들웨어는, 액션이 디스패치(dispatch) 되어서 리듀서에서 이를 처리하기전에 사전에 지정된 작업들을 설정합니다. 미들웨어를 액션과 리듀서 사이의 중간자라고 이해할 수 있습니다.

리듀서가 액션을 처리하기전에 필요한 작업들을 미들웨어를 통해 할 수 있습니다. 만약에 특정 액션이 몇초뒤에 실행되게 하거나, 현재 상태에 따라 아예 액션이 무시되게 하고 다른 종류의 액션들을 추가적으로 디스패치 할 수도 있습니다.

redux-thunk 를 통해 만든 액션생성자는 그 내부에서 여러가지 작업을 할 수 있습니다. 이 곳에서 네트워크 요청을 해도 무방하죠. 또한, 이 안에서 액션을 여러번 디스패치 할 수도 있습니다. 그러나 단점으로는 액션쪽에 비동기통신 코드가 번잡하게 들어감에 따라 파악하기 힘듭니다. 만들면서 맘에 들지 않았던 부분은 action이 dispatch만 하는것이 아니라 로직을 담고 작업을 수행한다는 단점이 있습니다.

action의 역할 이상으로 다른 영역까지 책임을 지고 있기 때문에 뭔가 찝찝합니다.

### 기존 화면 개발의 어려움

- 데이터 업데이트에 대한 화면 변경 성능 문제
- 중복되는 페이지 유지보수 어려움
- 특히 es6 문법을 함께 사용하면서 클래서, 프로미스, 모듈내보내기 불러오기, 템플릿 리터럴등 문법이 간결하고 쉬워짐

### SPA 장점과 단점

장점.

- 사용자 친화적 (빠른 반응성, 화면전환 에니메이션 등): client rendering, router
- 상대적으로 적은 전체 트래픽 양 (Ajax, 캐쉬)
- 필요한 부분만 새로 그리고 필요한 데이터만 새로 받는다.
- 상대적으로 유지보수가 쉽고 개발속도가 빠르다. (모듈화, 컴포넌트화)
- 프론트앤드와 백앤드의 분리로 인한 개발업무 분업화 및 협업이 쉽다.

단점.

- 초기구동속도 => Lazy Loading으로 해결, 브라우저 캐쉬
  SPA는 HTML, CSS, Javascript를 어플리케이션 라이프사이클에서 한번만 로드합니다. 서버와 데이터만 주고 받습니다.
- 검색엔진 최적화(SEO) => SSR로 해결
  SPA는 콘텐츠를 렌더링하기 위해 JavaScript에 의존하지만 모든 검색 엔진이 크롤링 중에 JavaScript를 실행하지는 않으며 페이지에 빈 콘텐츠가 표시될 수 있습니다. 이로 인해 의도치 않게 앱의 검색 엔진 최적화(SEO)가 어려워집니다. 그러나 대부분의 경우 앱을 제작할 때 검색 엔진에서 모든 콘텐츠 색인할 필요는 없으므로 SEO가 가장 중요한 요소는 아닙니다. 이를 극복하기 위해, 앱을 서버 측 렌더링하거나 Prerender와 같은 서비스를 사용하여 "브라우저에서 JavaScript를 렌더링하고, 정적 HTML을 저장한 다음, 크롤러에게 반환합니다".
- 하얀 화면(개발자 버그) : Error Boundaries
- 자바스크립트의 메모리 부족은 어플리케이션 속도를 저하시킬 수 있습니다.

### SPA 성능 문제 개선

lazy loading으로 초기 로딩 속도 개선.

- Webpack과 같은 모듈 번들러(Module Bundler)를 사용하여 여러 파일을 하나의 파일로 통합하여 용량이 커지면, 인터넷이 느린 환경에서는 페이지 로딩속도도 느려질 것
- 지금 당장 필요한 코드가 아니라면 따로 분리시켜서, 나중에 필요할때 불러와서 사용하도록 코드스플릿 사용.
- 초기 페이지에서 모든 리소스를 다운받지 않고, 리소스를 청크(Chunk) 단위로 묶어서 해당 리소스에 대한 요청이 있을 때만 다운로드 받도록 하는 방법 lazy loading

### 컴포넌트

- Portal 컴포넌트는 논리적으로 하위 컴포넌트지만 시각적으로는 상위 컴포넌트여야 할 때 사용한다.
- React에서는 합성, Composition을 통해 컴포넌트를 재사용할 수 있다.
- Composition을 지원하는 컴포넌트의 경우 PureComponent를 사용하면 성능이 나쁠 수 있다.
- Composition을 지원하는 컴포넌트를 최적화 하고 싶으면 특수화를 적용한다.

* 컴포넌트 제대로 만들기: https://hyunseob.github.io/2019/06/02/react-component-the-right-way/

### 컴포넌트 구조

하나의 컴포넌트 파일에서 구조.

- 외부 라이브러리 및 모듈 import
- component function 선언
- useSelector나 useState를 통하여 state 초기화 및 store값 가져오기
- useEffect를 통한 component의 lifecycle 구현
- return을 통한 JSX 구현
- 컴포넌트의 propTypes, defaultProps 작성
- 컴포넌트 export

HOC.
HOC는 하나의 부품처럼 특정 컴포넌트에 기능 하나를 추가해주는 역할을 한다.

action에 맞추어 status를 관리하고 response를 저장한다.

component 에서 action의 상태에 따른 후 처리를 대응하기 위함.

1. component에서 어떠한 액션과 관련있는지 알고 싶다.
2. 액션의 상태 및 결과(success, response)에 대해서 후처리를 component에서 하고 싶다.

---

## oAuth 로그인

Oauth는 외부서비스의 인증 및 권한부여를 관리하는 범용적인 프로토콜입니다. OAuth는 인증뿐만 아니라 권한도 관리합니다. 사용자의 권한에 따라 접근할 수 있는 데이터가 다르도록 설정이 가능합니다.

그외 인증 방법

- 세션/쿠키, JWT를 이용한 인증
- Access Token + Refresh Token을 이용한 인증
- SNS 로그인은 간단하게 봤을 때 OAuth2.0 + 서버 인증(세션/쿠키 , 토큰기반 인증)으로 구성

(사용자 <-> 어플리케이션 서버) 인증 절차였던 세션/쿠키, 토큰 기반 인증 방식을 완전히 대체하는게 아니라는 점입니다. 즉 SNS 로그인 기능을 넣더라도 결국은 세션/쿠키 방식이나 토큰을 활용해 인증을 거쳐야 합니다.

### Authorization Code Grant 방식을 예

- Resource Owner: User, 즉 일반 사용자를 칭합니다.
- Client: 우리가 관리하는 어플리케이션 서버(User와 혼동될 수 있는데 아닙니다!)
- Authorization Server: 권한을 관리하는 서버입니다. Access Token, Refresh Token을 발급, 재발급 해주는 역할을 합니다.
- Resource Server: OAuth2.0을 관리하는 서버(Google, Facebook, Naver 등) 의 자원을 관리하는 서버입니다. 주의할 점은 우리가 만드는 서버의 자원을 관리하는 곳이 아닙니다. Oauth 2.0 관리 서버의 자체 API를 의미합니다.

---

## CSS display 속성

- block: 아래 위로 블럭처럼 쌓는다.
- inline: 옆으로만 쌓는다.
- none: 나타내지 않는다. 요소박스를 생성하지 않는다.

## CSS visibility 속성

- visible: 보인다. 볼 수 있다.
- hidden: 보이지 않는다. 볼 수 없다. 요소박스는 생성되었다.
- collapse: table의 행과 열을 숨긴다.

## CSS position

- staic: 위치를 지정하지 않는다. offset은 무시된다.
- relative: 원래 위치로부터 offset으로 위치를 계산한다.
- absolute: 원래 위치 static이 아닌 가장 가까운 조상의 위치를 기준으로 하여offset으로 위치를 계산한다.
- fixed: 원래 위치와 상관없이 위치를 지정한다. 상위요소에 영향을 받지 않는다. 고정된 위치를 설정하며 브라우저의 상대위치가 기준이 된다.

## TDD와 BDD

- TDD는 테스트 자체에 집중하여 검증
- BDD는 비즈니스 요구사항에 집중하여 테스트 케이스를 검증

---

## 비동기통신과 동기통신의 차이점

동기식 통신은 통신에 참여하는 노드 모두가 시간을 동기화해서 전송하는 걸 말함(예를들면, 면접진행시 15분씩 1명씩 진행하는걸 생각하면됨)

비동기식은 시간을 안맞추는 대신 전송전에 연결을 맺는 등의 오버헤드를 가짐.(예를들면, 내가 말하기전에 너 들을준비 되었니? 통보하고 말하는거임)

---
layout: post
title: 기술 면접 질문
categories: Resume
---

## 링크드 리스트와 배열 차이
?

## 코드 리뷰 경험
///

## js 기술면접

https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Korean/questions/javascript-questions.md

## 최신 브라우저의 내부 살펴보기

https://d2.naver.com/helloworld/5237120


자바스크립트 코드가 많아지면 하나의 파일로 관리하는데 한계가 있다. 그렇다고 여러개 파일을 브라우져에서 로딩하는 것은 그만큼 네트웍 비용을 치뤄야하는 단점이 있다. 뿐만 아니라 각 파일은 서로의 스코프를 침범하지 않아야 하는데 잘못 작성할 경우 변수 충돌의 위험성도 있다. 웹팩은 모듈 번들러로, 모듈 번들러란 여러개의 나누어져 있는 파일들을 하나의 파일로 만들어주는 라이브러리를 말한다.

의존성 그래프에서 엔트리로 그래프의 시작점을 설정하면 웹팩은 모든 자원을 모듈로 로딩한 후 아웃풋으로 묶어준다. 로더로 각 모듈별로 바벨, 사스변환 등의 처리하고 이 결과를 플러그인이 받아 난독화, 텍스트 추출 등의 추가 작업을 한다.

웹팩은 모든 파일을 모듈로 관리한다고 했다. 자바스크립트 파일 뿐만 아니라 이미지, 폰트, 스타일시트도 전부 모듈로 관리한다. 그러나 웹팩은 자바스크립트 밖에 모른다. 비 자바스크립트 파일을 웹팩이 이해하게끔 변경해야하는데 로더가 그런 역할을 한다.

## 이벤트 캡쳐링 버블링
표준 DOM이벤트에서 정의한 이벤트 흐름엔 3가지 단계가 있다.
1. 캡쳐링: 이벤트가 하위요소로 전파되는 단계
2. 타겟: 이벤트가 실제 타겟 요소에 전달되는 단계
3. 버블링: 이벤트가 상위요소로 전파되는 단계, 이벤트가 발생하는 가장 안쪽부터 바깥쪽, 하위노드에서 상위노드로 이벤트가 전파되는 과정

이벤트는 최상위요소 window부터 시작해 아래로 전파되고(캡쳐링) 이벤트가 타겟 요소에 도착해 실행된 후(타겟단계) 다시 위로 전파된다.(버블링) 이런 과정을 통해 요소에 할당된 이벤트 핸들러가 호출된다.

예를 들면 테이블, 리스트...

[이벤트위임]

이벤트 위임은 이벤트 리스너를 하위 요소에 추가하는 대신 상위 요소에 추가하는 기법입니다. 리스너는 DOM의 event bubbling으로 인해 하위 요소에서 이벤트가 발생될 때마다 실행됩니다. 이 기술의 이점은 다음과 같습니다.

각 하위 항목에 이벤트 핸들러를 연결하지 않고, 상위 요소에 하나의 단일 핸들러만 필요하기 때문에 메모리 사용 공간이 줄어듭니다.
제거된 요소에서 핸들러를 해제하고 새 요소에 대해 이벤트를 바인딩할 필요가 없습니다.

하위요소에 각각 이벤트를 붙이지 않고 상위요소에서 하위요소의 이벤트들을 제어하는 방식. 이벤트가 하위요소로 전파되는 단계인 캡쳐링을 이용한다.

참고) 거의 모든 이벤트는 버블링 됩니다.
키워드는 ‘거의’ 입니다. focus 이벤트와 같이 버블링 되지 않는 이벤트도 있습니다. 버블링 되지 않는 이벤트의 종류에 대해선 조금 후에 알아보겠습니다. 몇몇 이벤트를 제외하곤 대부분의 이벤트는 버블링 됩니다.


[이벤트 api]

- event.preventDefault(): 현재 이벤트의 기본 동작을 중단한다.
- event.stopPropagation(): 현재 이벤트가 상위로 전파되지 않도록 중단한다.
- event.stopImmediatePropagation(): 현재 이벤트가 상위뿐 아니라 현재 레벨에 걸린 다른 이벤트도 동작하지 않도록 중단한다.


- event.stopPropagation():  위쪽으로 일어나는 버블링은 막아주지만, 다른 핸들러들이 동작하는 건 막지 못합니다.
- event.stopImmediatePropagation(): 한 요소의 특정 이벤트를 처리하는 핸들러가 여러개인 상황에서, 핸들러 중 하나가 버블링을 멈추더라도 나머지 핸들러는 여전히 동작합니다. 

버블링을 멈추고, 요소에 할당된 다른 핸들러의 동작도 막으려면 event.stopImmediatePropagation()을 사용해야 합니다. 이 메서드를 사용하면 요소에 할당된 특정 이벤트를 처리하는 핸들러 모두가 동작하지 않습니다.

## 크로스 브라우징이란?

크로스 브라우징은 W3C에서 채택된 표준 웹 기술을 적용해 모든 브라우저에 다른 기종의 OS나 HTML 렌더링 기술로, 비슷하게 만들어 어떤 환경에서도 이상없이 작동되게 하는 웹페이지를 제작하는 방법론이다. 정보로서의 소외감을 느끼지 않도록 해야 한다.

쉽게 말하자면 익스플로러에서 이용할 수 있던 사이트가 크롬이나 오페라에서는 보이지않아 이용할 수 없게 되는 것을 크로스브라우징을 이용하여 다양한 브라우저를 이용하더라도 사이트를 100% 이용할 수 있게 만드는 기술을 말한다.

웹표준 기술을 적용하여 서로 다른 OS 또는 플랫폼에서도 인터넷이 이상 없이 구현되는 기술로, 모든 브라우저가 동일한 정보를 보여주는 통일성이다.

즉, 인터넷 익스플로러(IE), 크롬, 사파리, 파이어 폭스, 오페라 등 여러 브라우저의 종류와 상관없이 홈페이지를 이용할 때 아무런 이상 없이 작동될 수 있도록 웹페이지를 제작하는 방법이며, 웹브라우저의 종류에 상관없이 웹사이트의 레이아웃 위치나 모양이 동일하게 보여지도록 하는 `상호 호환성`에 대한 기술을 말한다. 어느 한쪽에 최적화되어 치우지지 않도록 공통 요소를 사용하여 웹 페이지를 제작하는 기법을 말하는 것이다.


[대응]

- html5shiv: HTML5의 Element를 HTML5를 지원하지 않는 IE 9 이하 하위 버전 등에서 사용할 수 있도록 해 주는 Javascript 라이브러리이다.  
- Polyfill.io
- reset.css (or normalize.css)를 사용하자: CSS의 경우, browser의 기본 스타일이 제각각인 경우가 있다. 동일한 스타일을 적용하기 위해선 defalut 값을 초기화시킬 필요가 있다. 이것도 하나의 라이브러리로, 검색해보면 여러 개를 찾을 수 있다. 무작정 Copy & Paste 하지 말고, 어떤 의미에서 초기화를 시키는지 알고 사용하자.

- Prefix 를 적어주자: 아직 웹 표준이 안된 기능을 브라우저들이 가져다 지원하기 때문에 기능 앞에 각 브라우저들의 엔진을 prefix로 적어주는 것. 모든 브라우저에서 지원하는 호환 프로퍼티를 먼저 정의하고 CSS3에서 지원하는 프로퍼티를 나중에 정의하는 방법을 사용해야 한다. 이와 같은 이유로 접두어가 없는 속성은 가장 나중에 추가해줘야 한다!

```css
#menu {
     border-radius: 15px;
}
#menu {
     -webkit-border-radius: 15px;
     -moz-border-radius: 15px;
     border-radius: 15px;
}
```

## 반응형 웹
웹 디자인 기법 중 하나. 웹(Web)에 접속하는 디바이스에 반응하는(Responsive) 디자인(Design)을 말한다.

- 미디어 쿼리
- 유동형 그리드
- 반응형 레이아웃
- 뷰포트 설정

모바일 기기를 우선하여 기획(설계). 반응형 디자인에 접근하는 또 다른 방법은 웹 사이트의 모바일 버전을 먼저 디자인하는 것입니다. 이렇게 하면 작은 화면에서 이미지, 텍스트, 로고 및 기타 요소가 어떻게 보이는지 볼 수 있습니다. 문제없이 표시되면 큰 화면에서 또한 문제가 발생하지 않습니다.

작은 모바일 화면에서도 쉽게 클릭할 수 있게 만들어 주세요. 버튼, 링크 등 클릭 가능한 요소를 제작할 때 특히 주의해야 합니다. 모바일 기기의 화면 크기가 작다는 이유로 클릭 가능한 요소를 작게 만들면 사용자가 클릭하여 인터랙션 하기 어려워 집니다.

```html
<meta name="viewport" content="width=device-width" />
```

```css
/* 이곳에 모바일에 적용될 스타일을 먼저 작성합니다. */

@media screen and (min-width: 900px) {
   /* 최소 width가 900px일 때, 즉 width가 900px이상 화면(데스크탑)에서 사용될 스타일을 여기에 작성합니다. */
}
``` 

```css
/* 이곳에 데스크탑에서 사용될 스타일을 먼저 작성합니다. */

@media screen and (max-width: 500px) {
    /* 최대 width가 500px일 때, 즉 width가 500px이하 화면(모바일)에 사용될 스트일 시트를 여기에 작성합니다. */
}
```
 

## 실행컨텍스트(EC: Execution Context)

실행 컨텍스트는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 갖는다. 전역EC와 함수별EC를 가질수 있다. 3가지 프로퍼티를 가진다.

1. Variable Object (VO / 변수객체)
2. Scope Chain (SC)
3. this value

### 변수객체(VO: Variable Object)

VO는 아래의 정보를 담는 객체이다.

- 변수
- 매개변수(parameter)와 인수정보(arguments)
- 함수 선언(함수 표현식은 제외)

Variable Object는 실행 컨텍스트의 프로퍼티이기 때문에 값을 가지고 이 값은 다른 객체(전역GO/함수AO)를 가킨다. 전역컨텍스트, 함수컨텍스트의 경우, 가리키는 객체가 다르다. 이유는 각각의 내용이 다르기 때문이다. 예로 전역 코드에는 매개변수가 없지만 함수에는 매개변수가 있다.

- 전역객체 GO: 유일하며 최상위에 위치하고 모든 전역 변수, 전역 함수 등을 포함하는 전역 객체(Global Object / GO)를 가리킨다. 전역 객체는 전역에 선언된 전역 변수와 전역 함수를 프로퍼티로 소유한다.
- 활성객체 AO: 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체인 arguments object가 추가

### 스코프 체인(SC: Scope Chain)

스코프 체인(Scope Chain)은 일종의 리스트로서 전역 객체와 중첩된 함수 스코프의 레퍼런스를 차례로 저장하고 있다. 다시 말해, 스코프 체인은 해당 전역 또는 함수가 참조할 수 있는 변수, 함수 선언 등의 정보를 담고 있는 전역 객체(GO) 또는 활성 객체(AO)의 리스트를 가리킨다.

- 스코프 체인은 식별자 중에서 객체(전역 객체 제외)의 프로퍼티가 아닌 식별자, 즉 변수를 검색하는 메커니즘이다. 식별자 중에서 변수가 아닌 객체의 프로퍼티(물론 메소드도 포함된다)를 검색하는 메커니즘은 프로토타입 체인(Prototype Chain)이다.

### this value

this 프로퍼티에는 this 값이 할당된다. this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.

- 메소드 호출 패턴
- 함수 호출 패턴
- 생성자 호출 패턴
- call / apply 호출 패턴

## 클로저

클로저는, `함수 자신이 포함하는 스코프의 변수들!을 추적하는 함수`입니다. 함수가 중첩되어 있으면 중첩될 때마다 부모 함수의 Scope가 자식 함수의 스코프 체인(스코프 프로퍼티)에 포함됩니다.

- 자바스크립트 함수는, 호출되었을 때 실행되기 위한 코드뿐만 아니라, 더 많은 정보를 포함하고 있기 때문에 만들어진 환경을 기억한다고 할 수 있습니다. (이때, 메모리 소모)
- 자바스크립트 함수는, 해당 스코프에 선언되어 어떤 변수더라도, 내부적으로 보관합니다.
- 따라서 스코프 내에 포함된 어떤 변수라도 참조할 수 있고
- 값을 복사하지 않고 참조하고 있기 때문에 외부변수의 값을 변경 할 수도 있습니다.
- 클로저를 통해 내부 변수를 참조하는 동안에는 해당 변수가 차지하는 메모리를 GC가 회수하지 않으므로 클로저 사용이 끝나면 참조를 제거하는 것이 좋습니다.
- 클로저는 함수내의 지역변수를 감추는 은폐의 역할을 가능하게 합니다.
- 복잡한 코드를 쉽고 간결한 코드를 작성할 수 있습니다. (객체반환x, 함수반환o)
- 자바스크립트에서 클로저가 많이 사용되는 부분은 이벤트 그리고 비동기식 호출의 경우라고 할 수 있습니다.

```js
function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + "px";
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById("size-12").onclick = size12;
document.getElementById("size-14").onclick = size14;
document.getElementById("size-16").onclick = size16;
```

- 클로저 스코프 메커니즘: 내부 함수의 [[Scopes]] 프로퍼티는 자신의 실행 환경(Lexical Enviroment)과 자신을 포함하는 외부 함수의 실행 환경과 전역 객체를 가리키는데 이때 자신을 포함하는 외부 함수의 실행 컨텍스트가 소멸하여도 [[Scopes]] 프로퍼티가 가리키는 외부 함수의 실행 환경(Activation object)은 소멸하지 않고 참조할 수 있다. 이것이 클로저이다.

* 스코프체인: 변수검색 메커니즘
* 프로토타입체인: 객체의 프로퍼티를 검색하는 메커니즘

## 웹 브라우저에 URL을 입력하면 어떤 일이 일어날까?

https://owlgwang.tistory.com/1

1. 주소표시줄에 URL을 입력하고 Enter를 입력한다.
2. 웹 브라우저가 URL을 해석한다.

```
scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]
```

만약, URL이 문법에 맞지 않는다면 입력을 웹 브라우저의 기본 검색엔진으로 검색을 요청한다.

3. URL이 문법에 맞으면 Punycode encoding을 url의 host부분에 적용한다.

4. HSTS (HTTP Strict Transport Security)목록을 로드해서 확인한다. HSTS는 Web Site에 접속할 때, 강제적으로 HTTPS Protocol로만 접속하게 하는 기능입니다. 즉 HTTPS Protocol을 지원하는 Web Site 에서, 자신은 HTTPS Protocol만 사용해서 통신할 수 있음을, 접속하고자 하는 Web Browser에게 알려 주는 기능입니다. 요약하면, 보안을 강화시킬 목적으로, Web Browser에게 HTTPS Protocol만 사용하도록 강제하는 기능입니다. HSTS 기능을 사용하려면, Web Server 및 Web Browser 둘 다 기능을 지원해야 합니다. HSTS 기능을 지원하는 Web Server 를 "HSTS enabled Server" 라고 부릅니다.

- Web Browser는 먼저 HTTP Protocol("http://" 사용)로 해당 도메인에 접속을 시도합니다.
- 해당 도메인이 HTTPS Protocol만을 지원하는 Web Site라면, "301 Redirect" 또는 "302 Redirect" response를 보내고,
- Web Browser로 하여금 HTTPS Protocol로 다시 접속하라고 지시합니다.

5. 브라우저 캐시 확인 및 DNS(Domain Name Server) 조회한다.

- DNS에 요청을 보내기 전에 먼저 Browser에 해당 Domain이 cache돼 있는지 확인한다. (Chrome의 경우 chrome://net-internals/#dns 에서 확인 가능)
- 없을 경우 로컬에 저장돼 있는 hosts파일에서 참조할 수 있는 Domain이 있는지 확인한다.
- 모두 실패 했을 경우 Network stack에 구성돼 있는 DNS로 요청을 보낸다. (DNS는 일반적으로 Local router, ISP의 캐싱 DNS)

6. ARP 주소결정프로토콜을 통하여 대상의 IP와 MAC address를 알아낸다.

[MAC 주소(Media Access Control Address)]
네트워크 상에서 서로를 구분하기 위하여 Device 마다 할당된 물리적인 주소를 말합니다. 네트워크 세그먼트의 데이터 링크 계층에서 통신을 위한 네트워크 인터페이스에 할당된 고유 식별자이며 네트워크 노드는 여러 개의 NIC를 가질 수 있으며, 각 NIC는 고유한 MAC 주소를 가집니다.

[IP]

리소스들에게 접근하기 위해서는 해당하는 리소스가 어디있는지 알아야한다. 클라이언트가 인터넷에 연결된 기기를 식별하기 위해 기기들이 가지고 있는 유일한 번호이다.

IPv4 & IPv6.

- IPv4: 8bit씩 4부분의 32bit, 10진수로 표현 (2011년 2월에 IP가 모두 소진)
- IPv6: 16bit씩 8부분의 128bit, 16진수표현

[네트워크주소와 호스트주소]

주소의 클래스별 구분과 서브넷마스크를 통해 두개의 주소를 구분한다.

- 네트워크주소: 네트워크와 또 다른 네트워크를 구분
- 호스트주소: 같은 네트워크 속에서 기기를 식별하는데 사용

참고) Prefix 표기란 서브넷 마스크 맨 앞의 비트부터 1의 개수를 표기하는 방식을 말한다. 즉 맨 앞에 비트부터 공통 비트 개수를 표기하는 방식이다. 예를 들어 서브넷 마스크가 255.255.255.0인 경우 맨 앞의 비트부터 1이 24개가 있으므로 /24로 표기한다. (네트워크주소: 255.255.255 / 호스트주소: 0~255 이며, 이때 prefix가 24인 이유는 8비트.8비트.8비트.8비트 에서 마지막만 호스트 주소이므로 나머지 8비트.8비트.8비트는 24비트이므로)

- 클래스 A: IP 1~126.xxx.xxx.xxx 국가이상의 큰 통신망에서 사용한다.
- 클래스 B: IP 128~191.0~255.xxx.xxx 학교등 중대규모 통신망에서 사용한다.
- 클래스 C: IP 192~223.0~255.0~255.xxx 소규모회사나 ISP업체의 통신망에서 사용한다.
- 클래스 D: IP 224~239.0~255.0~255.0~255 멀티캐스트시에만 특수 사용하는 클래스
- 클래스 E: IP 240~255.0~255.0~255.0~255 연구용, 테스트용으로 존재하는 클래스이고 사용되지 않는다.

7. 대상과 TCP 통신을 통해 Socket을 연다. (HTTP의 기본값은 80, HTTPS의 기본값은 443)

Http Request를 위해, TCP Socket을 개방하고, 연결한다. 이 과정에서 3Way Hand-Shaking이 일어난다. TCP 연결에 성공하면, Http Request가 TCP Socket을 통해 보내진다. 이에 대한 응답으로, 웹 페이지의 정보가 사용자의 PC로 들어온다.

[3Way Handshake]
TCP Socket 연결을 하여, 데이터를 전송하기 위해서 발생한다.

1. 클라이언트는 서버에게 통신을 시작한다는 것을 알린다. syn
2. 서버는 클라이언트에게 응답함과 동시에 클라이언트에게 통신을 시작함을 알린다. syn + ack
3. 클라이언트는 서버에게 응답한다. ack (연결 성립 establish)

[4 Way Handshake]
연결 종료.

1. 클라이언트는 서버에게 통신을 종료한다는 것을 알린다. fin
2. 서버는 클라이언트에게 응답하고 남은 처리가 끝날때까지 기다린다. ack
3. 서버는 클라이언트에게 통신을 종료한다는 것을 알린다. fin
4. 클라이언트는 서버에게 응답한다. ack

---

## TCP/IP의 개념

어디서 출발하는지, 어디로 향하는 지에대해 최적의 경로를 선택하는 것이 IP를 통해서 이루어진다면 그 전에 어떻게 데이터를 전송할 것인가에 대한 규약이 필요하다. 어떻게 패킷을 분할하고 조합할 것인가에 대한 규약중 가장 자주 사용되는 것이 TCP이다.

| OSI 계층 | TCP/IP 모델 | . |
| Application <br/> Presentation <br/> Setting | Application | http, ftp, nntp..|
| Transport(TCP) | Host-to-Host Transport | 어떻게 전송? |
| Network(IP) | Internet | |
| Data Link | Network Interface| |
| Physical | Hardware | |

네트워크에서 전달하는 데이터의 최소단위를 패킷이라고 하는데 이 패킷은 이쪽 네트워크에서 저쪽 네트워크로 날로 던지지 않는다. 패킷이 전달되기 위해서는 포장하는 과정을 거쳐야하는데 TCP는 패킷을 어떻게 포장할것인가에 대한 약속이다. 패킷은 일련의 순서로 포장되어 보내지고, 받을 때는 반대로 해석된다.

- TCP/IP는 네트워크를 상호연결시켜 정보를 전송 할 수있도록하는 기능을 가진 다수의 프로토콜이 모여있는 프로토콜 집합
- 인터넷은 데이터 링크 계층을 지원하는 네트워크를 TCP/IP 프로토콜을 이용하여 상호연결하는 네트워크
- 인터넷 상의 서로 다른 운영체제를 쓰는 컴퓨터간 데이터 전송을 가능하게 하는 정보전송을 위한 인터넷 표준 프로토콜

## 라우터 / 홉 / DNS

[라우터]
네트워크는 라우터(게이트웨이)라는 장치를 통해서 형성되고 라우터는 목적에 맞는 데이터의 이동경로를 적당히 결정해 준다. 다른 네트워크연결을 라우팅이라고 한다.

[홉(hop)]
인터넷(또는 목적지)에 도달할 때까지 거치는 게이트웨이 개수이다. 일반적으로 네트워크에서 홉 수가 많으면(즉 게이트웨이 수가 많으면) 네트워크 부하가 발생해 전송 속도가 저하될 수 있다.

[DNS]
IP는 12개의 숫자로 이루어져 있다. 하지만 사용자들은 의미도 없는 12개의 숫자를 항상 외우고 다니지 않는다. 따라서 특정 단어(google, facebook)와 실제 IP 주소를 매핑시켜주는 시스템이 필요하고 그것이 DNS이다.

- 순서(역트리): 루트네임서버 -> 최상위도메인(국가명) -> 2단계네임서버

* Root네임 서버: 1단계 네임 서버만 관리
* 1단계 네임 서버: com, net, org 등은 2단계 네임 서버만 관리
* 2단계 네임서버: redhat, naver, samsung 등은 www서버, ftp, mail서버등을 관리

DNS가 동작하는 과정은 다음과 같다.

1. 일단 로컬에 있는 DNS서버에 캐싱해둔걸 먼저 살핀다.
2. 없다면 최상위 도메인에서부터 차례로 트리를 탐색한다.
3. 일치하는 도메인을 찾았다면 IP주소를 반환한다. (Recursive Query)

로컬네임서버.
/etc/resolv.conf에 저장된 네임 서버를 로컬 네임 서버라고 한다. 자신의 캐시 DB를 가진다.

[로컬 네임서버가 작동하는 순서]
응답은 전달받는것이 아닌 조회가능한 서버의 정보를 얻어 로컬네임서버가 직접 질의한다.

1. PI의 웹 브라우저 주소창에 www.nate.com을 입력한다.
2. PC가 리눅스일 경우 hosts파일을 뒤지고 없으면 /etc/resolv.conf 파일을 열어서 'nameserver 네임서버IP'부분을 찾아 로컬 네임 서버 컴퓨터를 알아낸다.
3. 로컬 네임 서버에 www.nate.com의 IP주소를 물어본다.
4. 로컬 네임 서버는 자신의 캐시 DB를 검색해 www.nate.com의 정보가 들어있는지 확인한다.
5. 로컬 네임서버가 'ROOT'서버에게 www.nate.com의 주소를 물어본다.
6. ROOT네임서버도 www.nate.com의 주소를 모르므로, 'com 네임 서버'의 주소를 알려주면서 'com 네임 서버'에게 물어보라고 한다.
7. 로컬 네임서버가 'com 네임 서버'에 www.nate.com의 주소를 물어본다.
8. 'com 네임 서버'도 www.nate.com 의 주소를 모르므로, 'nate.com'을 관리하는 네임서버의 주소를 알려주면서 'nate.com'네임 서버에게 물어보라 한다.
9. 로컬 네임서버가 'nate.com' 네임서버에 'www.nate.com'의 주소를 물어본다.
10. 'nate.com'네임서버는 네이트에서 구축한 네임 서버이므로 ㅇㅇㅇ.nate.com이라는 이름을 가진 컴퓨터의 목록은 모두 있다. www.nate.com의 IP 주소도 알기 때문에 IP주소를 알려준다.
11. 로컬 네임 서버는 www.nate.com의 IP주소를 요구한 PI에 IP주소를 알려 준다.
12. PC는 획득한 IP 주소로 접속을 시도한다.

- HTTPS인 경우 TLS(Transport Layer Security) handshake가 추가된다.
- TLS는 SSL(Secure Sockets Layer)이 표준화 되면서 바뀐 이름이다. HTTPS로 통신을 하게 되면 TCP socket 통신과정 전에 추가 된다.

* 참고) HTTP 연결 이 후에 서버는 연결을 close 할 수도 있고, 클라이언트가 보낸 헤더가 요청한 경우 추가 요청을 위해 연결을 유지 할 수도 있다.

* 304 Not Modified 응답에선 서버는 Payload가 없고 웹 브라우저는 캐시에서 HTML을 검색한다. HTML을 파싱한 후 웹 브라우저와 서버는 GET / HTTP/1.1 요청이 아닌 HTML페이지에서 참조하는 모든 자원(Image, CSS, favicon.ico 등)에 대해 이 프로세스를 반복한다. 만약 HTML이 다른 Domain의 resource를 참조하는 경우 웹 브라우저는 다른 도메인을 확인하는 단계로 돌아가고 해당 도메인에 대해 모든 단계를 수행한다. Host 요청의 header는 해당 서버의 이름으로 설정된다.

---

8. HTTPS인 경우 TLS(Transport Layer Security) handshake가 추가된다.
9. HTTP 프로토콜로 요청한다.
10. HTTP 서버가 응답한다.
11. 웹 브라우저가 그린다. 서버가 리소스(HTML, CSS, JS, Image 등)를 브라우저에 제공하면 브라우저는 Rendering Engine을 통해 아래 프로세스를 수행한다.

- 구문 분석 - HTML, CSS, JS
- 렌더링 - DOM Tree 구성 -> 렌더 트리 구성 -> 렌더트리 레이아웃 배치 -> 렌더트리 그리기

## HTTP와 HTTPS

https://javaplant.tistory.com/18

[HTTP(HyperText Transfer Protocol) 프로토콜]
웹상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고 받을 수 있는 프로토콜. 텍스트 교환이다. 문제는? 특정 서버에 요청을 주고 받을 때 수 많은 라우터와 스위치를 거치게 되는데, 그 중간에서 누군가가 우리의 패킷을 훔쳐 (Sniffing) 볼 수 있다. 패킷을 훔쳐 본다는 것은 결국 우리가 입력한 데이터, 예컨대 비밀번호와 같이 민감한 정보를 제 3자가 열람할 수 있다는 뜻이기 때문에 이를 미연에 방지하기 위한 많은 방법들이 연구되어 왔다. 네트워크 데이터가 암호화된다면, 중간에 공격자가 패킷을 열람하더라도 데이터가 유출되는 것을 막을 수 있다.

- 동작순서: TCP -> HTTP

[SSL/TLS 암호화] 오늘날 가장 널리 쓰이고 있는 암호화 방식이 SSL/TLS1 라는 것인데, 이 방식은 '인증서' 라고 하는 일종의 서명을 사용한다.

[HTTPS(Hypertext Transfer Protocol over Secure Socket Layer) 프로토콜]
HTTPS는 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer)프로토콜을 이용하여 웹브라우저(클라이언트)와 서버가 데이터를 주고 받는 통신 규약. 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전으로 HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다. 따라서 데이터의 적절한 보호를 보장한다. HTTPS의 기본 TCP/IP포트는 443이다. 모든사이트가 HTTPS를 안쓰는 이유는? 암호화에 따른 속도저하때문.

- 동작순서: TCP -> SSL -> HTTP

SSL 프로토콜은 암호화 중심 프로토콜로 정착시킨 기술로 정보 암호화시 공개키 암호화 방식을 사용하여, 공개키(Pubilc Key)와 개인키(Private Key) 두가지 키를 이용하는 암호화 방법을 사용한다. https 란 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer) 프로토콜을 이용하여 데이터를 전송하고 있다는 것을 의미.

공개키암호화 방식을 통해 데이터를 암호화하므로 HTTPS를 지원하는 서버에 요청(Request)을 하려면 공개키가 필요하다는 것을 알 수 있다. 그 공개키는 공개키 저장소(CA:Certificate Authority)에 있다. SSL프로토콜의 사용 목적은 두가지! 데이터암호화와 신원확인 용도로 사용된다.

참고) CA? 웹서버의 신뢰성을 보증해주는 기관을 CA(Certificate Authority) 혹은 Root Certificate라고 말한다. 신뢰성이 중요하기에 공인된 기업들만 참여할 수 있다.

[사용법]

1. 데이터 암호화: 공개키를 제공 받은 타인은 받은 공개키로 암호화하고, 비공개키를 가지고 있는 사람에게 전송한다. 이때 공개키가 유출되도 비공개키를 모르기에 복호가 불가능.

2. 데이터 주고 받을 때 서로 신원확인용(데이터 보호목적아님, 전자서명): 보내고자 하는 데이터를 소유자는 비공개키로 암호화하고, 전송시 공개키를 같이 보낸다. 데이터와 공개키를 받은 사람은, 공개키로 암호화된 데이터를 복호화한다. 이때, 암호화된 데이터를 공개키로 복호화할 수 있다는 것은 공개키와 쌍을 이루는 비공개키에 의해 암호화되었다는 뜻이다. 즉 공개키가 데이터를 제공한 사람의 신원을 보장해주게 된다.

한편 비대칭키는 키분배를 해결했지만 속도가 느리다. 매 통신시 상대에게 공유키를 요청하기 때문이다.
따라서 SSL에서 이 두가지방식(대칭, 공개키)을 모두 이용한다. 왜냐면 대칭키는 보안에 취약하지만 속도가 빠르고, 공개키는 보안은 강화됐지만 속도가 느리기때문!

[CA를 통해 공개키를 획득과정]

1. 기업이 HTTPS를 적용하기 위해서 공개키와 개인키를 만든다.
2. CA 기업을 선택 후 기업에 내 공개키를 관리해달라고 요청한다.
3. 이때 CA 기업만의 공개키와 개인키가 있다.
4. CA 기업은 CA기업의 이름과 A서버의 공개키, 공개키의 암호화 방법 등의 정보를 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.
5. 이제 클라이언트 입장에서, 예를 들어 A서버로 index.html 파일을 달라고 요청한다면 HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게된다.
6. 여기서 중요합니다. 세계적으로 신뢰할 수 있는 CA 기업의 공개키는 브라우저가 이미 알고 있습니다!
7. 브라우저가 CA 기업 리스트를 쭉 탐색하면서 인증서에 적혀있는 CA기업 이름이 같으면 해당 CA기업의 공개키를 이미 알고 있는 브라우저는 해독해서 A서버의 공개키를 얻는다.
8. 그러면 A서버와 통신할 때는 A서버의 공개키로 암호화해서 Request(요청)를 날린다.

## DOCTYPE선언

DOCTYPE선언은 어떤 버전의 HTML문서로 작성했는지 브라우저에게 알려주는 것으로 웹브라우저가 내용을 올바르게 출력하도록 도와줍니다. DOCTYPE 선언은 HTML 태그는 아니지만, 선언된 페이지의 HTML 버전이 무엇인지를 웹 브라우저에 알려주는 역할을 하는 선언문으로, 대소문자를 구분하지 않습니다. DOCTYPE선언을 하면 표준 모드로 작동되고 선언하지 않으면 호환모드로 작동해 의도와 다르게 표시될 수 있습니다.

HTML 4.01에서 DOCTYPE 선언은 SGML을 기반으로 하기 때문에 문서형정의(DTD:Document Type Definition)를 참조해야 합니다. DTD는 브라우저가 콘텐츠를 정확하게 표현하도록 마크업 언어에 대한 규칙을 명시합니다.

참고) SGML(Standard Generalized Markup Language)? 문서용 마크업 언어를 정의하기 위한 메타 언어이다.

```html
// html5이전
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

// html5
<!DOCTYPE html>
```

## 브라우저가 문서(HTML)를 해석하면서 하는일

브라우저는 기본적으로 다음과 같은 작업을 수행합니다.

- 불러오기(Loading): 불러오기는 HTTP 모듈 또는 파일시스템으로 전달 받은 리소스 스트림(resource stream)을 읽는 과정으로 로더(Loader)가 이 역할을 맡고 있음. 로더는 단순히 읽는 것이 아니라, 이미 데이터를 읽었는지도 확인하고, 팝업창을 열지 말지, 또는 파일을 다운로드 받을 지를 결정한다.
- 파싱(Parsing): 파싱은 DOM(Document Object Model) 트리를 만드는 과정으로 일반적으로 HTML, XML 파서를 각각 가지고 있음. HTML 파서는 말 그대로 HTML 문서를 해석하는데 사용되고, XML 파서는 XML 형식을 따르는 SVG, MathML 등을 처리하는데 사용함.
- 렌더링 트리(Rendering Tree / Reflow) 만들기: 파싱으로 생성된 DOM 트리는 HTML/XML 문서의 내용을 트리 형태로 자료 구조화 한 것을 말한다. 다시 말해, DOM 트리는 내용 자체를 저장하고 있고, `화면에 표시하기 위한 위치와 크기 정보, 그리는 순서 등을 저장하기 위한 별도의 트리 구조`가 필요한데 이를 일반적으로 렌더링 트리라고 부른다. 렌더링 트리는 표시되는 각 요소의 레이아웃을 계산하는 데 사용되고 픽셀을 화면에 렌더링하는 페인트 프로세스에 대한 입력으로 처리됩니다.
- CSS 스타일 결정: CSS 는 HTML 문서 내용과 별도로 표현을 나타내기 위해 만들어 졌음
- 레이아웃(Layout): 렌더링 트리가 생성될 때, 각 렌더(Render) 객체가 위치와 크기를 갖게 되는 과정을 레이아웃이라고 한다. (z-index)
- 그리기(Painting / RePainting): 그리기 단계는 렌더링 트리를 탐색하면서 특정 메모리 공간에 RGB 값을 채우는 과정이다. 렌더링 트리를 화면의 픽셀로 변환합니다.

`reflow`와 `repaint`는 수정된 렌더 트리를 다시 렌더링하는 과정에서 발생하는 것으로 웹 애플리케이션의 성능을 떨어뜨리는 주된 요인이다. 극단적인 경우, CSS 효과로 인해 Javascript 의 실행 속도가 느려질 수도 있다.

[Reflow 발생 요소]

리플로우는 모든 엘리먼트의 `위치와 길이, 크기 등을 다시 계산`하는 것으로 문서의 일부 혹은 전체를 다시 렌더링한다. 단일 엘리먼트 하나를 변경해도, 하위 엘리먼트나 상위 엘리먼트 등에 영향을 미칠 수 있다.

- 노드의 추가 또는 제거
- 요소의 위치 변경
- 요소의 크기 변경(인크리멘탈/글로벌 레이아웃)

[Repaint 발생 요소]

리페인트는 레이아웃에는 영향을 주지 않지만, `가시성에는 영향`을 주는 엘리먼트가 변경되면 발생한다.

- opacity
- background-color
- visibility
- outline

[정리]

- DOM 및 CSSOM 트리는 결합되어 렌더링 트리를 형성합니다.
- 렌더링 트리에는 페이지를 렌더링하는 데 필요한 노드만 포함됩니다.
- 레이아웃은 각 객체의 정확한 위치 및 크기를 계산합니다.
- 마지막 단계는 최종 렌더링 트리에서 수행되는 페인트이며, 픽셀을 화면에 렌더링합니다.

[성능 저하 최소화하기]

1. 클래스 변경을 통해 스타일을 변경할 경우, 최대한 말단의 노드의 클래스를 변경한다. 최대한 말단에 있는 노드를 변경함으로써, 리플로우의 영향을 최소화한다.

2. 인라인 스타일을 사용하지 않는다. 스타일 속성을 통해 스타일을 설정하면, 리플로우가 발생한다. 엘리먼트의 클래스가 변경될 때 엘리먼트는 하나의 리플로우만 발생시킨다. 인라인 스타일은 HTML 이 다운로드될 때, 레이아웃에 영향을 미치면서 추가 리플로우를 발생시킨다. 코드 가독성이점 추가.

3. 애니메이션이 들어간 엘리먼트는 가급적 position: fixed 또는 position: absolute로 지정하기(영향을 주는 노드 줄이기). Javascript + Css를 조합하여 애니메이션이 많거나 레이아웃 변화가 많은 요소의 경우 position을 absolute 또는 fixed를 사용하여 영향을 받는 주변 노드들을 줄일 수 있다. fixed와 같이 영향을 받는 노드가 전혀 없는 경우 reflow과정이 전혀 필요가 없어지기 때문에 Repaint 연산비용만 들게 된다. absolute 또는 fixed 위치인 엘리먼트는 다른 엘리먼트의 레이아웃에 영향을 미치지 않는다. (리플로우가 아닌 리페인트가 발생하는데, 이것은 훨씬 적은 비용이 든다.) 다른 요소에는 영향을 끼치지 않으므로 페이지 전체가 아닌 해당 요소만 reflow가 발생한다.

4. 부드러운 애니메이션이 성능을 저하시킨다. 한 번에 1px 씩 엘리먼트를 이동하면 부드러워 보이지만, 성능이 떨어지는 디바이스는 말썽일 수 있다. 엘리먼트를 한 프레임당 4px 씩 이동하면 덜 부드럽게 보이겠지만, 리플로우 처리의 1/4만 필요하다.

5. 레이아웃을 위한 <table> 은 피한다. <table> 은 점진적으로 렌더링되지 않고, 모두 불려지고 계산된 다음에서야 렌더링이 된다. 또한, 작은 변경만으로도 테이블의 다른 모든 노드에 대한 리플로우가 발생한다. 레이아웃 용도가 아닌 데이터 표시 용도의 <table> 을 사용하더라고, table-layout: fixed 속성을 주는 것이 좋다. table-layout: fixed 를 사용하면, 열 너비가 머리글 행 내용을 기반으로 고정되어 계산되기 때문이다.

6. CSS 에서 JavaScript 표현식을 사용하지 않는다. IE 와 FF 는 모두 CSS 에서 Javascript 를 실행할 수 있다. IE 에서는 표현 기법과 HTC 동작 방법이 있고, FF 에서는 XBL 을 사용하는 방법이 있다. (이 방법은 CSS 에서 Javascript 를 직접 실행하지는 않지만, 그 효과는 동일하다.) 문서가 리플로우될 때마다 JavaScript 표현식이 다시 계산된다.

7. CSS 하위 셀렉터를 최소화한다. 사용하는 규칙이 적을수록 리플로우가 빠르다.

8. gulp-uncss, grunt-uncss 와 같은 도구로 스타일 정의 및 파일 크기를 줄인다.

9. 숨겨진 엘리먼트를 변경한다. display: none; 으로 숨겨진 엘리먼트는 변경될 때, 리페인트나 리플로우를 일으키지 않는다. 그렇기 때문에 엘리먼트를 표시하기 전에 엘리먼트를 변경한다. (display: none 속성이 설정된 노드는 화면에 어떠한 공간도 차지하지 않기 때문에 Render Tree를 만드는 과정에서 제외된다.) visibility invisible은 레이아웃 공간을 차지하기 때문에 reflow의 대상이 되지만 display none은 Layout 공간을 차지하지 않아 Render Tree에서 아예 제외된다.

10. 합성만을 발생시키는 요소 사용하기. 스타일 속성 중 position, width, height 등과 같이 기하적 변화를 유발하는 속성을 변경하면 레이아웃이 발생한다. transform을 사용한 엘리먼트는 `레이어로 분리`되기 때문에 영향받는 엘리먼트가 제한되어 레이아웃과 페인트를 줄일 수 있다. 그리고 `합성만 발생`시키기 때문에 애니메이션에서 사용 시 렌더링 속도가 향상할 수 있다. 때에 따라 하드웨어가 지원될 경우 GPU를 사용할 수 있으므로 성능이 빠르다. 예를 들어 left, top을 사용하면 모든 프레임마다 엘리먼트와 배경이 합성되어 많은 시간이 걸리므로, transform: translate()를 사용해야 한다.

결론, left, right, width, height 보다 transform을, visibility/display 보다 opacitiy를 사용하여 리플로우와 리패인트를 줄인다.

## 가상돔

일반적으로 dom에 접근하여 여러번의 속성 변화, 여러번의 스타일 변화를 수행하면 그에따라 여러번의 Reflow, Repaint가 발생하게 됩니다. 하지만 Virtual DOM은 이렇게 변화가 일어나 Reflow, Repaint가 필요한 것들을 한번에 묶어서 dom에 전달하게 됩니다. 따라서 처리되는 Reflow, Repaint의 규모가 커질 수는 있지만 한번만 연산을 수행하게 됩니다. 이를 통해 여러번 Reflow, Repaint를 수행하며 연산이 반복적으로 일어나는 부분이 줄어들어 성능이 개선됩니다. 돔을 쉽게 조작하고, 실제 돔을 변경하면서의 불필요한 렌더링을 최소화시킵니다.

## 웹워커

무거운 연산 작업 시 웹워커를 도입하여 스레드를 나눠서 렌더링을 동시에 진행할 수 있습니다.
자바스크립트는 싱글스레드이지만, 브라우저에서 멀티 쓰레드를 사용할 수 있도록 웹워커 (html5)를 지원합니다.
각 브라우저 엔진에 따라 쓰레드의 개수가 다르지만, 크롬은 5개, 파이어폭스는 4개로 알려져 있습니다.
브라우저 버전별로 웹워커를 사용 유무는 다르기 때문에 웹워커를 통해 분산하여 연산 및 비동기처리를 하기 위해서는 브라우저별 처리가 필요합니다.

Background Thread에서 스크립트를 실행하는 방법으로 UI Thread와는 별개의 Thread를 실행시켜 사용자 인터페이스(UI)를 방해하지 않고 작업을 수행할 수 있습니다.

## React

- 가장 중요한 것은 상태관리.
- 단방향 데이터 플로우이다. 스테이트 관리 패턴. 스테이트가 꼬이지 않고 명료하게 나타난다.
- 단순 뷰레이어가 아닌 새 패턴의 한 부분이다.
- React는 프레임워크가 아닌 라이브러리기 때문에 다른 프레임워크와 혼용 가능
- 상태가 변하면 화면이 업데이트(변경)된다.
- 화면 갱신 상태에 의존 셀렉터 필요 없음
- 부작용(Side-Effect)없이 프로그래밍 하는 좋은 방법 중 하나는 커다란 코드를 작은 단위로 쪼개서 작성하는 것이다. (함수나 클래스를 사용하기도 하고, React에서는 컴포넌트라는 개념)
- 컴포넌트의 역할을 분리해 각각 고유한 책임을 부여함으로서 재사용성을 높이고, 디버깅을 쉽게하는데 그 목적이 있다.
- Component 의 가독성이 매우 높고 간단하여 쉬운 유지보수, 간편한 UI 수정 및 재사용 용이
- 모듈의 단위가 컴포넌트다. 컴포넌트 단위로 코드를 재사용 할 수 있다.
- 재사용 가능한 UI 컴포넌트. 레고블럭 조립
- 목적에 맞는 컴포넌트(레이아웃으로 컨테이너/화면구성 프레젠테이셔널)구성을 통해 관리가 용이해지고 코드 공유 및 코드 재사용 가능
- 컴포넌트당 클래스를 사용하므로 css캡슐화
- 직관적인 html jsx 마크업개발자와 협업
- React는 JavaScript 객체 형태의 Virtual DOM 을 사용하여 어플리케이션의 성능을 향상시킴 (JavaScript Virtual DOM 처리가 실제 DOM 보다 빠르기 때문)

### 단점

- 라이프사이클 잘 이해하고 사용해야 함. 꼬일 수 있음.
- 스테이트 관리 잘 해야함. 스테이트 관리를 잘 해야한다. 상황에 맞게 써야지 무턱대로 사용하면 불피요한 상태를 계속 관리하게 되어 더 복잡하다.
- VIEW ONLY , VIEW 이외의 기능은 써드파티 라이브러리(Third party library, =패키지, 모듈로 불리기도함)를 이용하거나 직접 구현해야함
- IE8 이하 지원하지 않음 (IE8 이하 버전을 지원해야 할 경우 v0.14 버전을 사용 해야함)
- React는 inline-template 과 JSX 를 사용하는데, 일부 개발자들에게는 적응이 안 될 수 있음

### 컴포넌트

- Portal 컴포넌트는 논리적으로 하위 컴포넌트지만 시각적으로는 상위 컴포넌트여야 할 때 사용한다.
- React에서는 합성, Composition을 통해 컴포넌트를 재사용할 수 있다.
- Composition을 지원하는 컴포넌트의 경우 PureComponent를 사용하면 성능이 나쁠 수 있다.
- Composition을 지원하는 컴포넌트를 최적화 하고 싶으면 특수화를 적용한다.
- Uncontrolled component & Controlled Component: Uncontrolled 컴포넌트는 상태를 직접 React 에서 제어하지 않는다는 의미에서 Uncontrolled 컴포넌트로 불립니다. 상태를 받는다. Controlled Component는 상태를 밀어넣어 준다. component의 prop으로 설정하고 이를 활용

* 컴포넌트 제대로 만들기: https://hyunseob.github.io/2019/06/02/react-component-the-right-way/

### 컴포넌트 구조

컴포넌트의 역할을 분리해 각각 고유한 책임을 부여함으로서 재사용성을 높이고, 디버깅을 쉽게하는데 그 목적이 있다. 컴포넌트나 state를 재활용하기 위해 HOC를 많이 사용하게 된다면 Wrapper Hell을 마주하게 된다.

[Presentational 컴포넌트]

보여주는데 초점을 맞춘 이 컴포넌트는 스타일 정보만을 가지며 화면을 그리는데만 집중한다. 이 컴포넌트는 보여주는데 집중하기 때문에 복잡한 비지니스 로직을 가지지 않으므로 state를 가질 필요가 없다. 따라서 함수형 컴포넌트(Functional Component)로 많이 구현을 한다.

[Container 컴포넌트]

비지니스 로직을 가지고 있으며, Presentational Component들을 가지고 화면을 그리는 최소한의 스타일 정보만 가지고 있다.

[hook 장점]

- useState: 상태 관리
- useEffect: 라이프 사이클
- useContext: 컨텍스트 사용
- useRef: 돔 접근
- useMemo, useCallback: 메모이제이션
- useReducer: 리듀서


- useState라는 Hook을 사용하면 `state를 재사용` 할 수 있게 해줄 뿐만 아니라, 비교적 덜 무거운 함수형 컴포넌트에도 state를 사용할 수 있다. 재사용하기 쉽게 모듈화 되었고, 가독성도 훨씬 좋아진 것을 알 수 있다.
- 컴포넌트를 개발하다보면 라이프 사이클에 중복된 로직을 사용하는 경우가 상당히 빈번하다. useEffect는 componentDidMount, componentDidUpdate, 그리고 componentWillUnmount를 합친 기능으로 중복된 로직을 피할 수 있게 한다.
- Class안에서 사용하는 this 문제해결. this는 호출패턴에 따라 달라진다. class컴포넌트는 바인딩이 필요하고 따라서 바인딩 작업 때문에 코드가 장황해진다.

참고) 컴포넌트의 render()함수가 실행되면 DOM이 그려집니다. render에서 사용되는 this는 컴포넌트 객체를 가리키는 것이 맞습니다. 그러나! React 클래스에서의 this는 클래스가 아닌, 전역객체를 의미합니다. 무슨말인고 하니 자바스크립트에서의 this는 호출하는 문맥(context)에 의해 좌우되는데 클래스의 메소드에서 호출되는 this는 컴포넌트가 아닌 전역객체를 가리킨다는 것입니다.

즉, click이벤트 핸들러함수에서 호출하는 this는 컴포넌트 객체를 가리키지 않습니다. handleClick() 함수가 호출될때의 this는 컴포넌트 객체가 아닌 전역객체 window를 의미합니다. 이유는, `객체의 메소드를 호출한 것이 아니라 단지 함수를 호출`했기 때문입니다. 메소드실행의 경우, 메소드를 소유한 객체가 this가 되지만 일반 함수를 호출한 경우 함수 실행에서의 this(실행문맥)는 전역객체를 가리킵니다.

- bind 메소드는 this의 대상을 지정해주는 역할을 합니다. 화살표함수는 실행문맥을 가지지 않기 때문에 컴포넌트 객체의 메소드를 실행하고자 하는경우 유용하게 사용할 수 있다.

- 화살표 함수: 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다. 동적으로 결정되는 일반 함수와는 달리 화살표 함수의 this 언제나 상위 스코프의 this를 가리킨다. 이 함수 표현은 메소드 함수가 아닌 곳에 가장 적합하다. 그래서 생성자로서 사용할 수 없다.

[하나의 컴포넌트 파일에서 구조]

- 외부 라이브러리 및 모듈 import
- component function 선언
- useSelector나 useState를 통하여 state 초기화 및 store값 가져오기
- useEffect를 통한 component의 lifecycle 구현
- return을 통한 JSX 구현
- 컴포넌트의 propTypes, defaultProps 작성
- 컴포넌트 export

[HOC]

장단점? 레퍼헬

Cross Cutting Concerns의 경우, 개발을 하다 보면 다음과 같은 상황에 직면하는 경우가 종종 있습니다.

- 개발 전반에 걸쳐 반복해서 등장하는 로직
- 그럼에도 불구하고 모듈화가 쉽지 않은 로직

예를 들면 유저 인증과 에러 처리의 과정으로 코드 디자인적인 측면에서 공통적으로 발생하지만 쉽게 분리를 시키지 못하는 문제를 Cross Cutting Concerns라고 합니다. 이 문제를 끌어안고 가면 프로젝트의 코드는 쉽게 스파게티가 되고 나중에는 유지 보수를 하기 힘들어집니다. HOC와 Decorator가 있고 이를 이용해 이 문제를 쉽게 해결할 수 있습니다. HOC는 하나의 부품처럼 특정 컴포넌트에 기능 하나를 추가해주는 역할을 합니다.

[state를 API의 응답으로 맞추는 이유]

action에 맞추어 status를 관리하고 response를 저장하여 component 에서 action의 상태에 따른 후 처리를 대응하기 위함.

1. component에서 어떠한 액션과 관련있는지 알고 싶다.
2. 액션의 상태 및 결과(success, response)에 대해서 후처리를 component에서 하고 싶다.

### 생명주기

- counstructor
- `componentWillMount`(v17 deprecated)
- render
- componentDidMount
- `componentWillReceiveProps(nextProps)`(v17 deprecated -> getDerivedStateFromProps)
- shouldComponentUpdate(nextProps, nextState)
- `componentWillUpdate`(v17 deprecated -> getSnapshotBeforeUpdate)
- render
- componentDidUpdate(prevProps, prevState)
- componentWillUnmount

참고) 변경 이유

- 초기 렌더링을 제어하는 방법이 많아져서 혼란이 됨.
- 오류 처리 인터럽트 동작시에 메모리 누수 발생할 수 있음.
- React 커뮤니티에서도 가장 혼란을 야기하는 라이프 사이클

[counstructor]
컴포넌트가 처음 만들어 질때 실행됩니다. 기본 state를 설정할 수 있습니다.

[componentWillMount]
컴포넌트가 DOM위에 만들어지기 전에 실행 됩니다. 따라서 DOM을 처리할 수 없습니다. render가 호출되기 전이기 때문에 setState를 사용해도 render가 호출하지 않습니다. (v17 deprecated에서 삭제)

[render]
화면 렌더링을 담당 합니다.

[componentDidMount]
첫 렌더링 후 실행됩니다. 이 안에서 다른 js프레임웍 연동 및 setTimeout, setInterval 및 Ajax를 사용합니다.

[componentWillReceiveProps(nextProps)]
props를 받을 때 실행됩니다. props에 따라 state를 업데이트 할 때 사용하면 유용합니다. 이 안에서 setState할 수 있지만 추가적인 렌더링은 발생하지 않습니다. 컴포넌트가 처음 마운트 되는 시점에서는 호출되지 않습니다. (v17 deprecated - getDerivedStateFromProps로 대체됨)

[shouldComponentUpdate(nextProps, nextState)]
props/state가 변경되었을때 리 렌더링을 할지 말지를 결정합니다. 실제로 사용할때는 필요한 비교를 하고 값을 반환해야 합니다. 쓸데없는 렌더링을 걸러낼 수 있습니다. shouldComponentUpdate 메쏘드를 별도로 선언하지 않았다면, 컴포넌트는 props, state 값이 변경되면 항상 리렌더링(re-render) 하도록 되어 있다.

참고) pureComponnet: shouldComponentUpdat함수는 상태(state, props)가 변경될 때, 얕은 비교를 통하여 리렌더링의 유무를 결정합니다. 상태변화에 대한 비교없이 무조건 불필요한 리렌더링을 수행하는 일반 컴포넌트보다는 필요한 경우에만 렌더링을 수행하므로써, 성능을 개선할 수 있는 이점이 있습니다.

ex) return nextProps.id !== this.props.id (이때 JSON.stringify를 사용하여 여러 field를 편하게 비교 할 수 있습니다.)

[componentWillUpdate(prevProps, prevState)]
컴포넌트 업데이트 직전 실행됩니다. setState는 절대로 사용하면 안됩니다. 무한 루프에 빠질수 있습니다. (v17 deprecated - getSnapshotBeforeUpdate로 대체됨)

[componentDidUpdate(prevProps, prevState)]
컴포넌트 업데이트 직후 실행됩니다. setState는 절대로 사용하면 안됩니다. 무한 루프에 빠질수 있습니다.

[componentWillUnmount]
컴포넌트가 DOM에서 사라진 후 실행됩니다. 컴포넌트 내부에서 타이머나 비동기 API를 사용하고 있을 때, 이를 제거하기에 유용합니다.

### React - Redux

Redux는 React에서 컴포넌트간의 State전달 및 관리를 편리하게 해 주는 라이브러리입니다. Redux는 Flux라는 아키텍처를 조금 손봐서 React에서 사용하기 적합하게 만들었습니다. React까지 필요하지 않는 기능에도 State를 맡기면 더러워지거나 오버 엔지니어링을 했던 시행착오를 해결할 수 있습니다. 규모나 상황에 따라 Redux는 선택적으로 사용하는 것이 맞습니다. 어떤 컴포넌트에 어떤 State를 공유 할 것인지에 대해 고민해야 합니다. 어떤 곳에서는 오히려 React의 깔끔한 구조를 깨뜨리기도 하는데 굳이 필요하지 않다면 전체적인 프로젝트의 복잡성을 낮추는데 도움이 됩니다.

### 미들웨어 thunk의 단점

미들웨어는, 액션이 디스패치(dispatch) 되어서 리듀서에서 이를 처리하기전에 사전에 지정된 작업들을 설정합니다. 미들웨어를 액션과 리듀서 사이의 중간자라고 이해할 수 있습니다.

리듀서가 액션을 처리하기전에 필요한 작업들을 미들웨어를 통해 할 수 있습니다. 만약에 특정 액션이 몇초뒤에 실행되게 하거나, 현재 상태에 따라 아예 액션이 무시되게 하고 다른 종류의 액션들을 추가적으로 디스패치 할 수도 있습니다.

redux-thunk 를 통해 만든 액션생성자는 그 내부에서 여러가지 작업을 할 수 있습니다. 이 곳에서 네트워크 요청을 할 수 있습니다. 또한, 이 안에서 액션을 여러번 디스패치 할 수도 있습니다.

그러나 단점으로는 액션쪽에 비동기통신 코드가 번잡하게 들어감에 따라 파악하기 힘듭니다. 만들면서 맘에 들지 않았던 부분은 action이 dispatch만 하는것이 아니라 로직을 담고 작업을 수행한다는 단점이 있습니다. action의 역할 이상으로 다른 영역까지 책임을 지고 있기 때문에 뭔가 찝찝합니다.

부작용을 다루기 위해 사가 사용.

- 지연처리
- 인수들을 변경(mutate)하기.
- HTTP 리퀘스트 처리
- API 호출이나 라우팅 전환같은 사이드이펙트를 일으키기.
- 같은 입력에 대해 확률적으로 다른 결과가 나오는 처리
- Date.now()나 Math.random() 같이 순수하지 않은 함수를 호출하기. 인수가 주어지면, 다음 상태를 계산해서 반환하면 됩니다. 예기치 못한 일은 없어야 합니다. 사이드 이펙트도 없어야 합니다. API 호출도 안됩니다. 변경도 안됩니다. 계산만 가능합니다.

## 화면개발

### 기존 화면 개발의 어려움

- 데이터 업데이트에 대한 화면 변경 성능 문제
- 중복되는 페이지 유지보수 어려움

특히 es6 문법을 함께 사용하면서 클래스, 프로미스, 모듈내보내기 불러오기, 템플릿 리터럴등 문법이 간결하고 쉬워짐

### SPA 장점과 단점

[장점]

- 사용자 친화적 (빠른 반응성, 화면전환 에니메이션 등): client rendering, router
- 필요한 부분만 새로 그리고 필요한 데이터만 새로 받는다.
- 상대적으로 적은 전체 트래픽 양 (Ajax, 캐쉬)
- 유지보수가 쉽고 개발속도가 빠르다. (모듈화, 컴포넌트화)
- 프론트앤드와 백앤드의 분리로 인한 개발업무 분업화 및 협업이 쉽다.

[단점]

- 초기구동속도가 느리다. 이는, Lazy Loading으로 해결할 있다.
- 검색엔진 최적화(SEO) 문제. SSR로 해결 가능. 앱을 서버 측 렌더링하거나 Prerender와 같은 서비스를 사용하여 브라우저에서 JavaScript를 렌더링하고, 정적 HTML을 저장한 다음, 크롤러에게 반환합니다.
- 하얀 화면(개발자 버그): Error Boundaries
- 자바스크립트의 메모리 부족은 어플리케이션 속도를 저하시킬 수 있습니다.

### SPA 성능 문제 개선

- Webpack과 같은 모듈 번들러(Module Bundler)를 사용하여 여러 파일을 하나의 파일로 통합하여 용량이 커지면, 인터넷이 느린 환경에서는 페이지 로딩속도도 느려질 것. -> 청크, 캐시, 코드 스플릿 도입
- lazy loading으로 초기 로딩 속도 개선.
- 초기 페이지에서 모든 리소스를 다운받지 않고, 리소스를 청크(Chunk) 단위로 묶어서 해당 리소스에 대한 요청이 있을 때만 다운로드 받도록 하는 방법 lazy loading
- 지금 당장 필요한 코드가 아니라면 따로 분리시켜서, 나중에 필요할때 불러와서 사용하도록 코드스플릿 사용.

참고) 웹팩은 모듈번들러. 여러개 나누어져 있는 파일들을 하나의 파일로 만들어 준다. 코드를 압축하고 최적화 할 수 있기 때문에 로딩속도를 높일 수 있다. 번들러를 사용하는 이유는? 코드의 양이 많아지면 코드의 유지와 보수가 쉽도록 `코드를 모듈로 나누어 관리`하는 모듈 시스템이 필요해집니다. 그러나 JavaScript는 언어 자체가 지원하는 모듈 시스템이 없습니다. 이런 한계를 극복하려 여러 가지 도구를 활용하는데 그 도구 가운데 하나가 webpack입니다.

request / response에 걸리는 시간을 획기적으로 줄일 수는 없었을까요. 여러 차례 http request 날리는 것이 문제라면 한 번 날리는 것으로 바꿔주면 됩니다. 대신, `한 번의 request`를 통해서 모든 모듈들을 한꺼번에 로드하면 됩니다.

---

## 검색엔진 최적화 SEO

- 보안 프로토콜 적용(HTTPS): 가산점 (적용을 장려)
- 문법에 맞는 HTML 작성하기
- 구체적인 페이지 제목 만들기
- 메타 태그 활용하기
- Robots.txt: 검색엔진 알고리즘이 접근여부 설정
- Sitemap.xml: 크롤링과정에서 색인될 수 있게 함
- Img의 alt 속성 적용: 높은 검색 순위 적용 및 이해
- 서버사이드 렌더링
- URL변경으로 리디렉션을 할때, 임시변경 302(307)보다는 영구변경 301(308)리디렉션 사용
- 인라인 속성 자제: HTML 파일 크기가 커지면 최적화 손해, 크롤링방해

---

## 서버사이드렌더링

https://www.popit.kr/react-%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81/

1. 우리 웹페이지를 검색 엔진에 노출시키기 위해서
2. 초기 렌더링 속도를 향상 시키기 위해서(최적화)

서버를 위해 번들링할 때는 node_modules에서 불러오는 것을 제외하고 번들링하는 것이 좋습니다. 이를 위해서 아래 라이브러리를 사용해야합니다. 번들링에 포함되지않은 static 파일들의 이름과 위치를 담은 Dictionary를 생성합니다. 리엑트 서버사이드 렌더링 에서는 componentDidMount는 호출되지 않습니다. 생성자와 componentWillMount만 호출됩니다.

```sh
$ yarn add webpack-node-externals
```

리액트 결과물에 라이브러리를 포함시키않습니다. 필요할 때마다 서버측에서 라이브러리를 통해 사용하기 때문에 불필요하게 클라이언트에게 제공할 필요가 없습니다. 이 처리을 통해 더욱 클라이언트측에서 코드가 더욱 가벼워질 것입니다.

[장점]

- SSR의 경우 view를 서버에서 렌더링하여 가져오므로 첫 로딩이 매우 짧음 (view를 보기까지)
- 물론 js파일을 모두 다운로드하고 적용하기 전까지는 그 어떤 인터렉션에도 반응하지는 않지만, 사용자 입장에서는 로딩이 매우 빠르다고 느껴짐.
- SEO(Search Engine Optimization) 검색엔진 최적화에 유리함(js 라이브러리/프레임워크를 사용하면서 고질적인 문제는 seo이다. 그냥 미리 그려지지 않고 빈 껍데기만 제공된다면 검색엔진이 당연하게도 내용을 검색하는데 어려움이 있음 but, SSR은 서버에서부터 페이지를 제공할 때 컨텐츠가 담겨있기 때문에 SEO에 대한 걱정을 덜 수 있음)

[단점]

- 장점을 제공하는 만큼 사용하는데에 있어서 어려움과 번거로움
- 프로젝트의 구조가 많이 복잡해짐.
- 단순히 렌더링만 하는것은 그렇게 큰 문제는 아니지만, 리액트 라우터, 리덕스 등의 라이브러리와 함께 연동해서 사용하면서, 서버에서 데이터를 가져와서 렌더링을 해줘야하는 경우엔 조금 어려워질수도 있다.
- view 변경 시 서버에 계속 요청을 해야하므로 서버에 부담이 큼, 정보가 많은 B2C 웹 서비스 등에는 서버 부담이 큼(요청 시 마다 새로고침이 일어나며 페이지를 로딩할 때마다 서버로부터 리소스를 전달받아 해석하고 화면에 렌더링 하는 방식이기 때문이다. 예를들어 현재 주소에서 동일한 주소를 가리키는(갖고있는) 버튼을 눌렀을때, 설정페이지에서 필요한 데이터를 다시 가져올 수 없다.

이것은 사용자와 인터랙션이 많은 요즘 웹앱에게 충분하지 않는 방법일 수 있다. 렌더링을 서버쪽에서 하는 것은 그 만큼 렌더링을 위한 `서버 자원이 사용`되는 것이고, 불필요한 트래픽도 낭비되는 것이다.

[대안]

- 동일한 페이지는 특정기간 동안 캐싱하여 성능을 최적화 할 수 있음
- 비동기식 렌더링
- 써드파티 라이브러리를 통하여 비동기식으로 작동하게끔 코드를 작성 할 수 있습니다.
- 메타태그(서버쪽에서 라우트에 따라 필요한 메타태그만 넣어주는 것. 그러면, 크롤러에선 해당 페이지에 대한 기본 정보는 얻어 갈 수 있게 된다.

- rapscallion: renderToString 을 비동기로 해주며, Promise 기반으로 작동하고, 컴포넌트 단위로 캐싱을 할 수 있습니다
- hypernova: airbnb 에서 만든 도구로서, 렌더링을 위한 서버를 따로 열어서 cluster 를 사용하여 여러 프로세스를 생성하여 렌더링을하고, 운영서버에서 렌더링서버로 결과물을 요청을 하는 방식으로 작동합니다.
- react-router-server: react-router v4 를 위해 만들어진 서버사이드 렌더링 라이브러리로서, Promise 비동기식 렌더링을 지원해주고, 깔끔한 방식으로 데이터를 불러올 수도 있습니다.)

## 웹사이트 최적화

- WebCache
- Code Compressing
- Image Optimizing
- Image Spriting
- Critical Rendering Path
- Webfont Optimizing
- Lazy Loading

## 웹 캐시

https://hahahoho5915.tistory.com/33

[캐싱 기본 개념]
캐싱(Caching)은 애플리케이션의 처리 속도를 높여준다. 이미 가져온 데이터나 계산된 결과값의 복사본을 저장함으로써 처리 속도를 향상시키며, 이를 통해 향후 요청을 더 빠르게 처리할 수 있다. 대부분의 프로그램이 동일한 데이터나 명령어에 반복해서 엑세스하기 때문에 캐싱은 효율적인 아키텍처 패턴이다.

[웹 캐시(WEB Cache)]
사용자(client)가 웹 사이트(server)에 접속할 때, 정적 컨텐츠(이미지, JS, CSS 등)를 특정 위치(client, network 등)에 저장하여, 웹 사이트 서버에 해당 컨텐츠를 매번 요청하여 받는것이 아니라, 특정 위치에서 불러옴으로써 사이트 응답시간을 줄이고, 서버 트래픽 감소 효과를 볼 수 있다. 하지만 잘못 사용한다면 고객들에게 실시간으로 정보를 올바르게 주지 못하고, 오히려 고객 CS가 발생하는 등 해당 업무 프로세스와, 시스템 환경을 잘 분석하여 적용하는 것이 중요할 것이다.

웹 캐쉬의 종류는 어디에 적용하느냐에 따라 다음과 같이 나뉠 수 있으며 이중 중점적으로 볼 내용은 Browser Cache입니다.

1. Browser Caches

- 브라우저 또는 HTTP요청을 하는 Client Application에 의해 내부 디스크에 캐쉬
- Cache된 Resource를 공유하지 않는 한 개인에 한정된 Cache
- 브라우저의 Back버튼 또는 이미 방문한 페이지를 재 방문하는 경우 극대화

2. Proxy Caches

- Browser Cache와 동일한 원리로 동작하며 Client나 Server가아닌 네트워크 상에서 동작.
- 큰회사나 IPS의 방화벽에 설치 되며 대기시간 & 트래픽 감소, 접근정책 & 제한 우회, 사용률 기록등 수행
- 한정된 수의 클라이언트을 위하여 무한대의 웹서버의 컨텐츠를 캐쉬

3. Gateway Caches (REVERSE OR SURROGATE PROXY)

- 서버 앞 단에 설치되어 요청에 대한 캐쉬 및 효율적인 분배를 통해 가용성, 신뢰성, 성능등을 향상
- Encryption / SSL acceleration, Load balancing, Serve/cache static content, Compression등을 수행
- 무한대의 클라이언트들에게 한정된 수(또는 하나)의 웹서버 컨텐츠를 제공

[브라우저 캐시]
ETag HTTP 응답 헤더는 특정 버전의 리소스를 식별하는 식별자입니다. 웹 서버가 내용을 확인하고 변하지 않았으면, 웹 서버로 full 요청을 보내지 않기 때문에, 캐쉬가 더 효율적이게 되고, 대역폭도 아낄 수 있습니다.

[브라우저 캐쉬 동작]
https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#invalidating-and-updating-cached-responses
https://goddaehee.tistory.com/171

이제 캐쉬가 일어나는 과정에서 위에서 설명한 http header들이 어떻게 사용되는지 살펴보겠습니다.

[첫 요청]

1. 브라우저는 서버에 index.html 파일을 요청합니다.
2. 서버는 index.html파일을 찾아보고 존재 하는 파일이라면 파일 내용을 브라우저에게 몇 가지 header값과 함께 응답합니다.
3. 브라우저는 응답 받은 내용을 브라우저에 표시하고 응답 헤더의 내용에 따라 캐쉬 정책을 수행합니다. (응답 헤더에 Last-Modified, Etag, Expires, Cache-Control:max-age 항목이 존재 한다면 복사본을 생성하고 값을 저장)

[재요청] (validation 수행)

- RESPONSE: Last-Modified / Etag
- REQUEST: If-Modified-Since / If-None-Match

(응답 LAST-MODIFIED -> 요청 If-Modified-Since)
(응답 Etag -> 요청 If-None-Match)

1. 브라우저는 최초 응답 시 받은 Last-Modified 값을 If-Modified-Since 라는 헤더에 포함 시켜 페이지를 요청합니다.
2. 서버는 요청 파일의 수정 시간을 If-Modified-Since값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면 200 OK와 함께 새로운 Last-Modified값을 응답 헤더에 전송합니다.
3. 브라우저는 응답 코드가 304인경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은후 Last-Modified값을 갱신합니다.

(응답 ETAG: ENTITY TAG -> 요청 If-None-Match)
ETag HTTP 응답 헤더는 특정 버전의 리소스를 식별하는 식별자입니다. 웹 서버가 내용을 확인하고 변하지 않았으면, 웹 서버로 full 요청을 보내지 않기 때문에, 캐쉬가 더 효율적이게 되고, 대역폭도 아낄 수 있습니다.

1. 브라우저는 최초 응답 시 받은 Etag값을 If-None-Match 라는 헤더에 포함 시켜 페이지를 요청합니다.
2. 서버는 요청 파일의 Etag값을 If-None-Match값과 비교하여 동일하다 면 304 Not Modified로 응답하고 다르다면 200 OK와 함께 새로운 Etag 값을 응답 헤더에 전송합니다.
3. 브라우저는 응답코드가 304인 경우 캐쉬에서 페이지를 로드하고, 200이라면 새로 다운 받은후 Etag값을 갱신합니다.

- Etag는 서버마다 생성하는 값이 다르며 파일마다 고유한 값을 가집니다.
- LAST-MODIFED(1.0) 와 ETAG(1.1)는 validation을 체크 합니다. 이를 체크하기 위해 서버와 한번의 통신이 발생하게 되며 그로 인해 요청과 응답에서 header와 cookie등에 의한 데이터 전송(1KB)이 발생하게 됩니다.

(If-None-Match)

- 서버보고 ETag가 달라졌는 지 검사하고 ETag가 다를 경우에만 컨텐츠를 새로 받는다.
  ex) If-None-Match: "0-2b800-5c466dda"
- 만약 ETag가 같다면 서버는 304 Not Modified를 응답하고 캐시를 그대로 사용하게 한다.

(Age)
Age 헤더는 캐시 응답 때 나타나는데, max-age 시간 내에서 얼마나 흘렀는지 초 단위로 알려줍니다. max-age= 3600을 설정한 경우, 1분이 지나면 Age: 60 이 캐시 응답 헤더에 포함됩니다.

(Expires)
Expires 날짜 헤더를 응답에 첨부할 수 있다.

1. 브라우저는 최초 응답 시 받은 Expires 시간을 비교하여 기간 내라면 서버를 거치지 않고 바로 캐쉬에서 페이지를 로드 합니다. 만약 기간이 만료되었다면 위에 설명한 validation 작업을 수행합니다. Cache-Control과 별개로 응답에 Expires라는 헤더를 줄 수도 있습니다. 응답 컨텐츠가 언제 만료되는지를 나타내며, Cache-Control의 max-age가 있는 경우 이 헤더는 무시됩니다.

(Cache-Control)

1. 브라우저는 최초 응답 시 받은 Cache-Control 중 max-age값(초 단위)를 GMT와 비교하여 기간 내라면 서버를 거치지 않고 캐쉬에서 페이지를 로드합니다. 만약 기간이 만료되었다면 validation 작업을 수행합니다.

- no-store: 캐시가 그 응답의 사본을 만드는 것을 금지한다.
- no-cache: 응답은 로컬 캐시 저장소에 저장될 수 있다. 다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없다.
- max-age: 캐시 유효시간. 리소스가 최신 상태라고 판단할 최대 시간을 지정합니다. 신선하다고 간주되었던 문서(만료되지 않은 문서)가 서버로부터 온 이후로 흐른 시간이고, 초로 나타낸다. 시간이 지나면, 응답 캐시는 만료된 것으로 여겨진다. 시간이 얼마나 지났는지는 age로 판단할 수 있다.
- age 헤더! 캐시 응답 때 나타나는데, max-age 시간 내에서 얼마나 흘렀는지 초 단위로 알려줍니다. 위 예제에서 max-age= 3600을 설정한 경우, 1분이 지나면 Age: 60 이 캐시 응답 헤더에 포함됩니다.
- expires 헤더!는 Cache-Control과 별개로 응답에 Expires라는 헤더를 줄 수도 있습니다. Expires: Thu, 26 Jul 2018 07:28:00 GMT 응답 컨텐츠가 언제 만료되는지를 나타내며, Cache-Control의 max-age가 있는 경우 이 헤더는 무시됩니다.

- must-revalidate: 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안 된다는 것을 의미한다.

아래 두 값을 통해 캐시를 막을 수 있다.

- no-cache: 브라우저가 서버의 응답을 캐시할지 스스로 결정할 수 있다. 하지만, 캐시된 정보가 해당 서버에서 제공한 것인지는 요청을 하게 된다.
- no-store: 브라우저가 서버의 응답을 캐시하지 못하도록 한다. 이 말은 반드시 매번 서버에 요청해야만 한다는 의미이다.

* Expires(1.0)와 Cache-Control: max-age(1.1)는 freshness를 체크합니다. 기간 내라면 서버와 통신을 하지 않고 캐쉬를 사용합니다.
* 시간은 HTTP date 형태이며 로컬 타임이 아닌 GMT를 사용합니다.
* 서버가 Last Modified Time 또는 Last Access Time을 기준으로 하여 일정 시간 이후로 Expires 또는 max-age를 설정 합니다.

[캐시전략]

캐쉬가 잘 적용되게 하기 위해서 다음과 같은 전략을 새웁니다.

1. 일관된 URL을 사용하라. 동일한 URL은 동일한 사이트라면 다른 페이지에서도 캐쉬되어 사용될 수 있습니다.
2. 자주 바뀌는 파일과 그렇지 않은 파일을 분리합니다. 그래야 각 Resource에 대해 최적의 freshness를 설정할 수 있습니다.
3. 다운가능한 파일의 내용이 바뀌면 이름(URL)을 바꿉니다. 그래야 수정된 버전(핑거프린트)을 제공할 수 있습니다.
4. SSL을 최소화 합니다. 암호화된 페이지는 캐쉬되지 않습니다.

### HTTP 헤더를 통한 브라우저 캐싱

- 모든 브라우저는 HTML 페이지, 자바스크립트 파일 및 이미지와 같은 웹 문서의 임시 저장을 위해 HTTP 캐시 (웹 캐시)의 구현을 제공하고있다.
- HTTP 헤더 지시문을 제공하여 브라우저가 응답을 캐싱할 수 있는 시기와 지속 기간을 지시할 때 사용된다.
- 리소스가 로컬 캐시로부터 빠르게 로드되기 때문에 점점 하드웨어 성능이 급격하고 있는 최근, 잘 활용한다면 엄청 강력한 속도를 제공 한다.
- 요청이 네트워크를 통해 전송되지 않기 때문에 왕복 시간(RTT, Round Trip Time)이 발생하지 않는다.
- 애플리케이션 서버 및 파이프라인의 다른 구성 요소에 대한 부하가 줄어든다.

## HTTP 요청 줄이기

초기 커넥션당 하나의 요청으로 인하여 동시 전송이 불가하였습니다. 파이프라이닝 기법을 통해 요청을 연속적으로 발생시켜 응답을 받았는데 다수 리소스 요청시 맨 마지막요청은 대시시간이 길어지는 문제가 여전히 발생하였습니다. HTTP2에서는 멀티플렉싱 스트림 기능으로 동시에 여러 메시지를 주고 받을 수 있게 되었습니다. 또, 리소스간 의존관계(우선순위)를 설정하여 렌더링이 늦어지는 문제를 해결하였습니다.

- 이미지스프라이팅: 큰 이미지에 좌표값을 지정한다
- 도메인 샤딩: 커넥션 수를 늘린다
- 압축: 전송되는 데이터용량을 줄인다.
- 데이터 URI스킴 사용: base64인코딩으로 이미지를 적용한다.
- HTML구조와 CSS스타일 렌더링시, 자바스크립트를 만나면 js완료전가지 렌더링이 블록된다. 스크립트 삽입 위치에 따라 스크립트 실행순서와 브라우저렌더링에 영향을 줄 수 있다. (defer는 외부자원비동기로딩 html파싱후 스크립트 실행 / async는 외부자원비동기로딩 받는 즉시 스크립트 실행)

style는 head에, javascript는 body 최하단에 위치하도록 합니다. 기본적으로, 브라우저가 페이지를 렌더링하려면 먼저 HTML 마크업을 파싱하여 DOM을 빌드해야 합니다. 하지만 브라우저가 파싱을 하다가 스크립트 파일을 만날 경우, 스크립트 파일을 요청하고 다 불러와지는 동안 구문에 대한 분석을 중단하게 되는데, 이것이 우리가 흔히 말하는 렌더링 블록킹(Rendering Blocking) 현상입니다. 당연히 렌더링이 계속해서 블록될 시 페이지의 첫 렌더링 시간은 지연될 수 밖에 없으며, 이는 곧 좋지 않은 사용자 경험으로 이어지게 됩니다. 이와 같은 이유 때문에, style과 script 파일을 지정된 곳에 위치시켜야 한다는 것이고, 좀 더 나은 페이지의 성능을 위해 간단하지만 필수적이라고 할 수 있습니다.

## CDN

콘텐츠를 담고있는 서버(Origin Server)들은 모든 사용자의 요청에 일일이 응답해야 한다. 이는 막대한 트래픽을 유발하고, 트래픽이 과도하게 증가하거나 부하가 끊임없이 들어오는 경우 장애가 발생할 확률도 크다. CDN을 사용함으로써 서버의 트래픽 부하 및 비용을 줄이고 사용자에게 빠른 서비스 제공도 가능하다. 장애 확률도 낮춰 줄 수 있다.

[장점]

1. 웹사이트 로딩 속도 개선
2. 인터넷 회선 비용 절감
3. 컨텐츠 제공의 안정성
4. 웹사이트 보안 개선

[CDN의 작동원리]

1. 최초 요청은 서버로 부터 컨텐츠를 가져와 고객에게 전송하며 동시에 CDN캐싱장비에 저장한다.
2. 두번째 이후 모든 요청은 CDN 업체에서 지정하는 해당 컨텐츠 만료 시점까지 CDN캐싱장비에 저장된 컨텐츠를 전송한다.
3. 자주사용하는 페이지에 한해서 CDN장비에서 캐싱이 되며, 해당 컨텐츠 호출이 없을 경우 주기적으로 삭제된다.
4. 서버가 파일을 찾는 데 실패하는 경우 CDN 플랫폼의 다른 서버에서 콘텐츠를 찾아 엔드유저에게 응답을 전송한다.
5. 콘텐츠를 사용할 수 없거나 콘텐츠가 오래된 경우, CDN은 서버에 대한 요청을 프록시로 작동하여 향후 요청에 대해 응답할 수 있도록 새로운 콘텐츠를 저장한다.

- GSLB(Global Server Load Balancing): 사용자에게 콘텐츠 전송 요청(Delivery Request)을 받았을 때, 최적의 네트워크 환경을 찾아 연결하는 기술. 물리적으로 가장 가깝거나 여유 트래픽이 남아 있는 곳으로 접속을 유도하는 기술로 DNS(도메인 이름을 IP주소로 변환하는 서비스) 서비스의 발전된 형태라고 할 수 있다.

## httpd

HTTPD(HTTP daemon) 서버는 요청 / 응답을 처리하는 서버이다. 가장 일반적인 HTTPD 서버는 Linux의 경우 Apache 또는 Nginx이고 Windows의 경우 IIS이다.

- 데몬(daemon, 발음: 데이먼/'deɪmən/ 또는 디먼 /'dimən/)은 사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다.

[Apache와 Nginx 비교]

| Apache | Nginx |
| 프로세스 중심의 접근법| 이벤트 중심의 접근 방식 |
| 각 요청에 대해 새로운 Thread 필요| 하나의 스레드에서 여러개의 요청을 처리 |
| 요청당 쓰레드 또는 프로세스가 처리하는 구조| 비동기 이벤트 기반으로 요청 |
| 모듈이 다양함| 모듈이 다양하지 않음 |
| PHP모듈 등 직접 적재 가능| 많은 접속자들 대응 가능 |
| 안정성, 확장성, 호환성 유세| 성능 우세 |
| 전통적인 파일기반 방식의 정적 컨텐츠 | 이벤트 처리/비동기식/논블로킹 방식 처리로 인해 정적 컨텐츠 제공시 고속 처리가 가능 |
| 동적 컨텐츠는 서버 내에서 처리 | 동적 컨텐츠를 처리 하지 않는다 |
| 리눅스, BSD, UNIX , Window | 리눅스, BSD, UNIX, Window 부분지원 |

## nodejs

Nodejs는 브라우저가 아닌 환경에서도 자바스크립트를 사용할 수 있게 하는 자바스크립트 `런타임환경`입니다. 서버사이드에서도 사용합니다. 노드를 통해 데스크탑 윈도우 프로그램도 만들 수 있습니다. 아톰에디터도 노드로 만들어져 있습니다. 노드는 웹서버가 아닙니다. 이 자체로는 아무것도 하지 않습니다. 따라서 HTTP서버를 직접 작성해야 합니다. `그냥 단지 코드를 실행할 수 있는 런타임환경`일 뿐입니다.

- 런타임 환경(영어: runtime environment): 컴퓨터가 실행되는 동안 프로세스나 프로그램을 위한 소프트웨어 서비스를 제공하는 가상 머신의 상태이다.

NodeJs는 HTTP 서버 라이브러리를 포함하고 있는데, 이는 웹 서버를 실행시키기 위한 Apache 같은 서버 프로그램이 필요하지 않다는 것이다. 이에 Apache와 같은 서버 운용정책에 종속 적이지 않고, 다양하게 개발하는 것이 가능하다. 정책이 없는 만큼 복잡하기에 위에 적은 Express가 존재한다. NodeJS의 특징 중의 하나는 단일 쓰레드 환경을 도입한 것이다. 이에 동시접속자가 많아도 'Non-blocking I/O'와 'Event Loop'를 통해 느려지지 않게 서비스를 구성할 수 있다.

Node.js®는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임입니다. Node.js는 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적입니다. Node.js의 패키지 생태계인 npm은 세계에서 가장 큰 오픈 소스 라이브러리 생태계이기도 합니다.

## 블로킹/논블로킹 & 동기/비동기

호출 및 처리 방식에서의 구분.

- Blocking/NonBlocking은 호출한 입장에서의 호출되는 함수가 바로 리턴하는지 하지않는지/하는지
- Sync/Async는 처리되는 방식은 함수완료여부를 신경쓰는지/쓰지않는지

비슷한 동작인것만 같은 Blocking/NonBlocking 과 Synchronous/Asynchronous를 각자의 관심사로 구분할 수 있습니다.

- Blocking: 호출되는 함수가 바로 리턴하지 않는다.
- NonBlocking: 호출되는 함수는 바로 리턴한다.
- Synchronous: 호출하는 함수는 작업 완료 여부를 신경쓴다.
- Asynchronous: 호출하는 함수는 작업 완료 여부를 신경쓰지 않는다.

## 비동기 호출

콜백호출 단점. 우선 가독성이 매우 떨어진다. 만약 비동기 처리가 3개로 끝나지 않는다면 끝없이 옆으로 누운 피라미드를 그리게 될 것. 에러처리를 한다면 모든 콜백에서 각각 에러 핸들링을 해주어야 한다. 콜백의 깊이만큼이나 복잡해지는 에러처리. 만약 에러 처리 없이 진행한다면 콜백 함수가 호출되지 않아도 왜- 어디서- 에러가 발생했는지 알아내기가 쉽지 않다.

프로미스 단점. 이러한 불편함을 해소하기 위해 ES6에서 비동기 흐름을 컨트롤하는 방법으로 Promise 객체가 등장한다. MDN: Promise 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다. 하지만 Promise 패턴도 만능은 아니다. 잘못 사용하면 여전히 then이 깊어질 수 있고, if 문 분기와 특정 에러 핸들링은 여전히 어렵다. 또한 코드가 then 체이닝에 갇혀야 한다.

이후 Async await 등장. MDN: 암시적으로 Promise를 사용하여 결과를 반환합니다.
비동기 함수를 사용하는 코드의 구문과 구조는, 표준 동기 함수를 사용하는것과 많이 비슷합니다.

## Event Loop

웹 서비스는 Non-Blocking I/O 시스템을 사용해야한다고 하였다. 하지만 브라우저를 비롯한 JavaScript는 단일 스레드 기반의 언어이다. 스레드가 하나라는 말은 곧 동시에 하나의 작업만 처리할 수 있다는 의미이다. 이 문제를 해결하기 위해 등장하는 개념이 Event Loop이다. 자바스크립트는 Event Loop를 이용하여 비동기 방식으로 동시성을 지원한다. 이와 같은 동시성은 JavaScript 엔진이 아닌 브라우저나 Node.js가 담당한다.

## 자바스크립트

자바스크립트는 싱글 스레드이기 때문에 이벤트 루프를 이용한 Callback 패턴을 굉장히 자주 사용

## 자바스크립트엔진(콜스택/힙/테스크큐) & WEB API(이벤트루프)

- 싱글스레드기반 호출스택, 순차적으로 하나씩만 처리
- 스택은 선형구조(LIFO - Last In First Out)
- 호출 스택의 각 단계를 스택 프레임(Stack Frame)이라고 합니다. 그리고 보통 예외가 발생했을 때 콘솔 로그 상에서 나타나는 스택 트레이스(Stack Trace)가 오류가 발생하기까지의 스택 트레이스들로 구성됩니다.
- 동적으로 생성된 객체(인스턴스)는 힙(heap)에 할당.
- 자바스크립트에서 비동기로 호출되는 함수(자바스크립트 엔진이 아닌 브라우저 APIs(Web API) 영역에 따로 정의되어 있는 함수들)들은 Call Stack에 쌓이지 않고 Task Queue에 들어 갑니다.
- 비동기 콜백은 즉시 호출 스택에 쌓이지 않고 Event Queue에서 기다렸다가 호출 스택이 비어있는 시점에 실행
- 브라우저는 호출 스택이 비워질 때마다 작업 큐에서 가장 오래된 작업을 꺼내와서 해당 작업에 대한 콜백을 실행시킵니다. 브라우저는 이 과정을 끊임없이 반복하는데, 이를 이벤트 루프(event loop)라고 부릅니다.
- 자바스크립트는 Event Loop를 이용하여 비동기 방식으로 동시성을 지원한다.
- 이벤트 루프의 기본 역할은 큐와 스택 두 부분을 지켜보고 있다가 스택이 비는 시점에 콜백을 실행시켜 주는 것입니다.

## 하이브리드앱(앱설치유무, 카메라, 앨범, 좌표 등)

[하이브리드앱의 장점]

- 네이티브API와 브라우저 API를 이용한 다양한 개발이 가능
- 웹 기술을 사용해 앱을 개발 가능 (UI를 통합하여 단일 코드로 개발 가능)
- 한번의 개발로 다수의 플랫폼에 대응 가능

[하이브리드앱의 단점]

- 네이티브 기능에 접근하기 위해 결국 네이티브 지식이 필요
- 웹뷰에서 앱을 실행하는 경우이기에 앱의 성능이 곧 브라우저의 성능
- UI프레임워크 도구(라이브러리)를 사용하지 않는다면 개발자가 UI를 제작해야 함



## MVC(Model, View, Controller)

화면과 데이터 처리를 분리해서 재사용이 가능하도록 하는 구조

- 모델: 데이터 혹은 데이터를 처리하는 영역
- 뷰: 결과 화면을 만들어 내는 데 사용하는 자원
- 컨트롤러: 웹의 요청(request)을 처리하는 존재로 뷰와 모델 사이의 중간 통식 역할

[MVC1]
Controller와 View가 요청과 응답을 함께 관리 합니다. 개발 속도가 빠르고 쉬우나 단, View(프리젠테이션 로직)과 Controller(비즈니스 로직)을 모두 포함하기 때문에 페이지가 너무 복잡해 질 수 있습니다. 또 로직이 혼재되어 있기 때문에 개발자와 디자이너의 분리된 작업이 어렵습니다. 유지보수 하기 어려워지고 정교한 Presentation 레이어를 구현하는데도 어렵습니다.(유효성 체크, 에러 처리등)

[MVC2]
Controller와 View가 분리되어 요청과 응답을 각각 관리 합니다. View가 보여주는 역할을 명확히 분담하기 때문에 UI레이어가 단순해지고 Presentation 레이어의 정교한 개발이 가능합니다.

결론, 모델2 방식은 개발자와 웹 퍼블리셔의 영역을 분리할 수 있으며, 컨트롤러의 URI를 통해서 뷰를 제어하기 때문에, 뷰의 교체나 변경과 같은 유지보수에 유용하게 사용될 수 있다.

## Canvas & SVG

- Canvas: 성능이 중요한 경우 활용, 빠른 대용량 데이터 처리에 적합, 동적인 데이터
- SVG: 디자인 및 요소별 커스터마이징 가능, 다양한 해상도에 적합, 정적인 데이터

## 세션 지 쿠키 차이

웹 사이트 정보를 저장하기위한 클라이언트 로컬 저장공간. 각각의 목적과 차이!

### 세션

- 클라이언트 정보를 서버에 저장.
- 로그인 정보처럼 페이지를 이동하더라도 계속 유지되어야 하는 정보를 저장한다.
- 브라우저마다 별도 세션 가진다.
- 브라우저 종료할때까지 유지된다.
- 세션아이디를 주고 받기도 한다.
- 단점은, 서버의 메모리를 사용하는 것이기 때문에 서버자원 문제 및 서버에 있는 정보 처리가 요구되어 속도가 느려질 수 있다.
- 세션아이디만 쿠키에 저장해서 사용하면 비교적 보안에 좋다.

### 쿠키

- 서버와 클라이언트 간의 지속적인 데이터 교환 목적으로 사용한다.
- 브라우저에 파일 형태로 저장한다.
- 파일로 저장되기 때문에 브라우저 종료해도 정보는 남아 있다
- 서버 요청시마다 함께 전송되며 문자열만 저장 가능하다. (4KB)
- 서버통신에 필요없는 데이터를 전송하게되면 데이터가 낭비된다.
- 팝업창 일정기간 보이지 않기, 서버통신에 필요한 인증과 관련된 정보나 세션에 저장된 토큰값을 저장하는데 활용된다.

### 웹 스토리지(로컬스토리지 / 세션스토리지)

- 쿠키의 제한점을 보완하기 위하여 등장하였다.
- 용량도 커졌고 서버로는 전달되지 않고 브라우저 로컬에만 저장되어 보안이 보장된다.
- 윈도우객체안에 들어있다.
- 자바스크립트 객체저장이 가능하다.

### 로컬스토리지

- 삭제하기 전까지 브라우저에 계속 저장되어 있다. (10MB)

### 세션스토리지

- 세션 유지기간에만 사용하능한 스토리지로 브라우저를 종료하면 자동 소멸한다. (5MB)

## 호이스팅

함수 안에 있는 선언들을 모두 끌어올려서 해당 함수 유효 범위의 최상단에 선언하는 것을 말한다. 변수의 사용 및 함수의 실행 코드가 선언보다 먼저 일어나도 정상 진행이 되도록 해준다.

- 자바스크립트 Parser가 함수 실행 전 해당 함수를 한 번 훑는다.
- 함수 안에 존재하는 변수/함수선언에 대한 정보를 기억하고 있다가 실행시킨다.
- 유효 범위: var는 함수 블록 {} 안에서 유효

참고) var는 function-scoped이고, let, const는 block-scoped입니다.

자바스크립트 엔진이 실행 컨텍스트를 생성하면서 스코프를 정의할 때, 기술된 순서에 상관없이 선언부에 대한 처리를 해석하는 것을 의미한다. 이때 우선순위가 최우선으로 끌어올려서 먼저 해석하게 된다. 코드작성순서에 상관없이 선언구문을 최우선으로 해석한다. 따라서 변수의 사용 및 함수의 실행 코드가 선언보다 먼저 일어나도 정상 진행이 가능하다.

1. 선언 단계(Declaration phase): 변수 객체(Variable Object)에 변수를 등록한다. 이 변수 객체는 스코프가 참조할 수 있는 대상이 된다.
2. 초기화 단계(Initialization phase): 변수 객체(Variable Object)에 등록된 변수를 메모리에 할당한다. 이 단계에서 변수는 undefined로 초기화된다.
3. 할당 단계(Assignment phase): undefined로 초기화된 변수에 실제값을 할당한다.

[var 키워드 호이스팅]

var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 다시 말해 스코프 체인이 가리키는 변수 객체에 변수가 등록되고 변수는 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라한다.

[var와 let의 차이]

하지만, var 로 선언된 변수와는 달리 let 로 선언된 변수를 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다.

```js
console.log(foo); // undefined
var foo;

console.log(bar); // Error: Uncaught ReferenceError: bar is not defined
let bar;
```

이는 let 로 선언된 변수는 스코프의 시작에서 변수의 선언까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지기 때문이다. 참고로, 변수는 선언 단계 > 초기화 단계 > 할당 단계 에 걸쳐 생성되는데 var 으로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 하지만, let 로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.

[함수 선언식-호이스팅vs함수 표현식-할당]

함수선언식의 경우, 변수 객체(VO)에 함수표현식과 동일하게 함수명을 프로퍼티로 함수 객체를 할당한다는 것이다. 단, 함수선언식은 변수 객체(VO)에 함수명을 프로퍼티로 추가하고 즉시 함수 객체를 즉시 할당하지만 함수 표현식은 일반 변수의 방식을 따른다. 따라서 함수선언식의 경우, 선언문 이전에 함수를 호출할 수 있다. 이러한 현상을 함수 호이스팅(Function Hoisting)이라 한다.

---

## 자바스크립트 디자인 패턴

각기 다른 소프트웨어 모듈이나 기능을 가진 다양한 응용소프트웨어 시스템들을 개발할 때도 서로간의 공통되는 설계 문제가 존재하며 이를 처리하는 해결책 사이에도 공통점이 있습니다. 이런 유사점을 패턴이라하며 패턴은 개발시의 의사소통을 원활하게 해주는 중요한 역할을 합니다.

다음 패턴들은, 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴입니다.

[Decorator 패턴]
객체의 결합을 통해 기능을 동적으로 유연하게 확장 할 수 있습니다. 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에 각 추가 기능을 Decorator 클래스로 정의 한 후 필요한 Decorator 객체를 조합함으로써 추가 기능의 조합을 설계 하는 방식입니다. 즉, 객체에 추가적인 요건을 동적으로 첨가 합니다.

```js
var sale = new Sale(100);
sale = sale.decorate("fedtax");
sale = sale.decorate("quebec");
sale = sale.decorate("money");
sale.getPrice(); // $112.88

// 다음은 구현체입니다.
function Sale(price) {
  this.price = price || 100;
}
Sale.prototype.getPrice = function() {
  return this.price;
};

Sale.decorators = {};
Sale.decorators.fedtax = {
  getPrice: function() {
    var price = this.uber.getPrice(); // uber 는 상속된 객체
    price += (price * 5) / 100; // 5% 세율 추가

    return price;
  }
};
Sale.decorators.money = {
  getPrice: function() {
    return "$" + this.uber.getPrice().toFixed(2);
  }
};
```

[프록시 패턴]
연산을 할 때 객체 스스로가 직접 처리하지 않고 중간에 다른 '숨겨진' 객체를 통해 처리하는 방법의 디자인 패턴입니다.

데코레이터 패턴과 구현방법이 비슷하지만 차이점은, 데코레이터 패턴은 반환값에 장식을 추가 하지만 프록시 패턴은 장식을 추가 하지 않고 반환을 받는다는 차이가 있습니다. 두 패턴은 구현이 매우 유사 하지만 의도에서 분명한 차이를 보입니다.

[Mediator 패턴]
객체 간의 영향도(결합도)가 높은 상태에서는 어플리케이션의 리팩토링이 예기치 않은 결과를 나을 수 있다. 따라서, 결합도를 낮추기 위해 객체의 상태가 변경되면 Mediator 에게 먼저 전달하고 이를 Mediator 가 다른 객체에 전달하는 방식의 코딩이 가능하다.

다음 패턴들은, 클래스와 객체들이 상호작용하는 방법 및 역할을 분담하는 방법과 관련된 패턴으로 객체나 클래스 사이의 알고리즘이나 책임분배를 담당합니다. & 객체 사이의 관계

[싱글톤 패턴]
전역 변수로 사용하지 않고 객체를 하나만 생성하도록 해서 생성된 객체를 어디에서든지 참고 할수 있도록 합니다.클래스 내부에 생성된 유일한 인스턴스 이외에는 더 이상 인스턴스를 생성할 수 없는, 즉 1개의 클래스 인스턴스만 생성이 가능합니다. 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있고 또한 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽습니다. 문제점으로는, 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 "개방-폐쇄 원칙" 을 위배하게 됩니다. 멀티쓰레드환경에서 동기화처리를 안하면 인스턴스가 두개가 생성된다든지 하는 경우가 발생합니다. ex) DBCP 처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황, 로그기록 등

```js
var obj = {
  myprop: "my value"
};

var obj2 = {
  myprop: "my value"
};
obj === obj2; // false
obj == obj2; // false
```

[Observer 패턴]
한 객체의 상태변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체의 관계를 구성하는 패턴입니다. 데이터의 변경이 발생했을 경우 상대 클래스나 객체에 의존하지 않으면서 데이터 변경을 통보하고자 할 때 유용합니다. 이 패턴의 주요 목적은 객체간의 결합도를 낮추는 것입니다.

예) mouseover, keypress 와 같은 브라우저 이벤트

[Iterator 패턴]
객체의 내부구조가 복잡하더라도 개별 속성에 쉽게 접근하기 위한 패턴

```js
var element;
while ((element = agg.next())) {
  // ...
  console.log(element);
}

// 아래는 구현체입니다.
var agg = (function() {
  var index = 0,
    data = [1, 2, 3, 4, 5],
    length = data.length;

  return {
    next: function() {
      var element;
      if (!this.hasNext()) {
        return null;
      }
      element = data[index];
      index += 1;
      return element;
    },
    hasNext: function() {
      return index < length;
    },
    rewind: function() {
      index = 0;
    },
    current: function() {
      return data[index];
    }
  };
})();
```

[팩토리 패턴]
비슷한 객체를 공장에서 찍어내듯이 반복적으로 생성할 수 있게 하는 패턴입니다. 팩토리 패턴의 가장 흔한 사례는 Object() 를 이용한 객체 생성시, 주어지는 값의 타입에 따라 String, Boolean, Number 등으로 객체가 생성되는 것입니다.

팩토리 패턴의 핵심은 클래스의 인스턴스를 만드는 것을 서브클래스에서 결정하도록 한다는 것이다. 모든 팩토리 패턴에서는 객체 생성을 캡슐화한다. 팩토리 메소드 패턴과 추상 팩토리 패턴이 존재한다.

- 팩토리 메소드 패턴: 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정한다.
- 추상 팩토리 패턴 : 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다. 추상 팩토리 패턴에는 팩토리 메소드 패턴이 포함될 수 있다.

디자인 원칙 중 '추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하지 않도록 만든다.'에 기인한 패턴이다.

외,

- 덕패턴: 함께 작업이 이루어지는 파일들을 하나로 합쳐 사용
- 코로케이션: 함께 수정되는 파일들을 같이 두는 것

## 자바스크립트 함수는 일급 객체(First Class)이다.

1. 러터럴에 의해 생성
2. 변수나 배열의 요소(원소), 객체의 프로퍼티 등에 할당 가능
3. 함수의 인자로 전달 가능
4. 함수의 러턴값으로 리턴 가능
5. 동적으로 프로퍼티를 생성 및 할당 가능

## 프로그래밍 패러다임

| 명령형imperative | 선언형declarative |
| 어떻게(How) | 무엇을(What) |
| 우리가 그것을 이루는 방법 | 우리가 이루고자 하는 것 |
| 목표보다는 알고리즘 명시 | 알고리즘보다는 목표 |
| 절차지향, 객체지향 | 함수형 |

[명령형 프로그래밍]
프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식. 알고리즘을 명시하고 목표는 명시 안함.

- 절차지향 프로그래밍: 수행되어야 할 연속적인 계산 과정을 포함하는 방식 (C, C++)
- 객체지향 프로그래밍: 객체들의 집합으로 프로그램의 상호작용을 표현 (C++, Java, C#)
- 명령형 프로그램은 알고리즘을 명시하고 목표는 명시하지 않는다.
- 명령형 방법을 사용하는 경우 개발자는 컴퓨터에서 목표를 이루기 위해 수행해야 하는 단계를 매우 자세히 설명하는 코드를 작성하며, 이러한 프로그래밍을 알고리즘 프로그래밍이라고도 한다.

[선언형 프로그래밍]
어떤 방법으로 해야 하는지(How)를 나타내기보다 무엇(What)과 같은지를 설명하는 방식. 알고리즘 명시하지 않고 목표만 명시.

- 함수형 프로그래밍: 순수 함수를 조합하고 소프트웨어를 만드는 방식 (클로저, 하스켈, 리스프)
- 선언형 프로그램은 목표를 명시하고 알고리즘을 명시하지 않는 것이다.
- 선언형인 함수형 프로그래밍 패러다임은 순수하게 함수적인 접근 방법으로 문제를 해결하는 것을 지원하기 위해 만들어졌다. 함수형 방법에는 실행할 일련의 함수로 문제를 구성하는 작업이 포함된다. 함수형 프로그래밍에서는 상태와 변경 가능한 데이터를 사용하지 않으며 대신 함수의 적용을 강조한다.

## 함수형 프로그래밍 (선언형: 알고리즘 보다는 목표를)

함수형 프로그래밍의 컨셉

- 변경 가능한 상태를 불변상태(Immutab)로 만들어 SideEffect를 없애자.
- 모든 것은 객체이다.
- 코드를 간결하게 하고 가독성을 높여 구현할 로직에 집중 시키자.
- 동시성 작업을 보다 쉽게 안전하게 구현 하자.

함수형 프로그래밍(종종 줄여서 FP라고 부름)은 순수 함수(pure function) 를 조합하고 공유 상태(shared state), 변경 가능한 데이터(mutable data) 및 부작용(side-effects) 을 피하여 소프트웨어를 만드는 프로세스입니다. 함수형 프로그래밍은 명령형(imperative) 이 아닌 선언형(declarative) 이며 애플리케이션의 상태는 순수 함수를 통해 전달됩니다. 애플리케이션의 상태가 일반적으로 공유되고 객체의 메서드와 함께 배치되는 객체 지향 프로그래밍과는 대조됩니다.

참고) 순수함수? 순수 함수는 예측이 가능하고, 디버그가 쉬우며 테스트하는 것은 더욱 쉽습니다. 그들의 참조 투명성referentially transparent 덕분에, 함수 결과를 캐싱하여 반복적으로 사용 할 수 있는 메모이제이션memoization 최적화 기법이 사용 가능합니다.

- 객체지향 프로그래밍은 프로그래머들이 프로그램을 상호작용하는 객체들의 집합
- 함수형 프로그래밍은 상태값을 지니지 않는 함수값들의 연속

[명령형]

1. 횡단보도까지 약 99m 이동(성남대로331번길),
2. 횡단보도를 이용하여 경기성남분당경찰서 방면으로 횡단,
3. 횡단보도까지 1개의 횡단보도를 지나 약 612m 이동,
4. 횡단보도를 이용하여 메르세데스벤츠코리아더클래스효성분당전시장 방면으로 횡단,
5. 네이버까지 약 50m 이동(불정로).

[선언형]

1. 출발: 경기도 성남시 분당구 성남대로 333,
2. 도착: 네이버 주소는 경기도 성남시 분당구 불정로 6.

## 객체지향 프로그래밍 4가지 특징

- 추상화
- 캡슐화
- 상속
- 다형성

## 객체 지향 설계 5대 원칙

- SRP (Single Responsibility Principle) 단일 책임 원칙
- OCP (Open Closed Principle) 개방 폐쇄 원칙
- LSP (Liskov Substitution Principle) 리스코프 치환 원칙
- ISP (Interface Segregation Principle) 인터페이스 분리 원칙
- DIP (Dependency Inversion Principle) 의존 역전 원칙

## 자바스크림트의 객체지향 프로그래밍

객체는 속성(필드)과 메소드(동작)로 구성된다.

자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다. 자바스크립트를 객체지향적인 언어라고 말할 수 있는 가장 중요한 이유 중 하나는 프로토타입 상속(prototypal inheritance) 이라는 확장과 재사용을 가능하게 해주기 때문입니다.

---

## 유저에이전트

웹사이트에 접속한 사용자의 환경 디바이스정보, 운영체제, 사용하는 브라우저 등의 정보를 담고 있습니다. 브라우저와 웹 표준이 완벽하지 않아 발생하는 호환성 문제를 대응하거나 사용자의 사용환경을 파악하여 그에 맞는 컨텐츠를 제공합니다. 마케팅을 위한 용도로도 활용됩니다. 제공자 입장에서는 사용자에게 맞춰서 서비스를 제공할 수 있기 때문에 꽤 중요합니다.

## Same-Origin Policy 동일 출처 정책

브라우저 보안상 브라우저에서는 특정 도메인에서 다른 도메인의 데이터를 접근하지 못하게 막습니다. 즉, 다른 출처에서 가져온 리소스(cors)와 상호작용하는 것을 제한하는 중요한 보안 방식입니다. 이것은 잠재적 악성 문서를 격리하여, 공격 경로를 줄이는데 도움이 됩니다.

동일 출처 정책(same-origin policy) 때문에 CORS 같은 상황이 발생하면 외부서버에 요청한 데이터를 브라우저에서 보안목적으로 차단합니다. 그로 인해 정상적으로 데이터를 받을 수 없습니다.

## CORS(Cross-Origin Resource Sharing) 교차 출처 리소스 공유

CORS는 교차 출처 리소스 공유로 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제입니다. 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 교차 출처 HTTP 요청을 실행합니다. 서버 단에서 데이터 접근 권한을 허용하는 정책이라고 할 수 있습니다.

- <img> 태그로 다른 도메인의 이미지 파일을 가져오거나
- <link> 태그로 다른 도메인의 CSS를 가져오거나
- <script> 태그로 다른 도메인의 javascript를 가져오는 것
- 그 외에도 <video> <audio> <object> <embed> <applet> 태그
  에는 동일 출처 정책이 적용되지 않습니다. SOP는 script에서 XMLHttpRequest나 Fetch API를 사용해 다른 출처에 리소스를 요청할 때 적용됩니다.

cors란 도메인 또는 포트가 다른 서버의 자원을 요청하면 발생하는 이슈입니다. 서버와 클라이언트가 분리되어 있는 앱에서는 cross-origin HTTP 요청을 서버에서 승인해주는 것이 좋습니다.

[Cross-Origin HTTP 요청을 허가 해주는 방법]

- Access-Control-Allow-Origin response 헤더를 추가 모든 클라이언트에 요청에 대한 cross-origin HTTP 요청을 허가하는 헤더를 추가한다.
- 미들웨어 CORS 추가: 허락하고자 하는 요청 주소를 추가한다.

## RESTfulAPI

REST(REpresentational State Transfer)는 용어를 해석하면 대표적인 상태 전달입니다. REST란, "웹에 존재하는 모든 자원(이미지, 동영상, DB 자원)에 고유한 URI를 부여해 활용"하는 것으로, 자원을 정의하고 자원에 대한 주소를 지정하는 방법론을 의미한다고 한다. 따라서 Restful API는 REST 특징을 지키면서 API를 제공하는 것을 의미한다. (일종의 Coding Convention이랄까. 설계원칙, 가이드를 지키면서 개발을 하자는 의미인듯 싶다.)

RESTfulAPI는 HTTP프로토콜을 활용하여 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식으로 자원URI + 행위Method + 표현Json을 통해 구현합니다. 클라이언트와 서버 간에 `데이터를 주고받기 위한 URL 규칙`입니다. 리소스 자체를 전송하는 것이 아닌 리소스 표현을 전송합니다.

- 동사보다는 명사를
- 대문자보다는 소문자로
- 밑줄보다는 하이픈을

다음과 같은 특징이 있습니다.

- Uniform(한정된 인터페이스)
- Stateless(무상태성)
- Cacheable(캐시가능)

## PUT과 PATHC

- PUT: 자원의 전체 교체, 자원내 모든 필드 필요. 만약 전체가 아닌 일부만 전달할 경우, 전달한 필드외 모두 null or 초기값 처리되니 주의
- PATCH: 자원의 부분 교체, 자원내 일부 필드 필요

---

## HTTP 프로토콜 특징

HTTP(Hypertext Transfer Protocol)는 애플리케이션 계층의 프로토콜로입니다. html 같은 HyperText 문서를 전송하기 위한 통신 규약으로 클라이언트와 서버가 서로 통신하기 위한 프로토콜입니다. HTTP 프로토콜은 상태가 없는(stateless) 프로토콜입니다. 여기서 상태가 없다라는 말은 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다는 말입니다. 좀 더 쉽게 말해서 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없다는 말이죠.

비연결지향으로 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response를 보내면 바로 연결을 끊는다. 연결을 끊어버리기 때문에, 클라이언트의 이전 상황을 알 수가 없다. 이러한 특징을 무상태(Stateless)라고 말한다. 이러한 특징 때문에 정보를 유지하기 위해서 Cookie와 같은 기술이 등장하게 되었다.

---

## CSS display(요소박스를 생성x) & visibility(요소박스를 생성o)

[display]

- block: 아래 위로 블럭처럼 쌓는다.
- inline: 옆으로만 쌓는다.
- none: 나타내지 않는다. 요소박스를 생성하지 않는다.

[visibility]

- visible: 보인다. 볼 수 있다.
- hidden: 보이지 않는다. 볼 수 없다. 요소박스는 생성되었다.
- collapse: table의 행과 열을 숨긴다.

## CSS position

offset에 대한 기준을 변경한다.

- staic: 위치를 지정하지 않는다. offset은 무시된다.
- relative: 원래 위치로부터 offset으로 위치를 계산한다.
- absolute: 원래 위치 static이 아닌 가장 가까운 조상의 위치를 기준으로 하여offset으로 위치를 계산한다.
- fixed: 원래 위치와 상관없이 위치를 지정한다. 상위요소에 영향을 받지 않는다. 고정된 위치를 설정하며 브라우저의 상대위치가 기준이 된다.

[정리]

- Absolute Position(브라우저 또는 상위요소를 기준으로 배치하는 방법)
- Relative Position(자기자신을 기준으로 배치하는 방법)
- Fixed Position(스크린을 기준으로 배치하는 방법)

## TDD와 BDD

- TDD는 테스트 자체에 집중하여 검증
- BDD는 비즈니스 요구사항에 집중하여 테스트 케이스를 검증

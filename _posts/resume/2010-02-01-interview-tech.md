---
layout: post
title: 기술 면접 질문
categories: Resume
---


## js 기술면접

https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Korean/questions/javascript-questions.md



## 클로저
클로저는, 함수 자신이 포함하는 스코프의 변수들!을 추적하는 함수입니다.

- 자바스크립트 함수는, 호출되었을 때 실행되기 위한 코드뿐만 아니라, 더 많은 정보를 포함하고 있기 때문에 만들어진 환경을 기억한다고 할 수 있습니다. (이때, 메모리 소모)
- 자바스크립트 함수는, 해당 스코프에 선언되어 참조할 수 있는 어떤 변수더라도, 내부적으로 보관합니다.
- 따라서 스코프 내에 포함된 어떤 변수라도 참조할 수 있고 
- 값을 복사하지 않고 참조하고 있기 때문에 외부변수의 값을 변경 할 수도 있습니다.

- 클로저를 통해 내부 변수를 참조하는 동안에는 내부 변수가 차지하는 메모리를 GC가 회수하지 않으므로 클로저 사용이 끝나면 참조를 제거하는 것이 좋습니다.

- 클로저는 함수내의 지역변수를 감추는 은폐의 역할을 가능하게 합니다.
- 복잡한 코드를 쉽고 간결한 코드를 작성할 수 있습니다. (객체반환x, 함수반환o)
- 자바스크립트에서 클로저를 활요할 수 있는 부분은 대부분으로 가장 많이 사용되는 부분은 이벤트 그리고 비동기식 호출의 경우라고 할 수 있습니다.

```js
function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + 'px';
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById('size-12').onclick = size12;
document.getElementById('size-14').onclick = size14;
document.getElementById('size-16').onclick = size16;
```




## Canvas & SVG
- Canvas: 성능이 중요한 경우 활용, 빠른 대용량 데이터 처리에 적합, 동적인 데이터
- SVG: 디자인 및 요소별 커스터마이징 가능, 다양한 해상도에 적합, 정적인 데이터


## 세션 스토리지 쿠키 차이

웹사이 정보를 저장하기위한 클라이언트 로컬 저장공간. 각각의 목적과 차이!

### 세션

- 클라이언트 정보를 서버에 저장.
- 브라우저마다 별도 세션 가진다.
- 로그인 정보처럼 페이지를 이동하더라도 계속 유지되어야 하는 정보 저장한다.
- 브라우저 종료할때까지 유지된다.
- 세션아이디를 주고 받기도 한다.
- 단점은, 서버의 메모리를 사용하는 것이기 때문에 서버자원문제 및 정보가 서버에 있기 때문에 처리가 요구되어 속도가 느려질 수 있다.
- 세션아이디만 쿠키에 저장해서 사용하면 비교적 보안에 좋다.

### 쿠키

- 서버와 클라이언트 간의 지속적인 데이터 교환 목적으로 사용한다.
- 브라우저에 파일 형태로 저장한다.
- 서버 요청시마다 함께 전송되며 문자열만 저장 가능하다. (4KB)
- 서버통신에 필요없는 데이터를 전송하게되면 데이터가 낭비된다.
- 파일로 저장되기 때문에 브라우저 종료해도 정보는 남아 있으며 팝업창 일정기간 보이지 않기, 서버통신에 필요한 인증과 관련된 정보나 세션에 저장된 토큰값을 저장하는데 활용된다.

### 웹 스토리지(로컬스토리지 / 세션스토리지)

- 쿠키의 제한점을 보완하기 위하여 등장하였다.
- 용량도 커졌고 서버로는 전달되지 않고 브라우저 로컬에만 저장되어 보안이 보장된다.
- 윈도우객체안에 들어있다.
- 자바스크립트 객체저장이 가능하다.

### 로컬스토리지

- 삭제하기 전까지 브라우저에 계속 저장되어 있다. (10MB)

### 세션스토리지

- 세션 유지기간에만 사용하능한 스토리지로 브라우저를 종료하면 자동 소멸한다. (5MB)

## 호이스팅

자바스크립트 엔진이 실행 컨텍스트를 생성하면서 스코프를 정의할 때 기술된 순서에 상관없이 선언부에 대한 처리를 해석할때 우선순위가 최우선으로 끌어올려서 먼저 해석하게 된다. 코드작성순서에 상관없이 선언구문을 최우선으로 해석한다.

-----------

## 디자인 패턴
- 어댑터: 
- 스트레티지: 
- 옵저버: 
- 싱글톤: 
- 템플릿: 
- 팩토리: 팩토리 메소드 패턴은 객체 생성을 직접하지 않고 하위 클래스가 어떤 객체 생성을 할지 결정하도록 위임
- 프록시:
- 아토믹: 



-----------

## 검색엔진 최적화 SEO
///


-----------





## 자바스크립트 함수는 일급 객체(First Class)이다.
1. 러터럴에 의해 생성
2. 변수나 배열의 요소(원소), 객체의 프로퍼티 등에 할당 가능
3. 함수의 인자로 전달 가능
4. 함수의 러턴값으로 리턴 가능
5. 동적으로 프로퍼티를 생성 및 할당 가능

## 함수형 프로그래밍

함수형 프로그래밍(종종 줄여서 FP라고 부름)은 순수 함수(pure function) 를 조합하고 공유 상태(shared state), 변경 가능한 데이터(mutable data) 및 부작용(side-effects) 을 피하여 소프트웨어를 만드는 프로세스입니다. 함수형 프로그래밍은 명령형(imperative) 이 아닌 선언형(declarative) 이며 애플리케이션의 상태는 순수 함수를 통해 전달됩니다. 애플리케이션의 상태가 일반적으로 공유되고 객체의 메서드와 함께 배치되는 객체 지향 프로그래밍과는 대조됩니다.

- 명령형 프로그램은 알고리즘을 명시하고 목표는 명시하지 않는다.
- 명령형 방법을 사용하는 경우 개발자는 컴퓨터에서 목표를 이루기 위해 수행해야 하는 단계를 매우 자세히 설명하는 코드를 작성하며,
이러한 프로그래밍을 알고리즘 프로그래밍이라고도 한다.
- 선언형 프로그램은 목표를 명시하고 알고리즘을 명시하지 않는 것이다.
- 함수형 프로그래밍 패러다임은 순수하게 함수적인 접근 방법으로 문제를 해결하는 것을 지원하기 위해 만들어졌다. 함수형 방법에는 실행할 일련의 함수로 문제를 구성하는 작업이 포함된다. 함수형 프로그래밍에서는 상태와 변경 가능한 데이터를 사용하지 않으며 대신 함수의 적용을 강조한다.

- 객체지향 프로그래밍은 프로그래머들이 프로그램을 상호작용하는 객체들의 집합
- 함수형 프로그래밍은 상태값을 지니지 않는 함수값들의 연속

명령형.
횡단보도까지 약 99m 이동(성남대로331번길) ,
횡단보도를 이용하여 경기성남분당경찰서 방면으로 횡단,
횡단보도까지 1개의 횡단보도를 지나 약 612m 이동,
횡단보도를 이용하여 메르세데스벤츠코리아더클래스효성분당전시장 방면으로 횡단,
네이버까지 약 50m 이동(불정로).

선언형.
출발: 경기도 성남시 분당구 성남대로 333,
도착: 네이버 주소는 경기도 성남시 분당구 불정로 6.

## 객체지향 프로그래밍 4가지 특징
- 추상화
- 캡슐화
- 상속
- 다형성

객체는 속성(필드)과 메소드(동작)로 구성된다.

자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다. 자바스크립트를 객체지향적인 언어라고 말할 수 있는 가장 중요한 이유 중 하나는 프로토타입 상속(prototypal inheritance) 이라는 확장과 재사용을 가능하게 해주기 때문입니다.



## 객체 지향 설계 5대 원칙
- SRP (Single Responsibility Principle) 단일 책임 원칙
- OCP (Open Closed Principle) 개방 폐쇄 원칙
- LSP (Liskov Substitution Principle) 리스코프 치환 원칙
- ISP (Interface Segregation Principle) 인터페이스 분리 원칙
- DIP (Dependency Inversion Principle) 의존 역전 원칙


------


## 유저에이전트
웹사이트에 접속한 사용자의 환경 디바이스정보, 운영체제, 사용하는 브라우저 등의 정보를 담고 있습니다. 브라우저와 웹 표준이 완벽하지 않아 발생하는 호환성 문제를 대응하거나 사용자의 사용환경을 파악하여 그에 맞는 컨텐츠를 제공하거나 마케팅을 위한 용도로도 활용됩니다. 


## Same-Origin Policy 동일 출처 정책
브라우저 보안상 브라우저에서는 특정 도메인에서 다른 도메인의 데이터를 접근하지 못하게 막습니다. 즉, 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 중요한 보안 방식입니다. 이것은 잠재적 악성 문서를 격리하여, 공격 경로를 줄이는데 도움이 됩니다.

동일 출처 정책(same-origin policy) 때문에 CORS 같은 상황이 발생하면 외부서버에 요청한 데이터를 브라우저에서 보안목적으로 차단합니다. 그로 인해 정상적으로 데이터를 받을 수 없습니다.

## CORS(Cross-Origin Resource Sharing)

CORS는 교차 출처 리소스 공유로 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제입니다. 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 교차 출처 HTTP 요청을 실행합니다. 서버 단에서 데이터 접근 권한을 허용하는 정책이라고 할 수 있습니다.

Cross-Origin HTTP 요청을 허가 해주는 방법.
- Access-Control-Allow-Origin response 헤더를 추가 모든 클라이언트에 요청에 대한 cross-origin HTTP 요청을 허가하는 헤더를 추가한다.
- 미들웨어 CORS 추가: 허락하고자 하는 요청 주소를 추가한다.

cors이란 도메인 또는 포트가 다른 서버의 자원을 요청하면 발생하는 이슈이다.
서버와 클라이언트가 분리되어 있는 앱에서는 cross-origin HTTP 요청을 서버에서 승인해주는 것이 좋다.


## REST(자원+행위+표현)
REST(Representational State Transfer)는 자원을 이름(표현)으로 구분하며 자원의 상태(정보)를 주고 받는 것 입니다. HTTP프로토콜을 활용하여 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식으로 자원URI + 행위Method + 표현Json을 통해 구현합니다.

RESTfulAPI는 REST 기반의 서비스 API를 구현한 것으로 클라이언트와 서버 간에 `데이터를 주고받기 위한 URL 규칙`입니다.
- 동사보다는 명사를
- 대문자보다는 소문자로
- 밑줄보다는 하이픈을

## PUT과 PATHC

- PUT: 자원의 전체 교체, 자원내 모든 필드 필요. 만약 전체가 아닌 일부만 전달할 경우, 전달한 필드외 모두 null or 초기값 처리되니 주의
- PATCH: 자원의 부분 교체, 자원내 일부 필드 필요

---------

## HTTP 요청 줄이기
HTTP는 클라이언트와 서버가 서로 통신하기 위한 프로토콜로 초기 커넥션당 하나의 요청으로 인하여 동시 전송이 불가하였습니다. 파이프라이닝 기법을 통해 요청을 연속적으로 발생시켜 응답을 받았는데 다수 리소스 요청시 맨 마지막요청은 대시시간이 길어지는 문제가 여전히 발생하였습니다. HTTP2에서는 멀티플렉싱 스트림 기능으로 동시에 여러 메시지를 주고 받을 수 있게 되었습니다. 또, 리소스간 의존관계(우선순위)를 설정하여 렌더링이 늦어지는 문제를 해결하였습니다.

- 이미지스프라이팅: 큰 이미지에 좌표값을 지정한다
- 도메인 샤딩: 커넥션 수를 늘린다
- 압축: 전송되는 데이터용량을 줄인다.
- 데이터 URI스킴 사용: base64인코딩으로 이미지를 적용한다.
- HTML구조와 CSS스타일 렌더링시, 자바스크립트를 만나면 js완료전가지 렌더링이 블록된다. 스크립트 삽입 위치에 따라 스크립트 실행순서와 브라우저렌더링에 영향을 줄 수 있다. (defer는 외부자원비동기로딩 html파싱후 스크립트 실행 / async는 외부자원비동기로딩 받는 즉시 스크립트 실행)

style는 head에, javascript는 body 최하단에 위치.
기본적으로, 브라우저가 페이지를 렌더링하려면 먼저 HTML 마크업을 파싱하여 DOM을 빌드해야 합니다. 하지만 브라우저가 파싱을 하다가 스크립트 파일을 만날 경우, 스크립트 파일을 요청하고 다 불러와지는 동안 구문에 대한 분석을 중단하게 되는데, 이것이 우리가 흔히 말하는 렌더링 블록킹(Rendering Blocking) 현상입니다. 당연히 렌더링이 계속해서 블록될 시 페이지의 첫 렌더링 시간은 지연될 수 밖에 없으며, 이는 곧 좋지 않은 사용자 경험으로 이어지게 됩니다. 이와 같은 이유 때문에, style과 script 파일을 지정된 곳에 위치시켜야 한다는 것이고, 좀 더 나은 페이지의 성능을 위해 간단하지만 필수적이라고 할 수 있습니다.

## 웹 최적화 방안
로딩 최적화.
- 브라우저: 

렌더링 최적화.
- 레이아웃 스레싱: 
- 가상돔: 
- 웹워커: 




---------






## React


### 특징
- 단방향 데이터 플로우이다. 스테이트 관리 패턴. 스테이트가 꼬이지 않고 명료하게 나타난다. 
- 단순 뷰레이어가 아닌 새 패턴의 한 부분이다.
- React는 프레임워크가 아닌 라이브러리기 때문에 다른 프레임워크와 혼용 가능
- 재사용 가능한 UI 컴포넌트. 
- 모듈의 단위가 컴포넌트 인다. 컴포넌트 단위로 코드를 재사용 할 수 있다.
- 직관적인 html jsx 마크업개발자와 협업
- 컴포넌트당 클래스를 사용하므로 css캡슐화
- 화면 갱신 상태에 의존 셀렉터 필요 없음
- 목적에 맞는 컴포넌트(레이아웃으로 컨테이너/화면구성 프레젠테이셔널)구성을 통해 관리가 용이해지고 코드 공유 및 코드 재사용 가능
- Component 의 가독성이 매우 높고 간단하여 쉬운 유지보수, 간편한 UI 수정 및 재사용 용이
- React는 JavaScript 객체 형태의 Virtual DOM 을 사용하여 어플리케이션의 성능을 향상시킴 (JavaScript Virtual DOM 처리가 실제 DOM 보다 빠르기 때문)


### 단점
- 라이프사이클 잘 이해하고 사용해야 함. 꼬일 수 있음.
- 스테이트 관리 잘 해야함. 스테이트 관리를 잘 해야한다. 상황에 맞게 써야지 무턱대로 사용하면 불피요한 상태를 계속 관리하게 되어 더 복잡하다. 
- VIEW ONLY , VIEW 이외의 기능은 써드파티 라이브러리(Third party library, =패키지, 모듈로 불리기도함)를 이용하거나 직접 구현해야함
- IE8 이하 지원하지 않음 (IE8 이하 버전을 지원해야 할 경우 v0.14 버전을 사용 해야함)
-  React는 inline-template 과 JSX 를 사용하는데, 일부 개발자들에게는 적응이 안 될 수 있음


### React - Redux

Redux는 React에서 컴포넌트간의 State전달 및 관리를 편리하게 해 주는 라이브러리. Redux는 Flux라는 아키텍처를 조금 손봐서 React에서 사용하기 적합하게 만들었습니다.

React까지 필요하지 않는 기능에도 State를 맡기면 더러워지거나 오버 엔지니어링을 했던 시행착오. 규모나 상황에 따라 Redux는 선택적으로 사용하는 것이 맞다. 어떤 컴포넌트에 어떤 State를 공유 할 것인지에 대해 고민해야 합니다.

어떤 곳에서는 오히려 React의 깔끔한 구조를 깨뜨리기도 하는데 굳이 필요하지 않다면 전체적인 프로젝트의 복잡성을 낮추는데 도움이 됩니다.



### 미들웨어 thunk의 단점
미들웨어는, 액션이 디스패치(dispatch) 되어서 리듀서에서 이를 처리하기전에 사전에 지정된 작업들을 설정합니다. 미들웨어를 액션과 리듀서 사이의 중간자라고 이해할 수 있습니다.

리듀서가 액션을 처리하기전에 필요한 작업들을 미들웨어를 통해 할 수 있습니다. 만약에 특정 액션이 몇초뒤에 실행되게 하거나, 현재 상태에 따라 아예 액션이 무시되게 하고 다른 종류의 액션들을 추가적으로 디스패치 할 수도 있습니다.

redux-thunk 를 통해 만든 액션생성자는 그 내부에서 여러가지 작업을 할 수 있습니다. 이 곳에서 네트워크 요청을 해도 무방하죠. 또한, 이 안에서 액션을 여러번 디스패치 할 수도 있습니다. 그러나 단점으로는 액션쪽에 비동기통신 코드가 번잡하게 들어감에 따라 파악하기 힘듭니다. 만들면서 맘에 들지 않았던 부분은 action이 dispatch만 하는것이 아니라 로직을 담고 작업을 수행한다는 단점이 있습니다.

action의 역할 이상으로 다른 영역까지 책임을 지고 있기 때문에 뭔가 찝찝합니다.



### 기존 화면 개발의 어려움
- 데이터 업데이트에 대한 화면 변경 성능 문제
- 중복되는 페이지 유지보수 어려움
- 특히 es6 문법을 함께 사용하면서 클래서, 프로미스, 모듈내보내기 불러오기, 템플릿 리터럴등 문법이 간결하고 쉬워짐

### SPA 장점과 단점
장점.
- 사용자 친화적 (빠른 반응성, 화면전환 에니메이션 등): client rendering, router
- 상대적으로 적은 전체 트래픽 양 (Ajax, 캐쉬)
- 필요한 부분만 새로 그리고 필요한 데이터만 새로 받는다.
- 상대적으로 유지보수가 쉽고 개발속도가 빠르다. (모듈화, 컴포넌트화)
- 프론트앤드와 백앤드의 분리로 인한 개발업무 분업화 및 협업이 쉽다.


단점.
- 초기구동속도 => Lazy Loading으로 해결, 브라우저 캐쉬
SPA는 HTML, CSS, Javascript를 어플리케이션 라이프사이클에서 한번만 로드합니다. 서버와 데이터만 주고 받습니다.
- 검색엔진 최적화(SEO) => SSR로 해결
SPA는 콘텐츠를 렌더링하기 위해 JavaScript에 의존하지만 모든 검색 엔진이 크롤링 중에 JavaScript를 실행하지는 않으며 페이지에 빈 콘텐츠가 표시될 수 있습니다. 이로 인해 의도치 않게 앱의 검색 엔진 최적화(SEO)가 어려워집니다. 그러나 대부분의 경우 앱을 제작할 때 검색 엔진에서 모든 콘텐츠 색인할 필요는 없으므로 SEO가 가장 중요한 요소는 아닙니다. 이를 극복하기 위해, 앱을 서버 측 렌더링하거나 Prerender와 같은 서비스를 사용하여 "브라우저에서 JavaScript를 렌더링하고, 정적 HTML을 저장한 다음, 크롤러에게 반환합니다".
- 하얀 화면(개발자 버그) : Error Boundaries
- 자바스크립트의 메모리 부족은 어플리케이션 속도를 저하시킬 수 있습니다.


### SPA 성능 문제 개선
lazy loading으로 초기 로딩 속도 개선.
- Webpack과 같은 모듈 번들러(Module Bundler)를 사용하여 여러 파일을 하나의 파일로 통합하여 용량이 커지면, 인터넷이 느린 환경에서는 페이지 로딩속도도 느려질 것
- 지금 당장 필요한 코드가 아니라면 따로 분리시켜서, 나중에 필요할때 불러와서 사용하도록 코드스플릿 사용.
- 초기 페이지에서 모든 리소스를 다운받지 않고, 리소스를 청크(Chunk) 단위로 묶어서 해당 리소스에 대한 요청이 있을 때만 다운로드 받도록 하는 방법 lazy loading

### 컴포넌트
- Portal 컴포넌트는 논리적으로 하위 컴포넌트지만 시각적으로는 상위 컴포넌트여야 할 때 사용한다.
- React에서는 합성, Composition을 통해 컴포넌트를 재사용할 수 있다.
- Composition을 지원하는 컴포넌트의 경우 PureComponent를 사용하면 성능이 나쁠 수 있다.
- Composition을 지원하는 컴포넌트를 최적화 하고 싶으면 특수화를 적용한다.

* 컴포넌트 제대로 만들기: https://hyunseob.github.io/2019/06/02/react-component-the-right-way/


### 컴포넌트 구조
하나의 컴포넌트 파일에서 구조.

- 외부 라이브러리 및 모듈 import
- component function 선언
- useSelector나 useState를 통하여 state 초기화 및 store값 가져오기
- useEffect를 통한 component의 lifecycle 구현
- return을 통한 JSX 구현
- 컴포넌트의 propTypes, defaultProps 작성
- 컴포넌트 export

HOC.
HOC는 하나의 부품처럼 특정 컴포넌트에 기능 하나를 추가해주는 역할을 한다.

action에 맞추어 status를 관리하고 response를 저장한다.

component 에서 action의 상태에 따른 후 처리를 대응하기 위함.
1. component에서 어떠한 액션과 관련있는지 알고 싶다.
2. 액션의 상태 및 결과(success, response)에 대해서 후처리를 component에서 하고 싶다.


-----------



## oAuth 로그인

Oauth는 외부서비스의 인증 및 권한부여를 관리하는 범용적인 프로토콜입니다. OAuth는 인증뿐만 아니라 권한도 관리합니다. 사용자의 권한에 따라 접근할 수 있는 데이터가 다르도록 설정이 가능합니다.

그외 인증 방법

- 세션/쿠키, JWT를 이용한 인증
- Access Token + Refresh Token을 이용한 인증
- SNS 로그인은 간단하게 봤을 때 OAuth2.0 + 서버 인증(세션/쿠키 , 토큰기반 인증)으로 구성

(사용자 <-> 어플리케이션 서버) 인증 절차였던 세션/쿠키, 토큰 기반 인증 방식을 완전히 대체하는게 아니라는 점입니다. 즉 SNS 로그인 기능을 넣더라도 결국은 세션/쿠키 방식이나 토큰을 활용해 인증을 거쳐야 합니다.

### Authorization Code Grant 방식을 예

- Resource Owner: User, 즉 일반 사용자를 칭합니다.
- Client: 우리가 관리하는 어플리케이션 서버(User와 혼동될 수 있는데 아닙니다!)
- Authorization Server: 권한을 관리하는 서버입니다. Access Token, Refresh Token을 발급, 재발급 해주는 역할을 합니다.
- Resource Server: OAuth2.0을 관리하는 서버(Google, Facebook, Naver 등) 의 자원을 관리하는 서버입니다. 주의할 점은 우리가 만드는 서버의 자원을 관리하는 곳이 아닙니다. Oauth 2.0 관리 서버의 자체 API를 의미합니다.


---------



## CSS display 속성
- block: 아래 위로 블럭처럼 쌓는다.
- inline: 옆으로만 쌓는다.
- none: 나타내지 않는다. 요소박스를 생성하지 않는다.

## CSS visibility 속성
- visible: 보인다. 볼 수 있다.
- hidden: 보이지 않는다. 볼 수 없다. 요소박스는 생성되었다.
- collapse: table의 행과 열을 숨긴다.

## CSS position
- staic: 위치를 지정하지 않는다. offset은 무시된다.
- relative: 원래 위치로부터 offset으로 위치를 계산한다.
- absolute: 원래 위치 static이 아닌 가장 가까운 조상의 위치를 기준으로 하여offset으로 위치를 계산한다.
- fixed: 원래 위치와 상관없이 위치를 지정한다. 상위요소에 영향을 받지 않는다. 고정된 위치를 설정하며 브라우저의 상대위치가 기준이 된다.

## TDD와 BDD
- TDD는 테스트 자체에 집중하여 검증
- BDD는 비즈니스 요구사항에 집중하여 테스트 케이스를 검증

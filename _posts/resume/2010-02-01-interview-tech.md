---
layout: post
title: 기술 면접 질문
categories: Resume
---


## js 기술면접

https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Korean/questions/javascript-questions.md

## MVC(Model, View, Controller)

화면과 데이터 처리를 분리해서 재사용이 가능하도록 하는 구조

- 모델: 데이터 혹은 데이터를 처리하는 영역
- 뷰: 결과 화면을 만들어 내는 데 사용하는 자원
- 컨트롤러: 웹의 요청(request)을 처리하는 존재로 뷰와 모델 사이의 중간 통식 역할

모델 2 방식은 개발자와 웹 퍼블리셔의 영역을 분리할 수 있으며, 컨트롤러의 URI를 통해서 뷰를 제어하기 때문에, 뷰의 교체나 변경과 같은 유지보수에 유용하게 사용될 수 있다.

 
MVC1.
Controller와 View가 요청과 응답을 함께 관리 합니다. 개발 속도가 빠르고 쉬우나 단, View(프리젠테이션 로직)과 Controller(비즈니스 로직)을 모두 포함하기 때문에 페이지가 너무 복잡해 질 수 있습니다. 또 로직이 혼재되어 있기 때문에 개발자와 디자이너의 분리된 작업이 어렵습니다. 유지보수 하기 어려워지고 정교한 Presentation 레이어를 구현하는데도 어렵습니다.(유효성 체크, 에러 처리등)

MVC2.
Controller와 View가 분리되어 요청과 응답을 각각 관리 합니다. View가 보여주는 역할을 명확히 분담하기 때문에 UI레이어가 단순해지고 Presentation 레이어의 정교한 개발이 가능합니다. 



## 클로저
클로저는, 함수 자신이 포함하는 스코프의 변수들!을 추적하는 함수입니다.

- 자바스크립트 함수는, 호출되었을 때 실행되기 위한 코드뿐만 아니라, 더 많은 정보를 포함하고 있기 때문에 만들어진 환경을 기억한다고 할 수 있습니다. (이때, 메모리 소모)
- 자바스크립트 함수는, 해당 스코프에 선언되어 어떤 변수더라도, 내부적으로 보관합니다.
- 따라서 스코프 내에 포함된 어떤 변수라도 참조할 수 있고 
- 값을 복사하지 않고 참조하고 있기 때문에 외부변수의 값을 변경 할 수도 있습니다.

- 클로저를 통해 내부 변수를 참조하는 동안에는 해당 변수가 차지하는 메모리를 GC가 회수하지 않으므로 클로저 사용이 끝나면 참조를 제거하는 것이 좋습니다.

- 클로저는 함수내의 지역변수를 감추는 은폐의 역할을 가능하게 합니다.
- 복잡한 코드를 쉽고 간결한 코드를 작성할 수 있습니다. (객체반환x, 함수반환o)
- 자바스크립트에서 클로저가 많이 사용되는 부분은 이벤트 그리고 비동기식 호출의 경우라고 할 수 있습니다.

```js
function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + 'px';
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById('size-12').onclick = size12;
document.getElementById('size-14').onclick = size14;
document.getElementById('size-16').onclick = size16;
```




## Canvas & SVG
- Canvas: 성능이 중요한 경우 활용, 빠른 대용량 데이터 처리에 적합, 동적인 데이터
- SVG: 디자인 및 요소별 커스터마이징 가능, 다양한 해상도에 적합, 정적인 데이터


## 세션 스토리지 쿠키 차이

웹 사이트 정보를 저장하기위한 클라이언트 로컬 저장공간. 각각의 목적과 차이!

### 세션

- 클라이언트 정보를 서버에 저장.
- 브라우저마다 별도 세션 가진다.
- 로그인 정보처럼 페이지를 이동하더라도 계속 유지되어야 하는 정보 저장한다.
- 브라우저 종료할때까지 유지된다.
- 세션아이디를 주고 받기도 한다.
- 단점은, 서버의 메모리를 사용하는 것이기 때문에 서버자원 문제 및 서버에 있는 정보 처리가 요구되어 속도가 느려질 수 있다.
- 세션아이디만 쿠키에 저장해서 사용하면 비교적 보안에 좋다.

### 쿠키

- 서버와 클라이언트 간의 지속적인 데이터 교환 목적으로 사용한다.
- 브라우저에 파일 형태로 저장한다.
- 서버 요청시마다 함께 전송되며 문자열만 저장 가능하다. (4KB)
- 서버통신에 필요없는 데이터를 전송하게되면 데이터가 낭비된다.
- 파일로 저장되기 때문에 브라우저 종료해도 정보는 남아 있다
- 팝업창 일정기간 보이지 않기, 서버통신에 필요한 인증과 관련된 정보나 세션에 저장된 토큰값을 저장하는데 활용된다.

### 웹 스토리지(로컬스토리지 / 세션스토리지)

- 쿠키의 제한점을 보완하기 위하여 등장하였다.
- 용량도 커졌고 서버로는 전달되지 않고 브라우저 로컬에만 저장되어 보안이 보장된다.
- 윈도우객체안에 들어있다.
- 자바스크립트 객체저장이 가능하다.

### 로컬스토리지

- 삭제하기 전까지 브라우저에 계속 저장되어 있다. (10MB)

### 세션스토리지

- 세션 유지기간에만 사용하능한 스토리지로 브라우저를 종료하면 자동 소멸한다. (5MB)

## 호이스팅

자바스크립트 엔진이 실행 컨텍스트를 생성하면서 스코프를 정의할 때, 즉 기술된 순서에 상관없이 선언부에 대한 처리를 해석할때, 우선순위가 최우선으로 끌어올려서 먼저 해석하게 된다. 코드작성순서에 상관없이 선언구문을 최우선으로 해석한다.

## 실행컨텍스트
.

-----------

## 디자인 패턴
- 어댑터: 
- 스트레티지: 
- 옵저버: 
- 싱글톤: 
- 템플릿: 
- 팩토리: 팩토리 메소드 패턴은 객체 생성을 직접하지 않고 하위 클래스가 어떤 객체 생성을 할지 결정하도록 위임
- 프록시:
- 아토믹: 

외, 
- 덕패턴: 함께 작업이 이루어지는 파일들을 하나로 합쳐 사용
- 코로케이션: 함께 수정되는 파일들을 같이 두는 것


-----------

## 검색엔진 최적화 SEO
- 보안 프로토콜 적용(HTTPS): 적용을 장려하는 가산점
- 문법에 맞는 HTML 작성하기
- 구체적인 페이지 제목 만들기
- 메타 태그 활용하기
- Robots.txt: 검색엔진 알고리즘이 접근하기 쉽도록 허용
- Sitemap.xml: 크롤링과정에서 색인될 수 있게 함
- Img의 alt 속성 적용: 높은 검색 순위 적용 및 이해

-----------





## 자바스크립트 함수는 일급 객체(First Class)이다.
1. 러터럴에 의해 생성
2. 변수나 배열의 요소(원소), 객체의 프로퍼티 등에 할당 가능
3. 함수의 인자로 전달 가능
4. 함수의 러턴값으로 리턴 가능
5. 동적으로 프로퍼티를 생성 및 할당 가능

## 함수형 프로그래밍

함수형 프로그래밍(종종 줄여서 FP라고 부름)은 순수 함수(pure function) 를 조합하고 공유 상태(shared state), 변경 가능한 데이터(mutable data) 및 부작용(side-effects) 을 피하여 소프트웨어를 만드는 프로세스입니다. 함수형 프로그래밍은 명령형(imperative) 이 아닌 선언형(declarative) 이며 애플리케이션의 상태는 순수 함수를 통해 전달됩니다. 애플리케이션의 상태가 일반적으로 공유되고 객체의 메서드와 함께 배치되는 객체 지향 프로그래밍과는 대조됩니다.

- 명령형 프로그램은 알고리즘을 명시하고 목표는 명시하지 않는다.
- 명령형 방법을 사용하는 경우 개발자는 컴퓨터에서 목표를 이루기 위해 수행해야 하는 단계를 매우 자세히 설명하는 코드를 작성하며,
이러한 프로그래밍을 알고리즘 프로그래밍이라고도 한다.
- 선언형 프로그램은 목표를 명시하고 알고리즘을 명시하지 않는 것이다.
- 함수형 프로그래밍 패러다임은 순수하게 함수적인 접근 방법으로 문제를 해결하는 것을 지원하기 위해 만들어졌다. 함수형 방법에는 실행할 일련의 함수로 문제를 구성하는 작업이 포함된다. 함수형 프로그래밍에서는 상태와 변경 가능한 데이터를 사용하지 않으며 대신 함수의 적용을 강조한다.

- 객체지향 프로그래밍은 프로그래머들이 프로그램을 상호작용하는 객체들의 집합
- 함수형 프로그래밍은 상태값을 지니지 않는 함수값들의 연속

명령형.
횡단보도까지 약 99m 이동(성남대로331번길) ,
횡단보도를 이용하여 경기성남분당경찰서 방면으로 횡단,
횡단보도까지 1개의 횡단보도를 지나 약 612m 이동,
횡단보도를 이용하여 메르세데스벤츠코리아더클래스효성분당전시장 방면으로 횡단,
네이버까지 약 50m 이동(불정로).

선언형.
출발: 경기도 성남시 분당구 성남대로 333,
도착: 네이버 주소는 경기도 성남시 분당구 불정로 6.

## 객체지향 프로그래밍 4가지 특징
- 추상화
- 캡슐화
- 상속
- 다형성

객체는 속성(필드)과 메소드(동작)로 구성된다.

자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다. 자바스크립트를 객체지향적인 언어라고 말할 수 있는 가장 중요한 이유 중 하나는 프로토타입 상속(prototypal inheritance) 이라는 확장과 재사용을 가능하게 해주기 때문입니다.



## 객체 지향 설계 5대 원칙
- SRP (Single Responsibility Principle) 단일 책임 원칙
- OCP (Open Closed Principle) 개방 폐쇄 원칙
- LSP (Liskov Substitution Principle) 리스코프 치환 원칙
- ISP (Interface Segregation Principle) 인터페이스 분리 원칙
- DIP (Dependency Inversion Principle) 의존 역전 원칙


------


## 유저에이전트
웹사이트에 접속한 사용자의 환경 디바이스정보, 운영체제, 사용하는 브라우저 등의 정보를 담고 있습니다. 브라우저와 웹 표준이 완벽하지 않아 발생하는 호환성 문제를 대응하거나 사용자의 사용환경을 파악하여 그에 맞는 컨텐츠를 제공합니다. 마케팅을 위한 용도로도 활용됩니다. 


## Same-Origin Policy 동일 출처 정책
브라우저 보안상 브라우저에서는 특정 도메인에서 다른 도메인의 데이터를 접근하지 못하게 막습니다. 즉, 다른 출처에서 가져온 리소스(cors)와 상호작용하는 것을 제한하는 중요한 보안 방식입니다. 이것은 잠재적 악성 문서를 격리하여, 공격 경로를 줄이는데 도움이 됩니다.

동일 출처 정책(same-origin policy) 때문에 CORS 같은 상황이 발생하면 외부서버에 요청한 데이터를 브라우저에서 보안목적으로 차단합니다. 그로 인해 정상적으로 데이터를 받을 수 없습니다.

## CORS(Cross-Origin Resource Sharing)

CORS는 교차 출처 리소스 공유로 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제입니다. 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 교차 출처 HTTP 요청을 실행합니다. 서버 단에서 데이터 접근 권한을 허용하는 정책이라고 할 수 있습니다.

Cross-Origin HTTP 요청을 허가 해주는 방법.
- Access-Control-Allow-Origin response 헤더를 추가 모든 클라이언트에 요청에 대한 cross-origin HTTP 요청을 허가하는 헤더를 추가한다.
- 미들웨어 CORS 추가: 허락하고자 하는 요청 주소를 추가한다.

cors란 도메인 또는 포트가 다른 서버의 자원을 요청하면 발생하는 이슈이다. 서버와 클라이언트가 분리되어 있는 앱에서는 cross-origin HTTP 요청을 서버에서 승인해주는 것이 좋다.


## REST(자원+행위+표현)
REST(Representational State Transfer)는 자원을 이름(표현)으로 구분하며 자원의 상태(정보)를 주고 받는 것 입니다. HTTP프로토콜을 활용하여 분산 하이퍼미디어 시스템을 위한 소프트웨어 개발 아키텍처의 한 형식으로 자원URI + 행위Method + 표현Json을 통해 구현합니다.

RESTfulAPI는 REST 기반의 서비스 API를 구현한 것으로 클라이언트와 서버 간에 `데이터를 주고받기 위한 URL 규칙`입니다.
- 동사보다는 명사를
- 대문자보다는 소문자로
- 밑줄보다는 하이픈을

## PUT과 PATHC

- PUT: 자원의 전체 교체, 자원내 모든 필드 필요. 만약 전체가 아닌 일부만 전달할 경우, 전달한 필드외 모두 null or 초기값 처리되니 주의
- PATCH: 자원의 부분 교체, 자원내 일부 필드 필요

---------

## HTTP 프로토콜 특징
HTTP(Hypertext Transfer Protocol)는 애플리케이션 계층의 프로토콜로입니다. html 같은 HyperText 문서를 전송하기 위한 통신 규약으로 클라이언트와 서버가 서로 통신하기 위한 프로토콜입니다. HTTP 프로토콜은 상태가 없는(stateless) 프로토콜입니다. 여기서 상태가 없다라는 말은 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다는 말입니다. 좀 더 쉽게 말해서 이전 데이터 요청과 다음 데이터 요청이 서로 관련이 없다는 말이죠.

비연결지향으로 클라이언트가 request를 서버에 보내고, 서버가 클라이언트에 요청에 맞는 response를 보내면 바로 연결을 끊는다. 연결을 끊어버리기 때문에, 클라이언트의 이전 상황을 알 수가 없다. 이러한 특징을 무상태(Stateless)라고 말한다. 이러한 특징 때문에 정보를 유지하기 위해서 Cookie와 같은 기술이 등장하게 되었다.

## 웹사이트 최적화
https://hahahoho5915.tistory.com/33
- WebCache
- Code Compressing
- Image Optimizing
- Image Spriting
- Critical Rendering Path
- Webfont Optimizing
- Lazy Loading

웹 캐쉬.
client가 요청하는 Resource(html, image, js, css등)에 대해 최초 요청 시 파일을 내려받아 특정 위치에 복사본을 저장, 이후 동일한 URL의 Resource요청은 내부에 저장한 파일(캐시)을 사용하여 더 빠르게 서비스하기 위한 것 이다. 서버를 통하지 않아 응답 시간이 감소하고 네트워크 트레픽이 감소되니 잘만 사용한다면 정말 좋은일이다.

하지만 잘못 사용한다면 고객들에게 실시간으로 정보를 올바르게 주지 못하고, 오히려 고객 CS가 발생하는 등 해당 업무 프로세스와, 시스템 환경을 잘 분석하여 적용하는 것이 중요할 것이다. 

웹 캐쉬의 종류.
웹 캐쉬의 종류는 어디에 적용하느냐에 따라 다음과 같이 나뉠 수 있으며 이중 중점적으로 볼 내용은 Browser Cache입니다.

1. Browser Caches
- 브라우저 또는 HTTP요청을 하는 Client Application에 의해 내부 디스크에 캐쉬
- Cache된 Resource를 공유하지 않는 한 개인에 한정된 Cache
- 브라우저의 Back버튼 또는 이미 방문한 페이지를 재 방문하는 경우 극대화


2. Proxy Caches
- Browser Cache와 동일한 원리로 동작하며 Client나 Server가아닌 네트워크 상에서 동작.
- 큰회사나 IPS의 방화벽에 설치 되며 대기시간 & 트래픽 감소, 접근정책 & 제한 우회, 사용률 기록등 수행
- 한정된 수의 클라이언트을 위하여 무한대의 웹서버의 컨텐츠를 캐쉬

3. Gateway Caches (REVERSE OR SURROGATE PROXY)
- 서버 앞 단에 설치되어 요청에 대한 캐쉬 및 효율적인 분배를 통해 가용성, 신뢰성, 성능등을 향상
- Encryption / SSL acceleration, Load balancing, Serve/cache static content, Compression등을 수행
- 무한대의 클라이언트들에게 한정된 수(또는 하나)의 웹서버 컨텐츠를 제공

 
브라우저 캐쉬 동작.
https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#invalidating-and-updating-cached-responses
https://goddaehee.tistory.com/171

이제 캐쉬가 일어나는 과정에서 위에서 설명한 http header들이 어떻게 사용되는지 살펴보겠습니다. 

첫 요청
1. 브라우저는 서버에 index.html 파일을 요청합니다. 
2. 서버는 index.html파일을 찾아보고 존재 하는 파일이라면 파일 내용을 브라우저에게 몇 가지 header값과 함께 응답합니다.
3. 브라우저는 응답 받은 내용을 브라우저에 표시하고 응답 헤더의 내용에 따라 캐쉬 정책을 수행합니다. (응답 헤더에 Last-Modified, Etag, Expires, Cache-Control:max-age 항목이 존재 한다면 복사본을 생성하고 값을 저장)

재요청.

(validation 수행)
- REQUEST: If-Modified-Since / If-None-Match
- RESPONSE: Last-Modified / Etag


(LAST-MODIFIED)
1. 브라우저는 최초 응답 시 받은 Last-Modified 값을 If-Modified-Since 라는 헤더에 포함 시켜 페이지를 요청합니다.
2. 서버는 요청 파일의 수정 시간을 If-Modified-Since값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면 200 OK와 함께 새로운 Last-Modified값을 응답 헤더에 전송합니다.
3. 브라우저는 응답 코드가 304인경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은후 Last-Modified값을 갱신합니다.



(ETAG: ENTITY TAG)
ETag HTTP 응답 헤더는 특정 버전의 리소스를 식별하는 식별자입니다. 웹 서버가 내용을 확인하고 변하지 않았으면, 웹 서버로 full 요청을 보내지 않기 때문에, 캐쉬가 더 효율적이게 되고, 대역폭도 아낄 수 있습니다.

1. 브라우저는 최초 응답 시 받은 Etag값을 If-None-Match 라는 헤더에 포함 시켜 페이지를 요청합니다.
2. 서버는 요청 파일의 Etag값을 If-None-Match값과 비교하여 동일하다 면 304 Not Modified로 응답하고 다르다면 200 OK와 함께 새로운 Etag 값을 응답 헤더에 전송합니다.
3. 브라우저는 응답 코드가 304인경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은후 Etag값을 갱신합니다.

* Etag는 서버마다 생성하는 값이 다르며 파일마다 고유한 값을 가집니다. 
* LAST-MODIFED(1.0) 와 ETAG(1.1)는 validation을 체크 합니다. 이를 체크하기 위해 서버와 한번의 통신이 발생하게  되며 그로 인해 요청과 응답에서 header와 cookie등에 의한 데이터 전송(1KB)이 발생하게 됩니다. 

If-None-Match.
- 서버보고 ETag가 달라졌는 지 검사하고 ETag가 다를 경우에만 컨텐츠를 새로 받는다.
  ex) If-None-Match: "0-2b800-5c466dda"
- 만약 ETag가 같다면 서버는 304 Not Modified를 응답하고 캐시를 그대로 사용하게 한다.



(Expires)
1. 브라우저는 최초 응답 시 받은 Expires 시간을 비교하여 기간 내라면 서버를 거치지 않고 바로 캐쉬에서 페이지를 로드 합니다. 만약 기간이 만료되었다면 위에 설명한 validation 작업을 수행합니다.

(Cache-Control)
1. 브라우저는 최초 응답 시 받은 Cache-Control 중 max-age값(초 단위)를 GMT와 비교하여 기간 내라면 서버를 거치지 않고 캐쉬에서 페이지를 로드합니다. 만약 기간이 만료되었다면 validation 작업을 수행합니다.

 
* Expires(1.0)와 Cache-Control: max-age(1.1)는 freshness를 체크합니다. 기간 내라면 서버와 통신을 하지 않고 캐쉬를 사용합니다.
* 시간은 HTTP date 형태이며 로컬 타임이 아닌 GMT를 사용합니다.
* 서버가 Last Modified Time 또는 Last Access Time을 기준으로 하여 일정 시간 이후로 Expires 또는 max-age를 설정 합니다.

 

## CACHING STRATEGY 
캐쉬가 잘 적용되게 하기 위해서 다음과 같은 전략을 새웁니다.

1. 일관된 URL을 사용하라. 동일한 URL은 동일한 사이트라면 다른 페이지에서도 캐쉬되어 사용될 수 있습니다.
2. 자주 바뀌는 파일과 그렇지 않은 파일을 분리합니다. 그래야 각 Resource에 대해 최적의 freshness를 설정할 수 있습니다.
3. 다운가능한 파일의 내용이 바뀌면 이름(URL)을 바꿉니다. 그래야 올바로 수정된 버전을 제공할 수 있습니다.
4. SSL을 최소화 합니다. 암호화된 페이지는 캐쉬되지 않습니다.



## 웹 최적화 방안
https://estrella-kim.github.io/frontend_performance_optimization

로딩 최적화.
- 브라우저: 

렌더링 최적화.
- 레이아웃 스레싱: 
- 가상돔: 
- 웹워커: 

## HTTP 요청 줄이기
초기 커넥션당 하나의 요청으로 인하여 동시 전송이 불가하였습니다. 파이프라이닝 기법을 통해 요청을 연속적으로 발생시켜 응답을 받았는데 다수 리소스 요청시 맨 마지막요청은 대시시간이 길어지는 문제가 여전히 발생하였습니다. HTTP2에서는 멀티플렉싱 스트림 기능으로 동시에 여러 메시지를 주고 받을 수 있게 되었습니다. 또, 리소스간 의존관계(우선순위)를 설정하여 렌더링이 늦어지는 문제를 해결하였습니다.

- 이미지스프라이팅: 큰 이미지에 좌표값을 지정한다
- 도메인 샤딩: 커넥션 수를 늘린다
- 압축: 전송되는 데이터용량을 줄인다.
- 데이터 URI스킴 사용: base64인코딩으로 이미지를 적용한다.
- HTML구조와 CSS스타일 렌더링시, 자바스크립트를 만나면 js완료전가지 렌더링이 블록된다. 스크립트 삽입 위치에 따라 스크립트 실행순서와 브라우저렌더링에 영향을 줄 수 있다. (defer는 외부자원비동기로딩 html파싱후 스크립트 실행 / async는 외부자원비동기로딩 받는 즉시 스크립트 실행)

style는 head에, javascript는 body 최하단에 위치.
기본적으로, 브라우저가 페이지를 렌더링하려면 먼저 HTML 마크업을 파싱하여 DOM을 빌드해야 합니다. 하지만 브라우저가 파싱을 하다가 스크립트 파일을 만날 경우, 스크립트 파일을 요청하고 다 불러와지는 동안 구문에 대한 분석을 중단하게 되는데, 이것이 우리가 흔히 말하는 렌더링 블록킹(Rendering Blocking) 현상입니다. 당연히 렌더링이 계속해서 블록될 시 페이지의 첫 렌더링 시간은 지연될 수 밖에 없으며, 이는 곧 좋지 않은 사용자 경험으로 이어지게 됩니다. 이와 같은 이유 때문에, style과 script 파일을 지정된 곳에 위치시켜야 한다는 것이고, 좀 더 나은 페이지의 성능을 위해 간단하지만 필수적이라고 할 수 있습니다.





---------






## React

### 생명주기
- counstructor
- `componentWillMount`(v17 defrecated)
- render
- componentDidMount
- `componentwillReceiveProps(nextProps)`(v17 defrecated)
- shouldComponentUpdate(nextProps, nextState)
- `componentWillUpdate`(v17 defrecated)
- render
- componentDidUpdate(prevProps, prevState)
- componentWillUnmount


counstructor.
컴포넌트가 처음 만들어 질때 실행됩니다. 기본 state를 설정할 수 있습니다.

componentWillMount.
컴포넌트가 DOM위에 만들어지기 전에 실행 됩니다. 따라서 DOM을 처리할 수 없습니다. render가 호출되기 전이기 때문에 setState를 사용해도 render가 호출하지 않습니다. (v17 defrecated에서 삭제)

render.
화면 렌더링을 담당 합니다.

componentDidMount.
첫 렌더링 후 실행됩니다. 이 안에서 다른 js프레임웍 연동 및 setTimeout, setInterval 및 Ajax를 사용합니다.

componentwillReceiveProps(nextProps).
props를 받을 때 실행됩니다. props에 따라 state를 업데이트 할 때 사용하면 유용합니다. 이 안에서 setState할 수 있지만 추가적인 렌더링은 발생하지 않습니다. 컴포넌트가 처음 마운트 되는 시점에서는 호출되지 않습니다. (v17 defrecated - getDerivedStateFromProps로 대체됨)

shouldComponentUpdate(nextProps, nextState).
props/state가 변경되었을때 리 렌더링을 할지 말지를 결정합니다. 실제로 사용할때는 필요한 비교를 하고 값을 반환해야 합니다. 쓸데없는 렌더링을 걸러낼 수 있습니다.

shouldComponentUpdate 메쏘드를 별도로 선언하지 않았다면, 컴포넌트는 props, state 값이 변경되면 항상 리렌더링(re-render) 하도록 되어 있다.

순수컴포넌트(PureComponent): shouldComponentUpdat함수는 상태(state, props)가 변경될 때, 얕은 비교를 통하여 리렌더링의 유무를 결정합니다. 상태변화에 대한 비교없이 무조건 불필요한 리렌더링을 수행하는 일반 컴포넌트보다는 필요한 경우에만 렌더링을 수행하므로써, 성능을 개선할 수 있는 이점이 있습니다. 


ex) return nextProps.id !== this.props.id (이때 JSON.stringify를 사용하여 여러 field를 편하게 비교 할 수 있습니다.)

componentWillUpdate(prevProps, prevState).
컴포넌트 업데이트 직전 실행됩니다. setState는 절대로 사용하면 안됩니다. 무한 루프에 빠질수 있습니다. (v17 defrecated - getSnapshotBeforeUpdate로 대체됨)

componentDidUpdate(prevProps, prevState).
컴포넌트 업데이트 직후 실행됩니다. setState는 절대로 사용하면 안됩니다. 무한 루프에 빠질수 있습니다.

componentWillUnmount.
컴포넌트가 DOM에서 사라진 후 실행됩니다. 컴포넌트 내부에서 타이머나 비동기 API를 사용하고 있을 때, 이를 제거하기에 유용합니다.

### 특징
- 단방향 데이터 플로우이다. 스테이트 관리 패턴. 스테이트가 꼬이지 않고 명료하게 나타난다. 
- 단순 뷰레이어가 아닌 새 패턴의 한 부분이다.
- React는 프레임워크가 아닌 라이브러리기 때문에 다른 프레임워크와 혼용 가능
- 재사용 가능한 UI 컴포넌트. 
- 모듈의 단위가 컴포넌트 인다. 컴포넌트 단위로 코드를 재사용 할 수 있다.
- 직관적인 html jsx 마크업개발자와 협업
- 컴포넌트당 클래스를 사용하므로 css캡슐화
- 화면 갱신 상태에 의존 셀렉터 필요 없음
- 목적에 맞는 컴포넌트(레이아웃으로 컨테이너/화면구성 프레젠테이셔널)구성을 통해 관리가 용이해지고 코드 공유 및 코드 재사용 가능
- Component 의 가독성이 매우 높고 간단하여 쉬운 유지보수, 간편한 UI 수정 및 재사용 용이
- React는 JavaScript 객체 형태의 Virtual DOM 을 사용하여 어플리케이션의 성능을 향상시킴 (JavaScript Virtual DOM 처리가 실제 DOM 보다 빠르기 때문)


### 단점
- 라이프사이클 잘 이해하고 사용해야 함. 꼬일 수 있음.
- 스테이트 관리 잘 해야함. 스테이트 관리를 잘 해야한다. 상황에 맞게 써야지 무턱대로 사용하면 불피요한 상태를 계속 관리하게 되어 더 복잡하다. 
- VIEW ONLY , VIEW 이외의 기능은 써드파티 라이브러리(Third party library, =패키지, 모듈로 불리기도함)를 이용하거나 직접 구현해야함
- IE8 이하 지원하지 않음 (IE8 이하 버전을 지원해야 할 경우 v0.14 버전을 사용 해야함)
-  React는 inline-template 과 JSX 를 사용하는데, 일부 개발자들에게는 적응이 안 될 수 있음


### React - Redux

Redux는 React에서 컴포넌트간의 State전달 및 관리를 편리하게 해 주는 라이브러리. Redux는 Flux라는 아키텍처를 조금 손봐서 React에서 사용하기 적합하게 만들었습니다.

React까지 필요하지 않는 기능에도 State를 맡기면 더러워지거나 오버 엔지니어링을 했던 시행착오. 규모나 상황에 따라 Redux는 선택적으로 사용하는 것이 맞다. 어떤 컴포넌트에 어떤 State를 공유 할 것인지에 대해 고민해야 합니다.

어떤 곳에서는 오히려 React의 깔끔한 구조를 깨뜨리기도 하는데 굳이 필요하지 않다면 전체적인 프로젝트의 복잡성을 낮추는데 도움이 됩니다.



### 미들웨어 thunk의 단점
미들웨어는, 액션이 디스패치(dispatch) 되어서 리듀서에서 이를 처리하기전에 사전에 지정된 작업들을 설정합니다. 미들웨어를 액션과 리듀서 사이의 중간자라고 이해할 수 있습니다.

리듀서가 액션을 처리하기전에 필요한 작업들을 미들웨어를 통해 할 수 있습니다. 만약에 특정 액션이 몇초뒤에 실행되게 하거나, 현재 상태에 따라 아예 액션이 무시되게 하고 다른 종류의 액션들을 추가적으로 디스패치 할 수도 있습니다.

redux-thunk 를 통해 만든 액션생성자는 그 내부에서 여러가지 작업을 할 수 있습니다. 이 곳에서 네트워크 요청을 해도 무방하죠. 또한, 이 안에서 액션을 여러번 디스패치 할 수도 있습니다. 그러나 단점으로는 액션쪽에 비동기통신 코드가 번잡하게 들어감에 따라 파악하기 힘듭니다. 만들면서 맘에 들지 않았던 부분은 action이 dispatch만 하는것이 아니라 로직을 담고 작업을 수행한다는 단점이 있습니다.

action의 역할 이상으로 다른 영역까지 책임을 지고 있기 때문에 뭔가 찝찝합니다.



### 기존 화면 개발의 어려움
- 데이터 업데이트에 대한 화면 변경 성능 문제
- 중복되는 페이지 유지보수 어려움
- 특히 es6 문법을 함께 사용하면서 클래서, 프로미스, 모듈내보내기 불러오기, 템플릿 리터럴등 문법이 간결하고 쉬워짐

### SPA 장점과 단점
장점.
- 사용자 친화적 (빠른 반응성, 화면전환 에니메이션 등): client rendering, router
- 상대적으로 적은 전체 트래픽 양 (Ajax, 캐쉬)
- 필요한 부분만 새로 그리고 필요한 데이터만 새로 받는다.
- 상대적으로 유지보수가 쉽고 개발속도가 빠르다. (모듈화, 컴포넌트화)
- 프론트앤드와 백앤드의 분리로 인한 개발업무 분업화 및 협업이 쉽다.


단점.
- 초기구동속도 => Lazy Loading으로 해결, 브라우저 캐쉬
SPA는 HTML, CSS, Javascript를 어플리케이션 라이프사이클에서 한번만 로드합니다. 서버와 데이터만 주고 받습니다.
- 검색엔진 최적화(SEO) => SSR로 해결
SPA는 콘텐츠를 렌더링하기 위해 JavaScript에 의존하지만 모든 검색 엔진이 크롤링 중에 JavaScript를 실행하지는 않으며 페이지에 빈 콘텐츠가 표시될 수 있습니다. 이로 인해 의도치 않게 앱의 검색 엔진 최적화(SEO)가 어려워집니다. 그러나 대부분의 경우 앱을 제작할 때 검색 엔진에서 모든 콘텐츠 색인할 필요는 없으므로 SEO가 가장 중요한 요소는 아닙니다. 이를 극복하기 위해, 앱을 서버 측 렌더링하거나 Prerender와 같은 서비스를 사용하여 "브라우저에서 JavaScript를 렌더링하고, 정적 HTML을 저장한 다음, 크롤러에게 반환합니다".
- 하얀 화면(개발자 버그) : Error Boundaries
- 자바스크립트의 메모리 부족은 어플리케이션 속도를 저하시킬 수 있습니다.


### SPA 성능 문제 개선
lazy loading으로 초기 로딩 속도 개선.
- Webpack과 같은 모듈 번들러(Module Bundler)를 사용하여 여러 파일을 하나의 파일로 통합하여 용량이 커지면, 인터넷이 느린 환경에서는 페이지 로딩속도도 느려질 것
- 지금 당장 필요한 코드가 아니라면 따로 분리시켜서, 나중에 필요할때 불러와서 사용하도록 코드스플릿 사용.
- 초기 페이지에서 모든 리소스를 다운받지 않고, 리소스를 청크(Chunk) 단위로 묶어서 해당 리소스에 대한 요청이 있을 때만 다운로드 받도록 하는 방법 lazy loading

### 컴포넌트
- Portal 컴포넌트는 논리적으로 하위 컴포넌트지만 시각적으로는 상위 컴포넌트여야 할 때 사용한다.
- React에서는 합성, Composition을 통해 컴포넌트를 재사용할 수 있다.
- Composition을 지원하는 컴포넌트의 경우 PureComponent를 사용하면 성능이 나쁠 수 있다.
- Composition을 지원하는 컴포넌트를 최적화 하고 싶으면 특수화를 적용한다.

* 컴포넌트 제대로 만들기: https://hyunseob.github.io/2019/06/02/react-component-the-right-way/


### 컴포넌트 구조
하나의 컴포넌트 파일에서 구조.

- 외부 라이브러리 및 모듈 import
- component function 선언
- useSelector나 useState를 통하여 state 초기화 및 store값 가져오기
- useEffect를 통한 component의 lifecycle 구현
- return을 통한 JSX 구현
- 컴포넌트의 propTypes, defaultProps 작성
- 컴포넌트 export

HOC.
HOC는 하나의 부품처럼 특정 컴포넌트에 기능 하나를 추가해주는 역할을 한다.

action에 맞추어 status를 관리하고 response를 저장한다.

component 에서 action의 상태에 따른 후 처리를 대응하기 위함.
1. component에서 어떠한 액션과 관련있는지 알고 싶다.
2. 액션의 상태 및 결과(success, response)에 대해서 후처리를 component에서 하고 싶다.


-----------



## oAuth 로그인

Oauth는 외부서비스의 인증 및 권한부여를 관리하는 범용적인 프로토콜입니다. OAuth는 인증뿐만 아니라 권한도 관리합니다. 사용자의 권한에 따라 접근할 수 있는 데이터가 다르도록 설정이 가능합니다.

그외 인증 방법

- 세션/쿠키, JWT를 이용한 인증
- Access Token + Refresh Token을 이용한 인증
- SNS 로그인은 간단하게 봤을 때 OAuth2.0 + 서버 인증(세션/쿠키 , 토큰기반 인증)으로 구성

(사용자 <-> 어플리케이션 서버) 인증 절차였던 세션/쿠키, 토큰 기반 인증 방식을 완전히 대체하는게 아니라는 점입니다. 즉 SNS 로그인 기능을 넣더라도 결국은 세션/쿠키 방식이나 토큰을 활용해 인증을 거쳐야 합니다.

### Authorization Code Grant 방식을 예

- Resource Owner: User, 즉 일반 사용자를 칭합니다.
- Client: 우리가 관리하는 어플리케이션 서버(User와 혼동될 수 있는데 아닙니다!)
- Authorization Server: 권한을 관리하는 서버입니다. Access Token, Refresh Token을 발급, 재발급 해주는 역할을 합니다.
- Resource Server: OAuth2.0을 관리하는 서버(Google, Facebook, Naver 등) 의 자원을 관리하는 서버입니다. 주의할 점은 우리가 만드는 서버의 자원을 관리하는 곳이 아닙니다. Oauth 2.0 관리 서버의 자체 API를 의미합니다.


---------



## CSS display 속성
- block: 아래 위로 블럭처럼 쌓는다.
- inline: 옆으로만 쌓는다.
- none: 나타내지 않는다. 요소박스를 생성하지 않는다.

## CSS visibility 속성
- visible: 보인다. 볼 수 있다.
- hidden: 보이지 않는다. 볼 수 없다. 요소박스는 생성되었다.
- collapse: table의 행과 열을 숨긴다.

## CSS position
- staic: 위치를 지정하지 않는다. offset은 무시된다.
- relative: 원래 위치로부터 offset으로 위치를 계산한다.
- absolute: 원래 위치 static이 아닌 가장 가까운 조상의 위치를 기준으로 하여offset으로 위치를 계산한다.
- fixed: 원래 위치와 상관없이 위치를 지정한다. 상위요소에 영향을 받지 않는다. 고정된 위치를 설정하며 브라우저의 상대위치가 기준이 된다.

## TDD와 BDD
- TDD는 테스트 자체에 집중하여 검증
- BDD는 비즈니스 요구사항에 집중하여 테스트 케이스를 검증


-----------

## TCP/IP의 개념
어디서 출발하는지, 어디로 향하는 지에대해 최적의 경로를 선택하는것이 IP를 통해서 이루어진다면 그 전에 어떻게 데이터를 전송할 것인가에 대한 규약이 필요하다. 어떻게 패킷을 분할하고 조합할 것인가에 대한 규약중 가장 자주 사용되는 것이 TCP이다.

네트워크에서 전달하는 데이터의 최소단위를 패킷이라고 하는데 이 패킷은 이쪽 네트워크에서 저쪽 네트워크로 날로 던지지 않는다. 패킷이 전달되기 위해서는 포장하는 과정을 거쳐야하는데 TCP는 패킷을 어떻게 포장할것인가에 대한 약속이다. 패킷은 일련의 순서로 포장되어 보내지고, 받을 때는 반대로 해석된다.


- TCP/IP는 네트워크를 상호 연결시켜 정보를 전송 할 수 있도록 하는 기능을 가진 다수의 프로토콜이 모여있는 프로토콜 집합
- 인터넷은 데이터 링크 계층을 지원하는 네트워크를 TCP/IP 프로토콜을 이용하여 상호 연결하는 네트워크
- 인터넷 상의 서로 다른 운영체제를 쓰는 컴퓨터간 데이터 전송을 가능하게 하는 정보전송을 위한 인터넷 표준 프로토콜


## 비동기통신과 동기통신의 차이점
동기식 통신은 통신에 참여하는 노드 모두가 시간을 동기화해서 전송하는 걸 말함(예를들면, 면접진행시 15분씩 1명씩 진행하는걸 생각하면됨)

비동기식은 시간을 안맞추는 대신 전송전에 연결을 맺는 등의 오버헤드를 가짐.(예를들면, 내가 말하기전에 너 들을준비 되었니? 통보하고 말하는거임)


## HTTP와 HTTPS
HTTP(HyperText Transfer Protocol) 프로토콜.
웹상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고 받을 수 있는 프로토콜
동작순서: TCP -> HTTP

HTTPS(Hypertext Transfer Protocol over Secure Socket Layer) 프로토콜.
웹 통신 프로토콜인 HTTP의 보안이 강화된 버전으로 HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다. 따라서 데이터의 적절한 보호를 보장한다. HTTPS의 기본 TCP/IP포트는 443이다. 모든사이트가 HTTPS를 안쓰는 이유는? 암호화에 따른 속도저하때문.

SSL 프로토콜은 테리사(Terrsa)가 개발해 Netscape사가 NetSite의 암호화 중심 프로토콜로 정착시킨 기술로 정보 암호화시 공개키(Pubilc Key)와 개인키(Private Key)라는 두가지 키를 이용하는 방법. https 란 인터넷 상에서 정보를 암호화하는 SSL(Secure Socket Layer) 프로토콜을 이용하여 데이터를 전송하고 있다는 것을 의미.

동작순서: TCP -> SSL -> HTTP


 


 

 
---
layout: post
title: TODO
categories: TODO
---

## 컨테이닝 블럭
요소의 크기와 위치는 컨테이닝 블록(containing block)의 영향을 받곤 합니다. 대부분의 경우, 어떤 요소의 컨테이닝 블록은 가장 가까운 블록 레벨 조상의 콘텐츠 영역이나, 항상 그런 것은 아닙니다. 이 글에서는 요소의 컨테이닝 블록을 결정하는 요인을 살펴보겠습니다.

https://developer.mozilla.org/ko/docs/Web/CSS/All_About_The_Containing_Block

# z-index
z-index 프로퍼티는 position 프로퍼티가 static이외인 요소에만 적용된다.
https://poiemaweb.com/css3-position

# 레이어 중앙정렬
https://wit.nts-corp.com/2014/08/22/2004

## 루프백


## 라우드
- https://zitto15.tistory.com/27

## 객체지향
- https://gmlwjd9405.github.io/2018/07/05/oop-solid.html

동기 비동기 면접?
형변환 넘버와 파스 차이
xss
xdr정리

테스트 종류 및 언제사용?
https://tiffany.devpools.kr/2018/03/19/sinon/

js 부동소수점
toFixed
toExponal?

https://github.com/Lee-hyuna/33-js-concepts-kr/wiki/%EB%AA%A8%EB%93%A0-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%95%8C%EC%95%84%EC%95%BC%ED%95%98%EB%8A%94-%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90

https://wormwlrm.github.io/2020/08/12/History-of-JavaScript-Modules-and-Bundlers.html
AMD 모듈
CommonJS 모듈
ECMAScript 하모니 모듈

참고) 모듈을 불러오는 다양한 방법

- ES6 Modules(ESM): import
- CommonJS: require
- AMD: define - require
- Browser: <script src="...">
  (이 외에도 System.js, Require.js 등의 모듈 로더등이 있다)

### 바벨?에서의 모듈 변환!!

## 접근성

aria-hidden
tab

/\*
TabPane을 사용하는 경우, 접근성을 포함하여 정의되어야 하는 속성
[List 영역]

1. id="{ID}"를 부여 tabpanel 의 aria-labelledby="{ID}" 연결 본문의 제목으로 인식시킴
2. role="tab"을 사용하여 탭메뉴의 탭요소 역할 부여
3. aria-controls="{ID}"를 사용하여 해당 탭의 본문과 연결
4. aria-selected="{boolen}"를 사용하여 해당 탭의 선택유무 명시
   [Contents 영역]
5. role="tabpanel"을 사용하여 탭메뉴의 본문 역할 부여
6. aria-labelledby="{ID}"를 사용하여 탭메뉴와 본문 연결
   \*/
   // role="tablist" > role="presentation" > role="tab"
   // role="tabpanel"

https://developers.google.com/web/fundamentals/accessibility/semantics-aria/hiding-and-updating-content?hl=ko

## requestAnimationFrame

브라우저가 렌더링 할 수 있는 능력에 따라 이벤트를 트리거 해주는 함수입니다.

https://m.blog.naver.com/PostView.nhn?blogId=dndlab&logNo=221633637425&proxyReferer=https:%2F%2Fwww.google.com%2F
https://codepen.io/jaehee/pen/BvzJOR

## 정규식 정리

자주 사용하는 애들

## target 가상 클래스

요소 id와 url에 있는 #가 같을때 적용
https://aboooks.tistory.com/309

https://codepen.io/kirkgleffe/pen/DfvuE

## Intersection Observer

문제는 2016년에 Intersection Observer API가 소개되면서 해결되었다. 이를 통해 단순히 뷰포트에 남아있는지뿐만 아니라, 한 요소가 그 요소의 어떤 부모라도 겹치는지 여부를 확인할 수 있다. 추가로, 요소 단 1픽셀이라도 겹치는지까지 확인할 수 있다.

const observer = new IntersectionObserver(callback, options);

observer.observe(element);

## ani

https://www.youtube.com/watch?v=bEoLCZzWZX8&feature=youtu.be
https://speakerdeck.com/lonekorean/silky-smooth-animation-with-css?slide=5
https://wit.nts-corp.com/2017/06/05/4571

## reflow & will-change

애니메이션은 CSS 속성 중 margin, height을 사용하여 구현했습니다. 하지만 애니메이션이 부자연스러운 현상이 있어 자료를 찾아보니 margin, height 속성은 애니메이션에 사용했을 때 성능 저하를 유발하는 속성 중 하나였습니

언뜻 보이게는 애니메이션이 잘 적용된 것으로 보입니다. 하지만 여기에 애니메이션으로 사용하면 안되는 CSS 속성이 추가되어 있습니다.

왼쪽으로 축소: margin(성능 문제)
아래쪽으로 천천히 확장: height(성능 문제)
fade in / fade-out: opacity
‘X’ 버튼 회전: rotate
‘↑↓’ 버튼 아래쪽으로 이동: translateY

UX 엔지니어이자 자바스크립트 개발자인 윌 보이드(Will Boyd)는 조금 더 부드러운 애니메이션을 만들 수 있는 방법과 그 예시를 소개하였습니다.(참고 영상, 참고 슬라이드)
“브라우저에서 하나의 애니메이션 프레임을 처리한다는 것은 애니메이션 구현에 필요한 모든 계산 과정과 계산을 통해 얻어진 픽셀 자리를 업데이트 하는 것까지 포함합니다. 목표는 브라우저가 이 과정에서 할일을 최대로 줄여서 초당 60프레임 정도의 부드러운 애니메이션을 만드는 것입니다. CSS 애니메이션 구현 비용과 직접적으로 연관되어 있는 것은 재조정(reflow)와 재색칠(repaint)를 일으키지 않는 속성들입니다.”
즉, 부드러운 애니메이션을 적용하려면 reflow와 repaint를 최소화 시켜야 합니다.

https://wit.nts-corp.com/2017/06/05/4571

## 브라우저 성능

https://d2.naver.com/helloworld/5237120

https://gloriajun.github.io/frontend/2018/10/23/frontend-reflow-repaint.html
https://d2.naver.com/helloworld/2922312

너무너무 중요
https://12bme.tistory.com/140

# raf

/\*  
// https://csstriggers.com/
// https://trendyminds.com/blog/silky-css-minimizing-repaints-jank
// https://developer.mozilla.org/ko/docs/Web/API/Window/requestAnimationFrame
// https://medium.com/@paul_irish/requestanimationframe-scheduling-for-nerds-9c57f7438ef4
// https://m.blog.naver.com/PostView.nhn?blogId=dndlab&logNo=221633637425&proxyReferer=https:%2F%2Fwww.google.com%2F
[requestAnimationFrame] -> 브라우저가 초당 렌더링하는 횟수를 보장
: 비동기 함수이다. 브라우저가 실행 시기를 결정한다. 스스로 반복해서 호출하지 않는다.
스스로를 반복 호출하지 않기 때문에 window.requestAnimationFrame 함수로 다음 함수를 반복하려면,
재귀적으로 window.requestAnimationFrame 함수를 다시 호출해 주어야 한다.

- setTimeout은 tast queue에 stack 쌓임
- requestAnimationFrame: animation frames 라는 queue에 stack 쌓임(task보다 먼저 실행됨)

---

[함수 호출]
브라우저에게 수행하기를 원하는 애니메이션을 알리고,
다음 리페인트가 진행되기 전에 해당 애니메이션을 업데이트하는 함수를 호출한다.
따라서 인자는! 리페인트 이전에 실행할 콜백이어야 한다.

---

[스타일 속성 예]

- repaint: background-color
- reflow: height

화면에 새로운 애니메이션을 업데이트할 준비가 될때마다 이 메소드를 호출하는것이 좋습니다.
이는 브라우저가 다음 리페인트를 수행하기전에 호출된 애니메이션 함수를 요청합니다.
콜백의 수는 보통 1초에 60회지만, 일반적으로 대부분의 브라우저에서는 W3C 권장사항에 따라 그 수가 디스플레이 주사율과 일치하게됩니다.
\*/

## ㄷㅍent passiv

https://amati.io/eventlisteneroptions-passive-true/

자바스크립트에 addEventListener()를 통해 등록된 이벤트는 컴포지터 스레드가 받습니다. 이벤트가 들어오면 컴포지터 스레드는 메인 스레드에 이벤트를 넘기고 렌더링 파이프라인에 따라 layout, paint를 거쳐 Layout tree를 기다리는 것이 원래의 동작입니다.

EventListenerOptions 의 속성 중 passive 속성이 바로 이 파이프라인과 관계가 있습니

{ passive:true } 의 진정한 의미는 이벤트를 받는 컴포지터 스레드에 해당 이벤트가 메인 스레드의 처리를 기다리지 않고 바로 Composite를 수행해도 된다는 힌트를 주는 것입니다.

그 이유는 { passive:true } 힌트를 통해 컴포지터 스레드가 메인 스레드의 처리를 기다리지 않고 바로 합성해야 하는데, listener 함수에 있는 e.preventDefault()는 스크롤을 막고 메인 스레드에서 처리를 해야하는 메소드이기 때문입니다.

## 웹최적화방식

https://black7375.tistory.com/72

## 함수형 컴포넌트와 클래스, 어떤 차이가 존재할까?

https://overreacted.io/ko/how-are-function-components-different-from-classes/

## IE

https://aboooks.tistory.com/357

https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-iedoco/3764531c-97c8-4bf2-bdc6-b3623738ea46

쿼크 모드는 오래된 웹 브라우저를 위하여 디자인된 웹 페이지의 하위 호환성을 유지하기 위해 W3C나 IETF의 표준을 엄격히 준수하는 표준 모드를 대신하여 쓰이는 웹 브라우저 기술을 가리킨다. 같은 코드라도 웹 브라우저마다 서로 다르게 해석하므로 전혀 다른 결과물을 보여주게 된다. 위키백과

x-ua-compatible
지정할 경우, content 특성의 값은 반드시 "IE=edge"여야 합니다. 사용자 에이전트는 이 프래그마를 무시해야 합니다.

    <meta http-equiv="X-UA-Compatible" content="IE=edge">

## 바벨 루즈

https://babeljs.io/docs/en/babel-plugin-proposal-class-properties

loose
boolean, 기본값은 false입니다.

때 true, 클래스 속성 대신의 할당 식을 사용하여 컴파일됩니다 Object.defineProperty.

이 없으면 { "loose": true }위 코드는 다음을 사용하여 다음과 같이 컴파일됩니다 Object.defineProperty.
Object.defineProperty(Bork, "a", {
configurable: true,
enumerable: true,
writable: true,
value: 'foo'
});

var Bork = function Bork() {
babelHelpers.classCallCheck(this, Bork);
this.x = 'bar';
this.y = void 0;
};

Bork.a = 'foo';
Bork.b = void 0;

그러나에서는 { "loose": true }할당 표현식을 사용하여 컴파일됩니다.

## 쌓임맥락

아 왜 맨날 모르겠지? 왜냐면 확실히 모르니까

- mdn
- https://css-tricks.com/stacking-order-of-multiple-backgrounds/

## color hex

..

## 드래그앤드랍

..

## 스켈레톤

CSS linear-gradient를 통한 Skeleton Screen
https://unordinarydays.tistory.com/184

https://wit.nts-corp.com/2018/11/19/5371

code:
https://codepen.io/viktorstrate/pen/yoBRLy

https://ideveloper2.tistory.com/168
https://velog.io/@devknth/Skeleton-CSS%EB%A5%BC-%EC%86%8C%EA%B0%9C%ED%95%A9%EB%8B%88%EB%8B%A4-71k60mych7

## 캐시

...

## puppeter

...

## side menu

https://codepen.io/jangka44/pen/WmGOLm

## defineProperty

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty

enumerable
이 속성이 대상 객체의 속성 열거 시 노출된다면 true.
기본값은 false.
데이터 서술자는 다음 키를 선택사항으로 가집니다.

value
속성에 연관된 값. 아무 유효한 JavaScript 값(숫자, 객체, 함수 등)이나 가능합니다.
기본값은 undefined
writable
할당 연산자로 속성의 값을 바꿀 수 있다면 true.
기본값은 false.

## 스켈레톤?

..

## react router hash

...

## uuid

...

## Shadow DOM? Virtual DOM?

둘 다 공통적 인 것은 성능 문제를 해결한다는 것입니다. 둘 다 문서 개체 모델의 별도 인스턴스를 만듭니다. 이 외에도 두 개념이 다릅니다. 가상 DOM은 전체 DOM 객체의 복사본을 생성하고 있으며 Shadow DOM은 DOM 객체의 작은 부분을 생성합니다.

https://www.blog.duomly.com/what-is-the-difference-between-shadow-dom-and-virtual-dom/

## npm

/usr/local/lib/node_modules

npm uninstall -g @vue/cli

node -v
npm -v

~/workspace/vue
$ node -v
v10.15.3
kimjihye@kimjihye-MacBook-Air on 토  7 18 at 08:09 PM
~/workspace/vue
$ npm -v
6.9.0

npm show @vue/cli@\* version
npm view @vue/cli versions --json

npm i -g @vue/cli

## 컨테이닝 블록 식별

https://developer.mozilla.org/ko/docs/Web/CSS/All_About_The_Containing_Block

## script

https://dog-developers.tistory.com/95
https://rhammer.tistory.com/52

## module

https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Modules
https://velog.io/@widian/%EC%9B%B9%EC%97%90%EC%84%9C-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AA%A8%EB%93%88-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0

기본적으로 모듈 기능을 가져오는 스크립트는 최상위 모듈로 작동합니다. 이를 생략하면 파이어폭스로 예를들면, "SyntaxError: import declarations may only appear at top level of a module"라는 오류를 줍니다.

import 와 export 문(statement)은 모듈 내에서만 사용할 수 있습니다. 정규 스크립트가 아닙니다.

주의: type="module"을 포함하면 인터널 스크립트에서도 import 모듈을 사용할 수 있습니다. 예: <script type="module"> /_ 여기에 코드를 작성하세요 _/ </script>.

## xx

https://www.thetopsites.net/article/52558777.shtml

Uncaught TypeError: Failed to resolve module specifier "react". Relative references must start with either "/", "./", or "../".

번들링 도구를 사용하지 않으려면 node_modulesimport 문이있는 JavaScript 파일과 관련 하여에 lodash 폴더의 경로를 제공해야합니다 .

번 들러를 사용하지 않으려면 필요한 기능인 특정 파일에서 가져 오는 것이 좋습니다. 예를 들면 다음과 같습니다.

'../node_modules/lodash/each' 에서 \_each 가져 오기
브라우저의 ES 모듈-거의 모든 주요 브라우저 공급 업체가 현재 ES 모듈을 지원하므로, 그렇지 않은 경우 Axel Rauschmayer의 JS 탐색은 다른 지정자에게 내장 된 가져 오기와 같은 향후 사용을 위해 좋은 장소 중 하나입니다. 브라우저 친화적 인 ES6 형식으로 게시 된 글로벌 태그가 지정된 ES6 라이브러리 라이브러리는 웹 서버에서 제공 될 때 CDN 또는 로컬 node_modules 폴더에서 직접 사용할 수 있습니다. 이 경우 node_modules를 포함한 전체 경로를 입력해야합니다.

결국 브라우저에서 JS 모듈을 사용할 수 없습니다. 이 모듈은 웹팩 또는 기타 번 들러 용입니다.

vscode가 노드 모듈 패키지를 올바르게 가져 오지 않습니다. · 이슈, vscode가 노드 모듈 패키지를 제대로 가져 오지 않습니다. # 30472 node_modules / core-decorators / index.js가 존재하지 않으므로 브라우저 스타일 가져 오기를 사용하더라도 code, you are commonjs 모듈 대상은이를 의미하지만 esnext 및 es6 모듈 대상은 그렇지 않습니다. ES6 모듈은 기본적으로 엄격 모드로 실행됩니다 (더 이상 '엄격한 사용'필요 없음). 이것의 최상위 값은 정의되어 있지 않습니다. 최상위 변수는 모듈에 로컬입니다. 브라우저가 HTML 구문 분석을 완료 한 후 ES6 모듈이 비동기식으로로드 및 실행됩니다. 제 생각에는 이것들이 모두 큰 장점입니다.

lodash-es 모듈 사용해보기

'../node_modules/lodash-es/each.js' 에서 각각 가져 오기
ES6 모듈은 브라우저에서 랜드를 지원합니다. 번들링을 다시 생각할 시간 입니까? 브라우저가 ES6 모듈을 구현하기 시작한 브라우저에서 Babel과 함께 사용하는 방법과 가져 오기가 Node.js의 요구와 어떻게 다른지에 대해 살펴 보았습니다. 번들링을 제외하고 지금 당장 많이 일어나지 않습니다.이 기사에서는 오늘날 브라우저에서 ES 모듈을 사용하는 방법을 보여줍니다. 최근까지 JavaScript에는 모듈 개념이 없었습니다. 직접 참조하거나 포함 할 수 없습니다

JavaScript 모듈, 기본 JavaScript 모듈 사용은 import 및 export 문에 따라 다르며 브라우저 호환성은 다음과 같습니다. 파일은 Node.js와 같은 런타임에 의해 모듈로 구문 분석되고 Babel과 같은 빌드 도구입니다. 대부분의 서버는 이미 .js 파일에 올바른 유형을 설정했지만 아직 .mjs 파일에 대해서는 설정하지 않았습니다. 브라우저와 Node.js간에 ES6 모듈을 공유하십시오. 이 저장소에는 관련 Enuma 블로그 게시물에서 논의한 전체 예제가 포함되어 있습니다. ECMAScript 모듈 지원은 2018 년 5 월 9 일부터 Firefox가 공식적으로이 기능을 공식적으로 공개 한 이후 모든 주요 브라우저에서 사용할 수 있습니다.

JavaScript 모듈 · V8, JavaScript 모듈이 모든 주요 브라우저에서 지원됩니다! HTML 스타일 주석 구문은 클래식 스크립트에서 작동하지만 모듈에서는 지원되지 않습니다. Node.js 및 d8과 같은 런타임으로, Babel과 같은 도구를 빌드하십시오. Node.js / npm에서 "패키지 이름"으로 JS 모듈을 가져 오는 것이 일반적입니다. ES6 모듈 스펙에는 "node_modules에서 일치하는 폴더 찾기"라고 표시되지 않으므로 --module es6도 그렇게하지 않습니다. node_modules에서 모듈을로드하기 때문에 commonjs가 프로젝트의 올바른 모듈 대상입니다.

Vue의 새로운 기능 : ES 모듈 브라우저 빌드, Vue 2.6에는 ES 모듈 브라우저 빌드가있어 모듈로 작성할 수 있으며 모듈로 분할 할 수 있으며 확장 가능한 방법으로 종속성을 가져올 수 있습니다. Vue ES 브라우저 빌드 (예 : node_modules / vue / dist / vue). esm.browser.js. nomodule 스크립트를로드하지 않으면 Notes 동적 가져 오기를 인식하지 못하는 브라우저는 CommonJS 또는 ES 모듈 파일에서 CommonJS 또는 ES 모듈 파일을 가져올 수 있습니다. 자세한 내용은 노드의 ECMAScript 모듈 설명서를 참조하십시오. 비활성화 됨 버전 12.0.0부터 :이 기능은 --experimental-modules runtime 플래그 뒤에 있습니다.

## meta 상세

- http-equiv: [content-security-policy | refresh]
  프래그마 지시문을 정의합니다. 특성의 이름(http-equiv(alent))에서 알 수 있듯이, 가능한 값은 특정 HTTP 헤더입니다.
- content-security-policy
  현재 페이지의 콘텐츠 정책을 정의할 수 있습니다. 대부분의 콘텐츠 정책은 허용하는 서버 출처와 스크립트 엔드포인트를 지정해 사이트 간 스크립트 공격 방어에 도움을 줍니다.
- refresh
  다음 항목을 지정합니다.
  content 특성에 양의 정숫값을 설정한 경우, 페이지를 새로 고칠 때까지의 초.
  content 특성이 양의 정숫값을 가지고 그 뒤를 문자열 ;url=과 유효한 URL이 뒤따른다면, 페이지를 해당 URL로 보낼 때까지의 초.

콘텐츠 보안 정책
Content-Security-Policy웹 사이트 관리자는 HTTP 응답 헤더를 사용하여 특정 페이지에 대해 사용자 에이전트가로드 할 수있는 리소스를 제어 할 수 있습니다. 몇 가지 예외를 제외하고 정책에는 주로 서버 원본 및 스크립트 끝점 지정이 포함됩니다. 이는 사이트 간 스크립팅 공격 ( XSS - Cross-site scripting ) 을 방지하는 데 도움이됩니다 .

<meta http-equiv="Content-Security-Policy" content="block-all-mixed-content">

## 프래그마 지시문 Pragma

Pragma 지시문은 컴퓨터 또는 운영 체제별 컴파일러 기능을 지정 합니다. Microsoft 컴파일러만을 위한 지시어를 사용한다면 \_\_pragma 지시어를 매크로에 연동하여 사용할 수 있습니다.

Directive
설명
설명영어에서 번역됨-컴퓨터 프로그래밍에서 지시어 또는 pragma는 컴파일러가 입력을 처리하는 방법을 지정하는 언어 구조입니다. 지시문은 프로그래밍 언어 문법의 일부가 아니며 컴파일러마다 다를 수 있습니다

https://docs.microsoft.com/ko-kr/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=vs-2019

## 커피원두

https://m.blog.naver.com/PostView.nhn?blogId=dalkis0811&logNo=40137427544&proxyReferer=https:%2F%2Fwww.google.com%2F

## 아티팩트 artifact

https://12bme.tistory.com/454

## 광고트래킹

네이버 광고 new Image()

https://support.criteo.com/s/article?article=About-Ad-Tracking&language=ko

http://www.wisetracker.co.kr/blog/a-walkthrough-of-app-attribution-tracking-url/

## JS 컨텍스트

실행컨텍스트는 덩어리 (실행을 위한 환경)

- 글로벌환경 GO
  : 1 환경 레코드ER(오브젝트환경레코드OER 동적환경만 존재)
  2 외부 렉시컬환경참조 OLER 는 무조건 null

- 렉시컬환경 LEComponent
  : 1 환경 레코드ER(선언적환경레코드 DER 정적환경 & 오브젝트환경레코드OER 동적환경)
  2 외부 렉시컬환경참조 OLER
- 변수환경 VEComponent
- this바인딩 TBComponent

실행 컨텍스트: {
렉시컬환경 LEComponent :{
환경레코드 ER:{
선언적환경레코드 DER 정적환경:{},
오브젝트환경레코드 OER 동적환경:{}
},
외부 렉시컬환경참조 OLER:{} -> 스코프
},
변수환경 VEComponent:{},
this바인딩 TBComponent:{},
}

콜스택은 실행콘텍스트의 논리적 구조이다.
함수가 호출되면 3개의 파라미터 값을 실행콘텍스트로 넘겨준다
함수를 호출한 오브젝트 -> this 바인딩 컴포넌트에 설정하여 this로 함조
함수코드 -> [[Code]]
호출한 함수의 파라미터 값 -> [[FormalParameters]] 함수 인자로 받는 파라미터명들 array형태.. 전달인자들을 param array의 index로 매핑{} 한다. param array 에 index에 해당하는 값이 없다면 즉 인자가 없다면 undefined. 호출된 함수의 Arument오브젝트에 설정 선언적환경레코드에 저장됨.

a,b,b
1,2,3

function x(a, b, b) {
console.log(a); // 1
console.log(b); // 3 덮어써짐
console.log(arguments);

console.log(arguments[0]);
// expected output: 1

console.log(arguments[1]);
// expected output: 2

console.log(arguments[2]);
// expected output: 3
}
x(1, 2, 3);

매개변수는 변수(variable)로, 전달인자는 값(value)으로 보는 것이 일반적이다.

## DPI 배율

화소 밀도가 높을수록 화면은 선명해진다.
해상도: resolution 스크린의 총 픽셀 수

- 같은 면적에서 해상도가 높아지면 이미지는 압축되어 사이즈가 작게 보인다.

mdpi 중간밀도 1x
hdpi 고밀도 1.5x
xhdpi 초고밀도 2x
xxhdpi 초초고밀도 3x

dpi는 인쇄와디스플레이 해상도의 측정단위이며, 특히 1제곱인치(2.54)공간 안에 만들어진 점이나 화소의 수.

안드로이드 상대적인 수치단위
도트 퍼 인치
촘촘히 하면 화질 조아여 상관관계

안드로이드 기준 160dpi = mdir 이고 1px은 1dp
그렇다면 320dpi는? 2px = 1dpi
2배율 됭야 함
밀도 덴시티
x1
x1.5

## 캐러셀

??

## 혼합컨텐츠. cors?

https://evan-moon.github.io/2020/05/21/about-cors/

The HTTP Content-Security-Policy (CSP) block-all-mixed-content directive prevents loading any assets over HTTP when the page uses HTTPS.
https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Security-Policy/block-all-mixed-content

https://googlesamples.github.io/web-fundamentals/fundamentals/security/prevent-mixed-content/xmlhttprequest-example.html

SSL기반의 웹 컨텐츠에서 중간에 암호화되지 안은 http기반의 컨텐츠가 발생할 경우 브라우저는 http컨텐츠를 로딩하지 않는다. 암호화된 https컨텐츠만 안전하다고 판단하기 떄문에ㅌ

https://rsec.kr/?p=137

SSL 기반의 웹컨텐츠에서 중간에 암호화 되지 않은 HTTP기반의 컨텐츠가 발생 할 경우 브라우저는 HTTP 컨텐츠를 로딩하지 않습니다. 암호화 된 HTTPS 컨텐츠만 안전 하다고 판단하기 때문이겠죠.

아래는 HTTPs 기반의 웹사이트에서 HTTP컨텐츠가 혼용 (Mixed) 되어 있을때 브라우저가 HTTP컨텐츠를 차단하고 보여주는 경고메시지 입니다. 크롬의 경우는 방패 아이콘을 표시해주고, 파이어폭스의 경우는 i 아이콘을 통하여 경고메시지를 표시해 줍니다.

## stacking context 쌓임맥락

## 컨테이닝 블럭 결정

https://developer.mozilla.org/ko/docs/Web/CSS/All_About_The_Containing_Block

## html 문서의 charset

<meta> 문서의 정보이기도 하지만
서버가

<meta chartset="utf8"> 태그는 html파일의 인코딩을 알려주는 태그. 인코딩을 명확하게 알려주지 않으면 웹브라우저 설정상황에 따라 자동으로 인코딩을 추정해서 처리해주는데, 처리가 정확할 경우도 있지만, 그렇지 못하는 경우도 많다 다양한 경우에 한글이 깨지지 않고 잘 보이기를 기대한다면 위태그는 꼭 적어주는 것이 좋다.

<meta> 요소는 문자 집합 결정 알고리즘의 한 부분일 뿐입니다. Content-Type HTTP 헤더와 바이트 순서 표식이 <meta> 값을 재정의할 수 있습니다.

https://developer.mozilla.org/ko/docs/Web/HTML/Element/meta

## 플렉스박스

센터정렬 얼라인아이템즈 & 저스티파이컨텐츠

## 트랜지션고 애니의 가장큰차이는

특정지점 프레임을 제어 할 수 이싸
시작 중간 긑 트랜지셔은 중간이 없어. 애니는 타임라인 프레임바이프레임

## 이벤트

// e.preventDefault();
e.stopPropagation();
// e.stopImmediatePropagation();

## 경쟁상태?

애플리케이션이 제대로 동작하기 위해 특별한 입ㄴ트 순서에 의존한다면 여러개의 동시적인 동작이 발생하는 순서에 따라 공유된 데이터구간을 다르게 수행할 수 있는 데이터 경쟁상태 - 동시적인 연산은 각자 누가 먼저 완료되었는지를 경쟁하는 것이다.

## 애니메이션

스크롤링이나 애니메이션과 같은 것들을 부드럽게 보이게 하려면, 초당 60 프레임이 필요하다.

초당 프레임(FPS)에 대해서 들어보았을 것이다. 나는 이것을 플립 북이라고 생각한다. 정적인 그림책 같지만 엄지 손가락을 사용하여 넘기면 페이지의 그림이 움직이는 것처럼 보인다.

이 플립 북의 애니메이션을 매끄럽게 보이게 하려면, 애니메이션이 발생하는 매초마다 60 페이지가 있어야 한다.

## requetAnimationFrame

가장 먼저 필요한것. 변하는 값이 무어냐. 변하는 값이 애니메이션 프레임과 관계가 있는가?
1초에 60프레임을 목표로한다. 목표로 하는 이유는 컴퓨너 성능에 따라 달라지니까

초기에는 초기화함수를 한번 호출하고
내부에서 requestAnimationFrame을 특정 조건안에서 실행하므로
특정조건을 만나지 못하면 무한으로 반복한다. 계속한다.

단, 초기에는 최초1번은 실행하고자 하는 함수를 호출 해주어야 한다.

## 뷰포트

https://mommoo.tistory.com/tag/getBoundingClientRect

요소의 위치를 생각할 때는 조금더 복잡해진다. 문서가 브라우저의 크기보다 큰 경우, 스크롤이 만들어지는데 스크롤에 따라서 위치의 값이 달라지기 때문이다. 이를 이해하기 위해서는 우선 뷰포트가 선행되어야 한다?

핵심은, 요소의 위치는,, 만들어지는 스크롤에 따라서 위치의 값이 달라진다.

- pageYOffset: 창으로 부터 현재 위치(좌표?) -> 스크롤된 길이 -> 스크롤의 정도 -> 중요! 스크롤시마다 영역의위치는 변경된다.
  전체 문서의 절대 적인 위치가 필요하다면 사용해야 하는 값이다. 특정 위치에 점을 찍거나, 이 기준은 뷰포트가 아닌 문서 전체기준에서의 y 위치값일테니까
- offsetTop은? 부모의 포지셔닝 정책 좌표기준이 바뀐다. 요소의 상위 요소중 하나라도 포지셔닝이 relative면 offset API는 절대좌표가 아닌 relative한 부모 요소의 상대좌표값이 구해집니다.

1. 요소의 절대좌표 구하기.  
   const absoluteTop = window.pageYOffset + element.getBoundingClientRect().top;
2. Viewport의 시작지점을 기준으로한 상대좌표
   const relativeTop = element.getBoundingClientRect().top;

출처: https://mommoo.tistory.com/85 [개발자로 홀로 서기]

- 뷰포트: innerWidth & innerHeight
- 해상도: window.screen.width & window.screen.height
- 패딩만 포함한 엘리먼트 크기 : ClientWidth ClientHeigh (패딩만 포함)
  element.clientWidth는 margin값과 border값이 제외된, padding값까지만 적용된 내부의 실제 크기를 가져온다.

컨텐츠라고 할때, 켄텐츠영역은 패딩과 border(테두리)는 포함하지 않는다.

- 마진만 제외한 엘리먼트 크기 :
- element.offsetWidth & offsetHeight: 패팅 & 보더 & 스크롤을 포함 (마진만 제외)
  element.offsetWidth는 margin을 제외한, padding값, border값까지 계산한 값을 가져온다. (일반적으로 많이쓰임)
  스크롤이 있는경우 스크롤을 포함하며, 스크롤의 크기는 브라우저마다 다르다.. 크롬 약 17

- scrollWidth: 스크롤이 존재하는 경우 스크롤로 감싸진 영역의 크키 (패팅 & 보더)

- getboundingclientrect width??????????와 offsetWidth는 거의 비슷.. (마지만 제외)
  https://so4869.tistory.com/26

정리
getBoundingClientRect().width
렌더링된 너비를 Return (화면에 그림)
소수점까지 반환

offsetWidth
layout 너비를 Return
반올림된 정수값을 반환

## array undefiane

ㆍundefinded가 아닌 empty 배열에서 메서드들이 비어 있는 요소에 대해서 어떠한 처리도 안 했음

ㆍundefinded는 비어있음을 의미하지만 값으로 인식하여 동작하기 때문에 순회의 대상이 됨. 이상하게 비어있다고 의미를 가지지만 자신이 값으로 존재한다는 것, 또한 자바스크립트 엔진에서 비어있는 식별자에게 접근할 시 자바스크립트 엔진이 자동으로 undefinded를 할당하니 개발자가 명시적으로 undefinded를 지정할 경우 혼란이 올 수 있음

[출처] [Javascript] undefinded, empty, null (자바스크립트, js, 배열, array, 빈 배열, 배열의 빈 공간, 배열 순회, forEach, map)|작성자 bbaktaeho

ㆍundefinded와 같은 의미를 가짐

ㆍ명시적으로 비어있다고 의미를 부여할 때 undefinded 보다 null 을 사용하는 것이 좋음(혼란을 피하는 법)

[출처] [Javascript] undefinded, empty, null (자바스크립트, js, 배열, array, 빈 배열, 배열의 빈 공간, 배열 순회, forEach, map)|작성자 bbaktaeho

var arr1 = new Array(5);

console.log(arr1)

var arr2 = [undefined, undefined, undefined, undefined];

console.log(arr2)

var arr3 = [];

arr3[3] = "hi";

console.log('arr1')

var result1 = arr1.map(function(e, i) {

// 순회한 것처럼 보이지만 새로운 빈 배열을 리턴하는 것 뿐임

return '1';

});

console.log('arr2')

var result2 = arr2.map(function(e, i) {

return '2';

});

var result3 = arr3.map(function(e, i) {

return '3';

});

console.log(result1);

console.log(result2);

console.log(result3);

> Array [undefined, undefined, undefined, undefined, undefined]
> Array [undefined, undefined, undefined, undefined]
> "arr1"
> "arr2"
> Array [undefined, undefined, undefined, undefined, undefined]
> Array ["2", "2", "2", "2"]
> Array [undefined, undefined, undefined, "3"]

[출처] [Javascript] undefinded, empty, null (자바스크립트, js, 배열, array, 빈 배열, 배열의 빈 공간, 배열 순회, forEach, map)|작성자 bbaktaeho

var arr1 = new Array(5);

console.log(arr1)

var arr2 = [undefined, undefined, undefined, undefined];

console.log(arr2)

var arr3 = [];

arr3[3] = "hi";

console.log('arr1')

arr1.forEach(function(e, i) {

// 완전히 비었을 때 순회조차 안함

console.log(e, i);

});

console.log('arr2')

arr2.forEach(function(e, i) {

console.log(e, i);

});

arr3.forEach(function(e, i) {

console.log(e, i);

});

> Array [undefined, undefined, undefined, undefined, undefined]
> Array [undefined, undefined, undefined, undefined]
> "arr1"
> "arr2"
> undefined 0
> undefined 1
> undefined 2
> undefined 3
> "hi" 3

## 글자가 넘칠때

/_ word-break: break-word; _/
overflow-wrap: break-word;

## jsonp

http://www.codejs.co.kr/jquery-jsonp/
JQUERY의 JSONP을 사용한 크로스도메인간 통신
2012-04-03 CODEJS 댓글 4개
웹은 Same origin policy이 동일한 도메인상의 요청만 가능하도록 제한하였지만,
도메인간 데이터 통신으로부터 다이나믹한 웹구현을 위한 방법으로 JSONP가 나오게 된것이다.

jQuery의 ajax를 이용한 두가지 jsonp 요청 방법을 지금부터 소개 하겠습니다.

첫번째, 요청 URL뒤에 ?callback=? 추가하여 jsonp 요청 구현하기
jQuery 1.2부터는 JSONP 호출에 대한 네이티브 지원이 제공되고 있다. JSONP 콜백을 지정한 경우 다른 도메인에 있는
JSON 데이터를 로드할 수 있으며 JSON 콜백은 url?callback=? 라는 구문을 사용하여 지정할 수 있다.

\$.getJSON() 방식을 살펴보면 url 맨 끝에 callback=이라는 문자열과 함께 실제 함수 이름 대신 ? 기호를 콜백 함수 이름으로

## poestmsg

데이터 전송

window.postMessage(data, [ports] , targetOrigin )

data: 전달할 메시지나 데이터,

ports : 메시지 포트 (생략가능)

targetOrigin : 타켓 도메인, 특정 도메인이 아니면 \* 사용가능

데이터 수신

window.onmessage = function(e){

if(e.origin === "http://보낸쪽domain.com"){

     alert(e.data);

}

}

또는

window.addEventListener("message", 컨트롤함수, true);

window.attachEvent("onmessage", 컨트롤함수);

## ifrma

https://m.blog.naver.com/forioso/220968026018

다른 도메인간 데이터 통신
프로필
사랑굳 2017. 3. 27. 10:51

이웃추가본문 기타 기능

Uncaught DOMException: Blocked a frame with origin "http://domain.com" from accessing a cross-origin frame.

도메인이 다르거나 ﻿프로토콜이 다르다면 서로 다른 사이트로 인식 하게 된다.

이렇게 다른 도메인 사이에 스크립트 처리시 보안 정책 위반으로 오류가 발생된다.

옛날에는 잘 되었지만 보안이 강조되면서 요즘은 다 막혀 있다.

주로 iframe 이나 팝업창 등의 다른 창을 제어할때 발생된다.

여러가지 편법이 있다.

개인의 브라우저에서 보안을 낮추는 설정을 하기도 하지만 권장사항은 아니다.

하지만 window.postMessage 라는 녀석이 나오면서 개발단에서 우회방법을 만들었다.

Cross Document Messaging 이라 불리며, IE8 이상 지원되면서 호환성도 인증받았다.

서로 다른 winodw객체..
https://junspapa-itdev.tistory.com/55
Uncaught DOMException: Blocked a frame with origin "http://inflearn.com:5500" from accessing a cross-origin frame.

동일 출처 정책
CORS 와 혼동하지 마십시오!

JavaScript를 사용하여 다른 Origin으로 *<iframe>*에 액세스하면 cantt 액세스 할 수 있습니다. 동일 출처 정책 브라우저는 다른 Origin 로 프레임에 액세스하려는 스크립트를 차단합니다.

주소의 다음 부분 중 하나 이상이 유지되지 않으면 출발지가 다른 것으로 간주됩니다.

_<protocol>://<hostname>:<port>/path/to/page.html
_
Protocol , hostname 및 port 다음과 같은 경우 도메인과 같아야합니다. 프레임에 액세스하려고합니다.

예

## html (Emmet abbreviation)

둘러보기로 가기검색하러 가기
에밋(Emmet)은 HTML, XML, XSL 문서 등을 편집할 때 빠른 코딩을 위해 사용하는 플러그인이다. 원래 젠코딩(Zen Coding)으로 부르다가 에밋(Emmet)으로 이름을 변경했다.[1] 매우 간단한 몇 가지 코드만 입력하면, 자동으로 완전한 HTML 코드를 생성해 준다.

https://docs.emmet.io/abbreviations/
https://ko.wikipedia.org/wiki/%EC%97%90%EB%B0%8B_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4)

! emmet abbreviation

https://opentutorials.org/module/2957/20611

## web

- 트랜스레이트 3d
- 서랍메뉴
- 스크롤
- 바퀴만들기
- js역사
- 모더나이저: 기능 탐지
- z index 쌓임 맥락: 포지션 적용에만?? 자식이 zindx라면? 부모와의 관계
- 드래그앤 드랍
- color & rgb + rgba
- ref
- merge
- requestAnimationFrame
- canvas 그리기 / getConext / attr css / pixel 수 / scale
- http 프로토콜 안맞으면 에러 cors

## transform

scaleY
translateY

## transition

변환하고 싶다. 전환. 전환과정. 스타일의 전환과정.
바뀌고 싶다.

바뀌는 과정을 보고 싶을 때. 어떤 스타일을 보고 싶은지 프롭으로.
특정 프롭에 대해서만 적용하는데..

다 보고싶다면??
여러개 나열하면 댐. 또는 all

transition-property: background-color, color;
transition-duration: 1s;
transition-timing-function: ease-out;

transition: background-color 1s ease-out,
transition: color 1s ease-out,
transition: all 1s ease-out,

키프레임은 언제??

순서 중요. 지속시간, 지연시간, 속도
transition: property duration timing-function delay|initial|inherit;
어떤 과정을 보고싶어?
얼마동안 보고싶어?
지연시간은? 얼마나(몇초) 있다가 보고싶어?
어떤 속도로 보고싶어?

https://www.w3schools.com/cssref/css3_pr_transition.asp
https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions

## will-change

https://wit.nts-corp.com/2017/06/05/4571

## vh

https://webclub.tistory.com/356

## 로렘입숨

Lipsum generator: Lorem Ipsum - All the facts
https://namu.wiki/w/%EB%A1%9C%EB%A0%98%20%EC%9E%85%EC%88%A8

로렘 입숨은 출판이나 그래픽 디자인 분야에서 폰트, 타이포그래피, 레이아웃 같은 그래픽 요소나 시각적 연출을 보여줄 때 사용하는 표준 채우기 텍스트로, 최종 결과물에 들어가는 실제적인 문장 내용이 채워지기 전에 시각 디자인 프로젝트 모형의 채움 글로도 이용된다.

https://brunch.co.kr/@forchoon/23

## css 7가지 단위

https://www.google.com/search?q=css+vw&oq=css+vw&aqs=chrome..69i57j0l7.4428j1j7&sourceid=chrome&ie=UTF-8
뷰포트 단위? vw

## IE 컴패터블?

호환성 메타태그 추가

## git..

깃 처음 시작

572 2020-06-04 10:05:16 git config --global user.name "Jenkins"
573 2020-06-04 10:06:55 git config --global user.email "Jenkins Server <noreply@jenkins.11stcorp.com>"
git config --list

git config --global push.default matching
git config --global push.default simple

git config --global push.default simple

이는 push 옵션을 확인하라는 경고이다.
push 옵션 2가지 차이점은
- simple : 현재 작업중이 브랜치만 push

- matching : local과 remote 브랜치명이 동일한 모든 브랜치를 push

git remote show origin

git push origin HEAD:build/version

깃 머지

## 리눅스 GNU GPL 리눅스 특징

https://jhnyang.tistory.com/18

## 용어정리

- 리팩터링: 겉으로 드러나는 코드의 기능(겉보기 동작)은 바꾸지 않으면서 내부 구조를 개선하는 방식으로 소프트웨어 시스템을 수정하는 과정. 코드를 작성하고 난 뒤에 설계를 개선하는 일이다.
  외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법
- 객체지향프로그래밍: 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

## 웹 사이트 속도 향상을위한 모범 사례

https://developer.yahoo.com/performance/rules.html?guccounter=1

## 정적타이핑 동적 타이핑

https://poiemaweb.com/typescript-typing
정적 타이핑
C나 Java같은 C-family 언어는 변수를 선언할 때 변수에 할당할 값의 타입에 따라 사전에 타입을 명시적으로 선언(Type declaration)하여야 하며 선언한 타입에 맞는 값을 할당해야 한다. 이를 정적 타이핑(Static Typing)이라 한다.

자바스크립트는 동적 타입(dynamic typed) 언어 혹은 느슨한 타입(loosely typed) 언어이다. 이것은 변수의 타입 선언 없이 값이 할당되는 과정에서 동적으로 타입을 추론(Type Inference)한다는 의미이다. 동적 타입 언어는 타입 추론에 의해 변수의 타입이 결정된 후에도 같은 변수에 여러 타입의 값을 교차하여 할당할 수 있다. 이를 동적 타이핑(Dynamic Typing)이라 한다.

동적 타이핑은 사용하기 간편하지만 코드를 예측하기 힘들어 예상치 못한 오류를 만들 가능성이 높다. 또한 IDE와 같은 도구가 변수나 매개 변수, 함수의 반환값의 타입을 알 수 없어 코드 어시스트 등의 기능을 지원할 수 없게 한다.

TypeScript의 가장 독특한 특징은 정적 타이핑을 지원한다는 것이다. 정적 타입 언어는 타입을 명시적으로 선언하며, 타입이 결정된 후에는 타입을 변경할 수 없다. 잘못된 타입의 값이 할당 또는 반환되면 컴파일러는 이를 감지해 에러를 발생시킨다.

참고로 정적 타이핑과 동적 타이핑 중 무엇이 우위인지에 대한 논쟁은 사실 큰 의미가 없다. 정적 타이핑과 동적 타이핑의 가장 큰 차이를 컴파일 시의 에러 검출과 런타임 시의 에러 검출로 볼 수 있는데 Java와 같은 정적 타이핑 언어도 런타임에만 검출되는 에러가 존재하기 때문이다.

정적 타이핑의 장점은 코드 가독성, 예측성, 안정성의 향상이라고 볼 수 있는데 이는 대규모 프로젝트에 매우 적합하다.

만약 타입 선언을 생략하면 값이 할당되는 과정에서 동적으로 타입이 결정된다. 이를 타입 추론(Type Inference)이라 한다.

let foo = 123; // foo는 number 타입
위 코드를 보면 변수 foo에 타입을 선언하지 않았으나 타입 추론에 의해 변수의 타입이 결정된다. 동적 타입 언어는 타입 추론에 의해 변수의 타입이 결정된 후에도 같은 변수에 여러 타입의 값을 교차하여 할당할 수 있다. 하지만 정적 타입 언어는 타입이 결정된 후에는 타입을 변경할 수 없다. TypeScript는 정적 타입 언어이므로 타입 추론으로 타입이 결정된 이후, 다른 타입의 값을 할당하면 에러가 발생한다.

any를 쓸꺼면 ts를 왜써?
타입 선언을 생략하고 값도 할당하지 않아서 타입을 추론할 수 없으면 any 타입이 된다. any 타입의 변수는 자바스크립트의 var 키워드로 선언된 변수처럼 어떤 타입의 값도 재할당이 가능하다. 이는 TypeScript를 사용하는 장점을 없애기 때문에 사용하지 않는 편이 좋다.

모듈 구현과 타입 선언
시작부터 짚고 넘어가야 할 것은, 모듈 구현(implement)과 타입 선언(declaration)은 별개라는 것이다. 모듈 구현은 모듈의 동작부를 작성하는 것이고, 타입 선언은 타입스크립트 컴파일러에서 제공하는 타입 검증을 위해 객체의 타입을 서술하는 것이다.

.ts파일로 작성한 스크립트의 경우 모듈 구현과 타입 선언이 동시에 이루어지지만,
.js파일에서는 오로지 모듈 구현만 이루어지고,
.d.ts파일에서는 타입 선언만 이루어진다

## npm

cache clean

## npx

npx node@6 -v
npx node@13.8.0 -v
npx -p node@8 npm run build

npx node@13.8.0 -v
v13.8.0
npx -p node@13.8.0 -- node -v
v13.8.0

npx -p node@13.8.0 node -v  
v13.8.0

npm: 6.14.4

## path.join 과 path.resolve 차이 📋 / path.join이란? / path.resolve란?

## pragma

http://sarghis.com/blog/941/
https://mayu.tistory.com/8
https://en.wikipedia.org/wiki/Pragma_once
https://jasonformat.com/wtf-is-jsx/

. JSX Pragma: transpile to h()
https://preactjs.com/guide/v8/switching-to-preact/

Rendering JSX
https://preactjs.com/guide/v8/getting-started/#rendering-jsx

## ts 핸드북 & jsxFactory

https://joshua1988.github.io/ts/config/tsconfig.html#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-%EC%86%8D%EC%84%B1
https://www.typescriptlang.org/docs/handbook/compiler-options.html

## 모듈

https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript
https://www.freecodecamp.org/news/javascript-modules-a-beginner-s-guide-783f7d7a5fcc/?source=latest---------1
https://www.freecodecamp.org/news/
모듈 패턴
객체 리터럴 표기법

## js 디자인 패턴 & 모듈패턴

https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript
http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html

## preact

https://preactjs.com/guide/v8/differences-to-react/#whats-added
import React from 'react' -> import {h} form 'preact'
plugin-transform-react-jsx
rules: [
{
test: /\.js\$/,
exclude: /node_modules/,
use: {
loader: "babel-loader",
options: {
presets: ["@babel/preset-env"],
plugins: [
[
"@babel/plugin-transform-react-jsx",
{
pragma: "h",
pragmaFrag: "Fragment",
},
],
],
},
},
},
className -> class
this.handleXX -> linkstate
https://medium.com/@janavianand/preact-cef54475648b

## bundle

https://www.freecodecamp.org/news/javascript-modules-part-2-module-bundling-5020383cf306/#.hgguh3g4o

## bfcache

https://jang8584.tistory.com/239
https://ifuwanna.tistory.com/63
https://programmingsummaries.tistory.com/tag/BFCache
https://m.blog.naver.com/PostView.nhn?blogId=youreme&logNo=110162034595&proxyReferer=https:%2F%2Fwww.google.com%2F
https://tnsgud.tistory.com/387
https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Working_with_BFCache

## mvc12

https://nickjoit.tistory.com/9
https://tapasnote.tistory.com/5
https://seongmun-hong.github.io/spring/MVC1-MVC2
https://creator0609.tistory.com/entry/MVC1-MVC2-%EC%B0%A8%EC%9D%B4

## arr & set

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Set

## SPA

https://poiemaweb.com/js-spa

## DAO

https://jungwoon.github.io/common%20sense/2017/11/16/DAO-VO-DTO/

https://gmlwjd9405.github.io/2018/12/25/difference-dao-dto-entity.html

## 웹팩

https://hoilzz.github.io/webpack/5-production/

development

강력한 소스 맵
실시간 재로드 또는 핫 모듈 교체가 가능한 localhost 서버
production

축소 번들
더 가벼운 무게 소스 맵
로드 시간을 개선하기위한 최적화 된 자산
webpack 공홈으로 인해 웹팩 설정 작성하기를 권장한다.

common.js

엔트리, 출력, babel-loader
플러그인은 HMR은 개발이 필요합니다
dev.js

HMR, devServer, devtool
prod.js

모드 : 생산

process.env.NODE_ENV === 'production'드롭 할 것입니다. webpack v4부터는 mode자동으로 DefinePlugin(NODE_ENV 같은 환경 변수 설정)

여튼 모드 : 생산이 자동으로 NODE_ENV가 생산으로 설정됩니다.

소스 매핑
생산 대표, 벤치 마크 테스트 (?) devtool: source-map을 권장한다. 빌드 속도가 아주 빠르면서 생산 모드에서 쓰기 적합하다.

inline-**_과 eval-_**은 생산에서 쓰지 말자. 전체 크기.

## 배열과 링크드 리스트?

...

## 요가

https://class101.net/products/yoga

## 부트스트랩하다

둘러보기로 가기검색하러 가기
부트스트랩(bootstrap) 또는 부트스트래핑(bootstrapping)은 "현재 상황에서 어떻게든 한다"는 뜻이다. 또, 사물의 초기 단계에서 단순 요소로부터 복잡한 체계를 구축하는 과정을 가리키는 경우도 있다.

부트스트랩 (컴퓨팅): 더 복잡한 도구를 만들 수 있도록 도와 주는 단순 도구를 만들거나 적재함으로써 복잡한 소프트웨어 도구를 만들거나 컴퓨터를 시작하는 것을 말한다. 줄여서 시동이라고도 할 수 있으며, 이는 컴퓨터를 시작하는 과정을 서술해 준다.
부트스트랩 (컴파일러): 언어 그 자체를 사용하여 컴퓨터 언어에 맞춰 컴파일을 기록하는 것을 말한다.

https://ko.wikipedia.org/wiki/%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9

https://ict-nroo.tistory.com/21

https://namu.wiki/w/Bootstrap
https://learningcarrot.wordpress.com/2015/11/12/%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-bootstrapping/

https://medium.com/javascript-in-plain-english/i-tested-a-react-app-with-jest-testing-library-and-cypress-here-are-the-differences-3192eae03850
내가 지적하고 싶은 한 가지는 CRA (Create-React-App)를 사용하여 React 앱을 부트 스트랩했다는 것입니다. 이는 Jest가 기본적으로 설치되어 제공됨을 의미합니다. Jest는 실제로 Jest 설정보다 더 많은 장소에서 편리하기 때문에 우리는 설정에서 이것을 제거하지 않을 것입니다. 원하는 경우 물론 완전히 제거 할 수도 있습니다.

## 코딩가이드

https://itmining.tistory.com/72
https://www.mimul.com/blog/why-we-argue-style/

## polyfill 적용

https://okchangwon.tistory.com/3

## pacakge @

extract-text-webpack-plugin으로 인스톨 하면 webpack 버전3가 호환이 되어있는 패키지가 인스톨되어 버리므로 webpack4과의 호환을 위해서 @next를 붙이자.

※extract-text-webpack-plugin 대신에 mini-css-extract-plugin을 사용해도 해결된다고 함

npm i extract-text-webpack-plugin@next -–save-dev

## 모듈러

https://perfectacle.github.io/2016/11/18/Module-bundling-with-Webpck/

## 번들러

https://www.freecodecamp.org/news/javascript-modules-part-2-module-bundling-5020383cf306/#.hgguh3g4o

이 문제를 해결하기 위해 요청 수를 줄이기 위해 모든 파일을 하나의 큰 파일 (또는 경우에 따라 몇 개의 파일)로 묶거나 "연결"합니다. 개발자가 "빌드 단계"또는 "빌드 프로세스"에 대해 이야기하는 것을들을 때, 이것이 그들이 말하는 것입니다.

번들링 작업 속도를 높이는 또 다른 일반적인 방법은 번들 코드를 "최소화"하는 것입니다. 축소는 코드의 기능을 변경하지 않고 내용의 전체 크기를 줄이기 위해 소스 코드에서 불필요한 문자 (예 : 공백, 주석, 줄 바꿈 문자 등)를 제거하는 프로세스입니다.

데이터가 적을수록 브라우저 처리 시간이 줄어들어 파일을 다운로드하는 데 걸리는 시간이 줄어 듭니다. “ underscore-min.js ” 와 같이“최소”확장자를 가진 파일을 본 적이 있다면 축소 버전이 정식 버전에 비해 매우 작고 읽을 수없는 것 입니다.

Gulp 및 Grunt와 같은 작업 실행기는 개발자가 연결 및 축소를 간단하게 수행하므로 사람이 읽을 수있는 코드가 개발자에게 노출 된 상태를 유지하면서 컴퓨터에 최적화 된 코드가 브라우저에 번들로 제공됩니다.

## devtool

https://trustyoo86.github.io/webpack/2018/01/10/webpack-configuration.html

## 알아보기

module loose 모드?
활성화 하지 않으면 호환성이 없는 코드로 트랜스파일링 된다?

## npx

https://geonlee.tistory.com/32

## unhandled promise reject

async함수 안에서 예상치 못한 에러가 발생하는 경우, 프로미스를 반환하여 에러처리를 하지 않는 경우, 내부적으로는 서비스는 실행되나 unhandled promise rejction 문구를 출력한다. express 는 에러발생을 인식하지 못한채 응답만 지연되게 한다.

해결안, express에서 라우팅핸들러함수에서 오류가 발생한경우 내부적으로 미들웨어의 세번째 파라메터인 next함수를 호출하여 error를 전달하여 마지막 에러처리 미들웨어에서 받아 적절하게 처리할 수 있도록 한다.

async awiat 함수는 기본적으로 promise를 리턴해주는 구조이다. 그렇다는 건 그안에서 발생한 오류를 단순하게 바깥으로 던져서 잡는게 아니라 promise의 catch함수를 통해 처리해주어야 한다는 의미이다.
라우팅 핸들러함수가 리턴한 reject된 promise를 적절하게 처리해주지 않고 있어서 발생

https://programmingsummaries.tistory.com/?page=3
async await 는 try catch 로 에러가 잡히지 않는가?
async함수에서 발생한 오류는 일반 함수내에서 try/catch로 잡을 수 없다. 해결안으로 함수를 또 async에서 호출한당.. 아니면 프로미스를 받아 catch로 reject처리

async function err () {
throw new Error('오류 발생');
}

(function () {
try {
err();
}
catch (e) {
console.log('에러', e);
}
}) ();
// Uncaught (in promise) Error

## node 하모니 옵션

https://nodejs.org/ko/docs/es6/
https://stackoverflow.com/questions/13351965/what-does-node-harmony-do
이전 버전의 nodejs에서 ECMAScript 6 기능을 실행하려는 경우 --harmony 플래그를 사용할 수 있습니다. 최신 버전의 노드는 ES6을 지원하므로 --harmony 플래그가 필요하지 않습니다.

## enzyme

https://www.vobour.com/jest%EC%99%80-enzyme%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-react-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8-te

https://shs400.github.io/2019/01/23/enzyme/

\\\

https://appear.github.io/2018/11/23/REACT/react-translate-13/

https://www.robinwieruch.de/react-function-component

## NODE JS - 모듈이란? , module.export 와 exports의 차이

출처: https://dydals5678.tistory.com/97 [아빠개발자의 노트]
https://programmingsummaries.tistory.com/340

## npm Dependencies devDependencies

package.json 파일 내의 dependencies, devDependencies의 차이를 알기 위해서 구글링을 하던 중, 보아도 잘 모르겠는 부분이 있어서 우리 drfts프로젝트인 lib-tz의 package.json파일을 보았지만.. 잘 모르겠어서 구글링의 도움을 받았습니다.

결과 1 => 프로젝트를 개발/테스트하려는 것이 아니라 활용만 하려는 목적이라면 개발의존성을 설치하는 것이 불필요하므로, devDependencies의 패키지를 제외하고 설치할 수도 있다.

결과 2 => dependencies, devDependencies는 해당 패키지가 다른 패키지에 의존할 경우 의존성에 대한 항목이다

결과 3 => dependencies와 devDependencies의 차이는 배포용 패키지(실제 상품에서 사용할 패키지)와 개발용 패키지(목, 테스트 패키지 등)의 차이다.

결과 4 => dependencies 는 이 패키지에 의존하는 `다른 프로젝트에서 구동`시키기 위한 의존성이다. `즉, 이 패키지를 활용할 때 필요한 의존성을 명시`한다. npm install --save 명령을 통해 패키지를 설치하면 이 항목에 프로젝트 정보가 저장된다.

devDependencies 에는 `이 패키지를 테스트하거나 개발할 때 필요한 패키지들을 명시`한다. npm install --save-dev 명령을 통해 패키지를 설치하면 이 항목에 프로젝트 정보가 저장된다.

::: 결론 ::: 우리가 개발 시 필요한 (컴파일러 같은) 라이브러리들은 devDependencies에 적어주고, 진짜 우리 프로젝트에서 기술스펙으로 사용되어야할 라이브러리들은 dependencies에 적어줍니다.

어떤 라이브러리가 프로젝트의 컴파일(빌드) 타임에 필요하면 devDependencies에 넣고, 런타임에도 계속 쓰이는 것이면 dependencies에 넣어야 합니다.

원래는 컴파일을 하면 컴퓨터는 알아듣지만, 인간이 이해하기에 상당히 난해한, 바이너리(0,1)로 결과가 나오는데, 트랜스파일은 컴퓨터가 알아들을 수 있는 형태가 아닌 브라우저가 알아들을 수 있는 형태로 코드를 바꿉니다. 근데 그 결과를 인간이 딱히 못알아보는 것도 아니예요. 결과가 바이너리도 아니고요. 사실 번역하는 과정에 가깝죠. 번역한다는 말의 translate 와 compile을 그냥 합쳐서 만들어둔 단어입니다.

https://github.com/saeromCho/shumblr/wiki/package.json-%ED%8C%8C%EC%9D%BC-%EB%82%B4%EC%9D%98-dependencies%EC%99%80-devDependencies%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EA%B3%BC-%EC%B6%94%EA%B0%80%EC%A0%81%EC%9D%B8-%EA%B3%B5%EB%B6%80(About-Babel)

## npm 버전

틸트 캐럿 골벵이
틸트는 첨부터 끝까지
캐럿은 API호환성이 깨지는 경우를 대비해 1점때 2점때만 자동 버전업

~(틸트)와 ^(캐럿)의 차이는 아래와 같다.

~(틸트)는 패치 버전 범위 내에서 업데이트한다. :

~0.0.1 : 0.0.1 <= version < 0.1.0
~0.1.1 : 0.1.1 <= version < 0.2.0
^(캐럿)는 마이너 버전 범위 내에서 업데이트한다. :

^1.0.2 : 1.0.2 <= version < 2.0
npm semver calculator에 방문하면 패키지 별로 버전 표기법을 사용하여 업데이트 버전 범위를 확인할 수 있다.

버전에 대한 보다 자세한 사항은 semver : The semantic versioner for npm를 참조하기 바란다.

https://blog.outsider.ne.kr/1041

## UX와 CX는 어떻게 다른가?

- UX: User 제품/시스템/서비스를 이용하는 데 있어 사용자의 인지 반응, 사용상 기대하는 바
  User: 무언가를 이용하거나 사용하는 사람. 고객일수도 고객은 아닐 수도 있음

사용자연구
페르소나
사용자 Journey 경로
사용성테스트
정보구조
인터랙션 디자인
디자인법칙
가이드라인

=> 서비스오 제품에 잘 적용되도록

- CX: Customer 서비스 공급자와 고객의 관계가 지속됨에 따라 관련하여 고객이 체험하는 모든 경험 총체
  Customer: 고객 또는 잠재고객

고객조사
페르소나
고객 Journey
프로토타입
디자인
비즈니스 전략
비즈니스/서비스 사례
KPI

회사의 브랜드전략, 비즈니스 전략, 사업상 성과지표 함께 염두하고 고민

UI는 인터페이스 디자이너, UI개발자, 사용자 조사를 경험할 수 있는 사람, 즉 개발자는 UI를 고민할 수 있다.

고민한다. CX를 경험하는 사람은 마케팅매니저, 프러덕트매니저, 시장조사, 비지니스 분석, 고객전략 매니저업무를 경험한 사람이 적합하다.

!! 둘의 공통점은 사람 또는 그들의 니즈에 대한 것! 공감.

접근 방식이 다르다.
제품을 사용함에 있어 니즈를 조사하고 분석. 인터페이스 설계 검증 테스트

벗, 제품 서비스에만 한하지 않고 전반적인 라이프스타일부터 구체적인 이즈가 무엇인지 이해해야 한다. 브랭ㄴ드와 만나는 접점을 고민. 고객경험을 더 좋게 만듦으로써 궁극적으로는 비즈니스 목표를달성시키는 것이 최종 목표이다. 전략안!

https://uxd-trend.tistory.com/37

## ITSM IT Service Management

서비스 요청 프로세스
서비스 요청관리는 서비스문의, 업무지원요청, 개발요청 인프라 변경요청등 고객으로부터 접수되는 모든 유형의 요청을 관리

## 자료구조 알고리즘

## 제트인덱스와 오퍼시티

## 리펙터링

사전적 의미는?

리팩터링은 소프트웨어 공학에서 '결과의 변경 없이 코드의 구조를 재조정함'을 뜻한다. 주로 가독성을 높이고 유지보수를 편하게 한다. 버그를 없애거나 새로운 기능을 추가하는 행위는 아니다. 사용자가 보는 외부 화면은 그대로 두면서 내부 논리나 구조를 바꾸고 개선하는 유지보수 행위이다.

외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법입니다. 코드가 작성된 후에 디자인을 개선하는 작업입니다.?

https://asfirstalways.tistory.com/373

## 호출스택 쌓이는 순서

지역변수 흐름 파악 필요

## 키프레임

??

## 모달

??

## history api

History API 를 위해서는 세션 히스토리(Session History) 개념을 이해하는 것이 좋다.

세션 히스토리 개념을 위해 간단하게 브라우저 로딩부터 설명하겠다.

https://falsy.me/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%9D%B4%ED%95%B4-2-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EA%B7%B8%EB%A6%AC%EA%B3%A0-history-api/
https://mygumi.tistory.com/299
https://developer.mozilla.org/ko/docs/Web/API/History_API

```js
window.onpopstate = function (event) {
  alert(
    `location: ${document.location}, state: ${JSON.stringify(event.state)}`
  );
};

history.pushState({ page: 1 }, "title 1", "?page=1");
history.pushState({ page: 2 }, "title 2", "?page=2");
history.replaceState({ page: 3 }, "title 3", "?page=3");
history.back(); // alerts "location: http://example.com/example.html?page=1, state: {"page":1}"
history.back(); // alerts "location: http://example.com/example.html, state: null"
history.go(2); // alerts "location: http://example.com/example.html?page=3, state: {"page":3}"
```

## 웹팩 플러그인

https://lazymankook.tistory.com/82

http://jeonghwan-kim.github.io/js/2017/05/15/webpack.html

## 웹 프론트엔드 프래임웍

앵귤러 리엑트 뷰

https://www.samsungsds.com/global/ko/support/insights/frameworks.html

## 웹컴포넌트?

https://d2.naver.com/helloworld/188655

## 반응형 웹

https://www.samsungsds.com/global/ko/support/insights/Responsive_web_1.html

## 자바스크립트 개발자라면 알아야 할 33가지 개념

https://www.google.com/search?q=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4+%EC%95%8C%EC%95%84%EC%95%BC+%ED%95%A0+33%EA%B0%80%EC%A7%80+%EA%B0%9C%EB%85%90&oq=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4+%EC%95%8C%EC%95%84%EC%95%BC+%ED%95%A0+33%EA%B0%80%EC%A7%80+%EA%B0%9C%EB%85%90&aqs=chrome..69i57j69i60l2j69i61.118j0j4&sourceid=chrome&ie=UTF-8

## 리소스 우선순위 정하기

https://beomy.github.io/tech/browser/preload-preconnect-prefetch/

## 인증서 동작

https://medium.com/@icehongssii/%EA%B9%9C%EC%B0%8D%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%83%81%EC%8B%9D-4-https-%EC%99%80-ssl-%EA%B2%89%ED%95%A5%EA%B8%B0-78ff41071720

https://blog.naver.com/PostView.nhn?blogId=alice_k106&logNo=221468341565&parentCategoryNo=&categoryNo=16&viewDate=&isShowPopularPosts=true&from=search

## 스누핑

https://limkydev.tistory.com/191

## TIL / eject

https://helloinyong.tistory.com/174
https://medium.com/@jsh901220/create-react-app%EC%97%90%EC%84%9C-eject%EC%82%AC%EC%9A%A9%EC%95%88%ED%95%98%EA%B8%B0-customize-cra-react-app-rewired-10a83522ace0

## oAuth 로그인(인증+권한)

- https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/
- http://blog.weirdx.io/post/39955

OAuth는 Open Authorization, Open Authentication 뜻하는 것으로 애플리케이션(페이스북,구글,트위터)(Service Provider)의 유저의 비밀번호를 Third party앱에 제공 없이 인증,인가를 할 수 있는 오픈 스탠다드 프로토콜이다. OAuth 인증을 통해 애플리케이션 API를 유저대신에 접근할 수 있는 권한을 얻을 수 있다. OAuth가 사용되기 전에는 외부 사이트와 인증기반의 데이터를 연동할 때 인증방식의 표준이 없었기 때문에 기존의 기본인증인 아이디와 비밀번호를 사용하였는데, 이는 보안상 취약한 구조였다. 유저의 비밀번호가 노출될 가망성이 크기 때문이다. 그렇기 때문에 이 문제를 보안하기 위해 OAuth의 인증은 API를 제공하는 서버에서 진행하고, 유저가 인증되었다는 Access Token을 발급하였다. 그 발급된 Access token으로 Third party(Consumer)애플리케이션에서는 Service Provider의 API를 안전하고 쉽게 사용할 수 있게 되었다.

OpenID로 개발된 표준 인증 방식, API인증과 사용자인증에 사용된다. Oauth는 외부서비스의 인증 및 권한부여를 관리하는 범용적인 프로토콜입니다. OAuth는 인증뿐만 아니라 권한도 관리합니다. 사용자의 권한에 따라 접근할 수 있는 데이터가 다르도록 설정이 가능합니다.

[그외 인증 방법]

- 세션/쿠키, JWT를 이용한 인증
- Access Token + Refresh Token을 이용한 인증
- SNS 로그인은 간단하게 봤을 때 OAuth2.0 + 서버 인증(세션/쿠키, 토큰기반 인증)으로 구성

(사용자 <-> 어플리케이션 서버) 인증 절차였던 세션/쿠키, 토큰 기반 인증 방식을 완전히 대체하는게 아니라는 점입니다. 즉 SNS 로그인 기능을 넣더라도 결국은 세션/쿠키 방식이나 토큰을 활용해 인증을 거쳐야 합니다.

### Authorization Code Grant 방식을 예

- Resource Owner: User, 즉 일반 사용자를 칭합니다.
- Client: 우리가 관리하는 어플리케이션 서버(User와 혼동될 수 있는데 아닙니다!)
- Authorization Server: 권한을 관리하는 서버입니다. Access Token, Refresh Token을 발급, 재발급 해주는 역할을 합니다.
- Resource Server: OAuth2.0을 관리하는 서버(Google, Facebook, Naver 등) 의 자원을 관리하는 서버입니다. 주의할 점은 우리가 만드는 서버의 자원을 관리하는 곳이 아닙니다. Oauth 2.0 관리 서버의 자체 API를 의미합니다.

## 최슨 브라우저 동작 및 내부

https://d2.naver.com/helloworld/9274593

## 프로세스 소통 ipc

https://jhnyang.tistory.com/24

## URLSearchParams

URLSearchParams 생성자는 전체 URL을 분석하지 않습니다. 그러나, 맨 앞의 ?는 제거합니다.
https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams

## set

let difference = arr1.filter(x => !arr2.includes(x));

let difference = arr1.filter(x => arr2.includes(x));
https://p-iknow.netlify.com/data-structure/set

읽어봐 3개
https://www.zerocho.com/category/HTML&DOM/post/5b3ae84fb3dabd001b53b9ab

## 웹워커

https://developer.mozilla.org/ko/docs/Web/API/Web_Workers_API
https://medium.com/@pks2974/web-worker-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-4ec90055aa4d

Web Worker는 script 실행을 메인 쓰레드가 아니라 백그라운드 쓰레드에서 실행할 수 있도록 해주는 기술 입니다. 이 기술을 통해 무거운 작업을 분리된 쓰레드에서 처리할 수 있으며, 이를 통해 메인 쓰레드(일반적으로 UI 쓰레드)는 멈춤, 속도저하 없이 동작할 수 있게 됩니다.

네이티브에서 웹으로 접근
웹에서 네이티브(하이드브리드인 경우 많이 사용됨

Web Worker의 개념과 활용
Worker는 Worker() 생성자를 통해 생성되며 지정된 Javascript 파일에 포함된 코드를 Worker 쓰레드에서 실행합니다. (Worker는 현재 Window와 분리된 DuplicatedWorkerGlobalScope라는 별도의 Global context에서 동작합니다.) Worker 쓰레드에서 어떠한 코드도 실행할 수 있지만, 몇가지 예외가 있습니다. 예를들어 Worker 내에서는 DOM을 직접 다룰 수 없습니다. 또한 Window의 기본 메서드와 속성을 사용할 수 없습니다. 보다 자세한 정보는 Functions and classes available to workers를 참조해주세요.)

다음과 같은 롱 타임 스크립트 작업에 웹워커는 안성맞춤일 것이다.

- 매우 복잡한 수학적 계산 작업

- 원격지에 있는 리소스에 대한 액세스 작업(또는 로컬 스토리지를 액세스 하는 경우)

- 백그라운드에서 조용히 오랜시간 작업애햐 하는 경우

- UI 쓰레드에 방해 없이 지속적으로 수행해야 하는 작업 등

예제
https://iamawebdeveloper.tistory.com/105

## 웹서버 통신

https://owlgwang.tistory.com/1

## Cache-Control Header

https://kdevkr.github.io/archives/2018/understanding-cache-control/

## 반응형 이미지

https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images

## ppi & dpi

https://blank2.tistory.com/3

## 에셋의 배율

http://suiux.com/gui_specification/

도트 퍼 인치(Dots per inch, DPI)는 인쇄와 디스플레이 해상도의 측정 단위이며, 특히 1 제곱인치 (2.54 제곱센티미터) 공간 안에 만들어진 점이나 화소의 수를 말한다.

<p>Low density (120dpi) (0.75x): ldpi<br>
Medium density (160dpi) (baseline) : mdpi<br>
High density (240dpi) (1.5x) : hdpi<br>
Extra High density (320dpi) (2x) : xhdpi<br>
Extra Extra High density (480dpi) (3x) : xxhdpi<br>
Extra Extra Extra High density (480dpi) (4x) : xxhdpi</p>

## 크롤링

https://www.fun-coding.org/crawl_basic2.html

## mainfest json

https://developer.mozilla.org/ko/docs/Web/Progressive_web_apps/Installable_PWAs

https://ko.wikipedia.org/wiki/%EB%A7%A4%EB%8B%88%ED%8E%98%EC%8A%A4%ED%8A%B8_%ED%8C%8C%EC%9D%BC
매니페스트 파일(manifest file)은 컴퓨팅에서 집합의 일부 또는 논리정연한 단위인 파일들의 그룹을 위한 메타데이터를 포함하는 파일이다. 예를 들어, 컴퓨터 프로그램의 파일들은 이름, 버전 번호, 라이선스, 프로그램의 구성 파일들을 가질 수 있다.

## http 분석 요청 응답 헤더

https://developer.mozilla.org/ko/docs/Web/HTTP/Overview
https://goddaehee.tistory.com/169?category=281064

## 캐시

https://goddaehee.tistory.com/171
https://hahahoho5915.tistory.com/33

## 에러코드

https://joshua1988.github.io/web-development/http-part1/

## 웹서버통신

https://yoonjaepark.github.io/2019-01-01/how-to-request-browser

https://velog.io/@onikss793/%EC%84%9C%EB%B2%84-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80

## 웹서버 캐시

http res 304?
https://developer.mozilla.org/ko/docs/Web/HTTP/Conditional_requests

리소스가 변경되지 않았다면, 서버는 304 Not Modified 응답을 회신하게 되는데, 이는 캐시를 다시 신선한 것으로 만들어주며 클라이언트는 그 캐시된 리소스를 사용하게 됩니다. 비록 어떤 리소스를 소비하는 응답/요청 라운드 트립이 있다고 하더라도, 연결을 통해 다시 전체 리소스를 전송하는 것보다는 더 효율적입니다.

https://pjh3749.tistory.com/264
https://www.zerocho.com/category/HTTP/post/5b594dd3c06fa2001b89feb9
https://goddaehee.tistory.com/171
https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=ko

## http tcp

https://medium.com/@chrisjune_13837/web-http-tcp-ip-%EB%A9%94%EC%8B%9C%EC%A7%80%EB%9E%80-4b2721fe296f
클라이언트로부터 특정 주소로 요청이 들어오면 DNS 상에서 IP주소를 받아옵니다 → HTTP 계층에서 HTTP 메시지를 작성합니다 → TCP 계층에서 HTTP 메시지를 패킷으로 분해합니다. → IP계층에서 전송위치를 확인하고 → 네트워크를 통하여 전송합니다. 그 이후는 위의 과정의 역순으로 진행하여 처리합니다.

https://asfirstalways.tistory.com/85

## will-change

애니메이션 성능 향상시키기
https://riptutorial.com/ko/css/example/1930/-will-change--%EC%86%8D%EC%84%B1%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EA%B8%B0

## transition

?? GPU가속을 사용합니다.

## vsync

화면의 디스플레이 주기 tick
프레임 버퍼에 있는 내용을 어떤 주기로 가져올거냐 fetch

## 크롤링

??

## 다른 준비

- amp
  https://d2.naver.com/news/8185757
  https://byline.network/2016/05/1-169/

https://kakaomobility.recruiter.co.kr/app/jobnotice/view?systemKindCode=MRS2&jobnoticeSn=23180
https://kakaomobility.recruiter.co.kr/app/jobnotice/view?systemKindCode=MRS2&jobnoticeSn=16131

- 메신저 pim 기능

## rel

https://m.blog.naver.com/PostView.nhn?blogId=zoomen1004&logNo=220693042851&proxyReferer=https%3A%2F%2Fwww.google.com%2F
https://linuxism.ustd.ip.or.kr/633

## 웹지엘

## JavaScript HTML5 Canvas Animated Background

keyword: javascript canvas-bg
https://onaircode.com/javascript-html5-canvas-animated-background/
https://codepen.io/jkiss/pen/OVEeqK
https://codepen.io/VincentGarreau/pen/pnlso

## 웹 워커

웹 워커
무거운 연산 작업 시 웹워커를 도입하여 스레드를 나눠서 렌더링을 동시에 진행할 수 있습니다.
자바스크립트는 싱글스레드이지만, 브라우저에서 멀티 쓰레드를 사용할 수 있도록 웹워커 (html5)를 지원합니다.
각 브라우저 엔진에 따라 쓰레드의 개수가 다르지만, 크롬은 5개, 파이어폭스는 4개로 알려져 있습니다.
브라우저 버전별로 웹워커를 사용 유무는 다르기 때문에 웹워커를 통해 분산하여 연산 및 비동기처리를 하기 위해서는 브라우저별 처리가 필요합니다.
internet explorer는 10 이상 지원합니다. webpack을 쓰는 프로젝트의 경우는 worker-loader(https://www.npmjs.com/package/worker-loader)플러그인을 사용할 수 있습니다.

## offsetWidth

??
https://ohgyun.com/571
https://github.com/jinyowo/JS-Calendar/wiki/**offsetHeight,-innerWidth-%EC%99%80-%EB%B9%84%EC%8A%B7%ED%95%9C-%EC%86%8D%EC%84%B1%EB%93%A4-%EC%A0%95%EB%A6%AC

일반적으로 엘리먼트의 전체 크기를 알고 싶다면, `offsetWidth`와 `offsetHeight` 속성을 가져오면 된다.
이 속성은 엘리먼트의 패딩과 보더, 스크롤바의 사이즈를 포함한 값을 리턴한다.

clientWidth, clientHeight

만약, 실제로 보여지고 있는 컨텐츠가 얼마만큼의 공간을 차지하고 있는지 확인하고 싶다면,
`clientWidth`와 `clientHeight` 속성을 사용하는 것이 좋다.

이 속성은 보더와 스크롤바의 크기를 제외한 실제 컨텐츠의 크기를 리턴한다. (패딩은 포함하고 있다)

scrollWidth, scrollHeight

만약, 보이는 것과 상관 없이 실제 컨텐츠 영역이 얼마만큼의 크기를 갖고 있는지 확인하고 싶다면,
`scrollWidth`와 `scrollHeight` 속성을 확인하면 된다.

이 속성은 전체 스크롤바를 사용하게 되어 숨겨진 영역까지 포함한 크기를 리턴한다.

## 최적화 방안

https://medium.com/myrealtrip-product/fe-website-perf-part2-e0c7462ef822

웹사이트 성능 측정 및 최적화 Part 2. 렌더링

사람의 눈은 1초당 60개 이상의 프레임(60 fps, 프레임당 16.7ms)으로 이뤄진 애니메이션을 볼 때 움직임이 자연스럽다고 느낍니다. 반대로 60 fps를 초과할수록 움직임이 버벅인다는걸 느끼게 됩니다.

화면에 프레임을 추가하는 순서
자바스크립트로 스타일을 변경하는 구문이 있는지 확인한 뒤 해당되는 DOM 요소에 CSS class 또는 inline 스타일로 반영합니다.
Style: 현재 버전의 CSS를 어떤 DOM 요소에 적용해야 할지 계산합니다.
Layout: 각 요소의 너비나 위치를 갱신에 화면 상에 배치합니다.
Paint: 각 요소에 배경색, 글자 색과 같이 픽셀을 채우는 과정입니다.
Composite: 이전 과정에서 생성된 레이어를 병합합니다.
위 과정의 처리 시간이 16.7ms 을 초과하는 횟수가 늘어날수록 전체 렌더링 시간이 지연됩니다. 결국 앞서 나온 애니메이션 예제와 같이 여행자가 인지할만큼 반응이 느려지는 결과를 가져옵니다.

애플리케이션에 많은 부담을 주는 경우 레이아웃 트리거를 완전히 피하려고 노력해야 합니다!

크고 복잡한 레이아웃 및 레이아웃 스래싱 피하기 / 강제 동기식 레이아웃 레이아웃 스레싱
https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?hl=ko

https://thisblogfor.me/web/raf_perform/

이때 rAF를 사용하여 DOM을 읽는 로직은 현재 프레임에서 실행하고, DOM을 수정하기 위한 로직은 rAf와 함께 사용해 다음 프레임에서 함께 실행하도록 예약하여 레이아웃 스레싱이 줄일 수 있다.(데모)

이 패턴은 아주 훌륭하기 때문에, 다음과 같이 헬퍼 메서드를 만들어 사용하는 것을 제안한다.

---

## 지원

엔지 / 카카오

## 터치 스타트 무브? 차이

## css

“브라우저에서 하나의 애니메이션 프레임을 처리한다는 것은 애니메이션 구현에 필요한 모든 계산 과정과 계산을 통해 얻어진 픽셀 자리를 업데이트 하는 것까지 포함합니다. 목표는 브라우저가 이 과정에서 할일을 최대로 줄여서 초당 60프레임 정도의 부드러운 애니메이션을 만드는 것입니다. CSS 애니메이션 구현 비용과 직접적으로 연관되어 있는 것은 재조정(reflow)와 재색칠(repaint)를 일으키지 않는 속성들입니다.”
즉, 부드러운 애니메이션을 적용하려면 reflow와 repaint를 최소화 시켜야 합니다.

transform translate willchange

### transform

http://tcpschool.com/css/css3_transform_2Dtransform

CSS3에서는 transform 속성을 사용하여 HTML 요소의 모양, 크기, 위치 등을 자유롭게 바꿀 수 있습니다. transform 속성은 HTML 요소에 대해 다음과 같은 동작을 제공합니다.

- 해당 요소를 움직입니다.
- 해당 요소를 회전시킵니다.
- 해당 요소의 크기를 변경합니다.
- 해당 요소를 기울입니다.
- 해당 요소에 위의 네 가지 동작 중 원하는 동작들을 한 번에 적용시킵니다.

CSS3에서는 transform 속성을 사용하여 2D 변형(transform)과 3D 변형(transform)을 모두 제공합니다.

1. translate()
2. rotate()
3. scale()
4. skew()
5. matrix()

rotate // 회전하기
scale // 크기변경
translate // 이동
skew // 기울이기
(matrix // a,b,c,d,x,y를 기준)

### will-change

https://wit.nts-corp.com/2017/06/05/4571

will-change는 변화가 예상되는 요소를 브라우저에게 미리 알려줍니다. 브라우저는 실제 요소가 변화되기 전에 적절하게 최적화를 할 수 있습니다. 큰 비용이 드는 변화도 최적화로 인해 페이지의 반응성을 증가시킬 수 있습니다. will-change 속성을 사용하면 해당 레이어는 GPU에 업로드 됩니다.

will-change 속성은 4가지가 있습니다.

```
will-change: auto;
will-change: scroll-position;
will-change: contents;
will-change: transform;
will-change: top, left;
```

주의사항. 브라우저는 모든 요소에 대해 이미 최적화를 시키려고 시도하고 있습니다. will-change 속성이 사용된 요소는 최적화를 하기 위해 많은 자원을 소모하기 때문입니다. 과도한 메모리 사용과 더 복잡한 렌더링으로 성능이 더 안좋아 질 수 있습니다.

#### 사용법

브라우저에게 미리 will-change 사용을 알려주어야 합니다.
변화가 일어날 요소에 will-change를 직접 선언하면 적용이 되지 않습니다.

/_ 변화할 요소와 will-change가 같이 있으므로 적용이 안 됨 _/
.box {
transform: rotate(180deg);
transition: transform 1s linear;
will-change: transform;
}
그러므로 선택자 :hover, 자바스크립트 mouseenter 등을 통하여 미리 알려주어야 합니다.

/_ hover를 통해서 will-change를 선언 했으므로 적용 _/
.box:hover {
will-change: transform;
}
.box {
transition: transform 1s linear;
}
.box:active {
transform: rotate(180deg);
}

## 차트 라이브러리

## 지원하기

## 프론트앤드 프래임

rAF v-sync
https://thisblogfor.me/web/raf_perform/

https://medium.com/myrealtrip-product/fe-website-perf-part2-e0c7462ef822
https://cyberx.tistory.com/38

1초당 60개 이상의 프레임

## 모달

## 캔버스 공부

## 개발

- 타입스크립트 & 스토리북: https://velog.io/@velopert/design-system-using-typescript-and-storybook
- 캔버스 스네이크: https://www.youtube.com/watch?v=9TcU2C1AACw&t=252s

## 서비스 워커

https://developer.mozilla.org/ko/docs/Web/Progressive_web_apps/%EC%86%8C%EA%B0%9C
https://developers.google.com/web/fundamentals/primers/service-workers/

## 웹앱 매니페스트

https://web.dev/add-manifest/

리엑트 프로젝트

http call lib
Axios? fetch? fetch data?
await?

리덕스 활용 프로젝트 목록
https://velopert.com/3365

멀티 카운트
https://velopert.com/3346

리덕스 플래인 프로젝트 (생활코딩)
https://www.youtube.com/watch?v=bn-8isrtx0k&list=PLuHgQVnccGMB-iGMgONoRPArZfjRuRNVc&index=6

리엑트 배열 다루기
(튜토리얼 전체 목록) https://velopert.com/3613
https://velopert.com/3638#comment-1968

제스트 테스트 케이스
https://velopert.com/3587

react-hooks 훅 프로젝트활용 promise 개선
https://velog.io/@velopert/react-hooks

## Preload, Prefetch And Priorities in Chrome

What is the caching behavior for <link rel=”preload”> and <link rel=”prefetch”>?
크롬에는 네 가지의 캐시가 있다. the HTTP cache, memory cache, Service Worker cache & Push cache 이다. Preload, precache된 자원은 모두 http cache에 저장된다.
, preload는 선언적 fetch이다. Document의 onload event를 막지 않으면서 브라우저가 자원을 요청하도록 강제할 수 있다.
Prefetch는 자원이 필요할수도 있다는 것은 브라우저에게 힌트를 주지만, 로딩할지 말지는 브라우저가 결정하게 한다.

prefetch는 구글에서 광범위하게 사용되고 있고, 검색결과 페이지에서 목적 페이지를 렌더링하는데 걸리는 시간을 줄일 목적으로, 중요한 자원을 prefetch하기 위해 여전히 사용하고 있다.
Preload는 여러 케이스에서 실배포된 큰 사이트에서 사용하고 있고, 이 글에서 이에 대한 내용을 볼 수 있다. 그 전에, 우선 network stack이 preload와 prefetch를 어떻게 다르게 다루는지 알아보자.

현재 페이지서 사용될거라 확신이 드는 자원들은 preload하여라. 미래의 여러 navigation boundaries에서 사용될거라 생각되는 자원들은 prefetch하라.

https://medium.com/@koh.yesl/preload-prefetch-and-priorities-in-chrome-15d77326f646

## 클라이언트사이드 렌더링

https://blog.woolta.com/categories/9/posts/141
https://velopert.com/3425
https://jaroinside.tistory.com/24

## 웹개발의 이해

https://eunajjing.github.io/2019/07/16/boostcouse-webdev/

## Web Dev 웹 브라우저에 URL을 입력하면 어떤 일이 일어날까?

https://owlgwang.tistory.com/1

## http와 ajax

예를 들어보겠습니다. 제가 과거에 썼던 포스트가 있는데, 이 주소는 링크와 같습니다. 이 링크를 누르면, 사용자가 사용하는 웹 브라우저(크롬, 웨일, 사파리, 파이어폭스, 인터넷 익스플로러 등등)가 HTTP 규약에 따라 미디엄 서버에 해당 URL에 해당하는 웹페이지를 요청합니다. 그러면, 서버가 해당 요청에 응답하며, 그 결과인 html 문서가 브라우저 창에 뿌려지는 식입니다.

AJAX를 쓰면, 유저는 새로운 HTML을 서버로부터 받는 것이 아닙니다. 즉, 유저는 (유저가 정말 새로운 웹페이지로 이동하기를 원하는 것이 아닌 한)새로운 웹페이지로 이동하는 것이 아닙니다. 대신, 동일한 웹페이지 내에서 DOM을 변경하게 됩니다.

사용자의 이벤트로부터 Javascript는 해당 이름과 내용이 쓰여진 DOM을 읽습니다. 그리고는 XMLHttpRequest 객체를 통해 웹서버에 해당 이름과 내용을 전송합니다. 웹서버는 요청을 처리하고 XML, Text 혹은 JSON을 XMLHttpRequest 객체에 전송합니다. 그러면, Javascript가 해당 응답 정보를 DOM에 씁니다. 그렇게 결과페이지가 만들어집니다.
AJAX를 쓰면 새로운 HTML을 서버로부터 받아야 하는 것이 아닙니다. 동일한 페이지의 일부를 수정할 수도 있는 가능성이 생깁니다. 결과적으로 사용자 입장에서는 페이지 이동이 발생되지 않고 페이지 내부 변화만 일어나게 됩니다. HTML 페이지 전체를 다 바꿔야 하는 것이 아니라 부분만 바꿀 수 있게 되는 것입니다.
.

나이브 HTTP는 클라이언트쪽에서 Request를 보내고 Server쪽에서 Response를 받으면 이어졌던 연결이 끊기게 되어있습니다. 그래서 화면의 내용을 갱신하기 위해서는 다시 request를 하고 response를 하면서 페이지 전체를 갱신하게 됩니다.
AJAX는 html 페이지 전체가 아닌 일부분만 갱신할수 있도록 XMLHttpRequest객체를 통해 서버에 request 합니다. XMLHttpRequest는 서버와의 연결을 잡아둡니다. Json이나 xml형태로 필요한 데이터만 주고 받으며 DOM을 갱신하기 때문에 그만큼의 자원과 시간을 아낄 수 있습니다.

나이브한 HTTP는 웹브라우저가 서버에 요청합니다.
AJAX는 XMLHttpRequest 객체가 서버에 요청합니다.

나이브한 HTTP는 항상 페이지를 이동합니다.
AJAX는 조그마한 변경이 필요할 때, 해당 페이지 내에서 변경이 가능합니다.

그러나 여전히 AJAX로 여전히 수행하지 못하는 것들이 있습니다.
.
.
왜냐하면, AJAX도 여전히 HTTP로 서버와 통신하기 때문입니다. 즉, AJAX도 HTTP의 한계를 완전히 벗어나지 못했습니다. HTTP는 “클라이언트의 요청이 있고 그 다음 서버로부터 응답을 받는 상황”인데, 이 틀로부터 벗어나지 못했습니다.
“클라이언트의 요청이 있고 그 다음 서버로부터 응답을 받는 상황”에서 벗어나는 예를 들어보겠습니다. “클라이언트의 요청이 없음에도, 서버로부터 응답을 받는 상황”을 들어보고자 합니다.

클라이언트의 요청이 없음에도, 서버로부터 응답을 받는 상황”에 대한 미봉책[RFC6202]이었습니다. 즉, 데이터 수신을 위해 서버가 클라이언트에게 전송해 주는 푸시(push)방식이 아니라 여전히클라이언트가 서버에에게 요청하는 폴링(polling) 방식이었습니다.
이와 같은 애로사항은 HTML5 개발 과정에 녹아들었습니다. 결국, HTML5은 순수 웹 환경에서 실시간 양방향 통신이 가능해지게 만들어졌습니다. 그 스펙의 명칭이 바로 ‘웹 소켓(Web Socket)’ 입니다.

이제 동시대 즉 웹소켓의 시대로 넘어왔습니다. 2014년 10월 28일의 HTML5 버전이 나올 때 함께 등장했던 웹소켓은 2016년 11월 1일 HTML5.1 버전이 나오고 2017년 12월 14일 HTML5.2 버전이 나올 때까지 더더욱 발전했습니다.
웹소켓은 약속입니다. HTTP와 같이 약속입니다. 브라우저와 서버가 양방향 통신을 할 수 있도록 지원하는 프로토콜입니다.

웹소켓은 HTTP의 문제를 해결해주는 약속입니다. HTTP에서 원리적으로 해결할 수 없었던 문제는 “클라이언트의 요청이 없음에도, 그 다음 서버로부터 응답을 받는 상황”이었는데요. 웹소켓은 HTTP가 해결할 수 없었던 이 문제를 해결하는 새로운 약속이었습니다. 즉, 브라우저가 서버에 데이터를 요청하고 서버가 브라우저에 데이터를 보내기 위해 별다른 제약이 없습니다.
웹소켓에서는 서버와 브라우저 사이에 양방향 소통이 가능합니다. 브라우저는 서버가 직접 보내는 데이터를 받아들일 수 있고, 사용자가 다른 웹사이트로 이동하지 않아도 최신 데이터가 적용된 웹을 볼 수 있게 해줍니다. 웹페이지를 ‘새로고침’하거나 다른 주소로 이동할 때 덧붙인 부가 정보를 통해서만 새로운 데이터를 제공하는 웹서비스 환경의 빗장을 본질적으로 풀어준 셈입니다.
웹소켓 약속 하에서는 실시간 소통이 편안해지게 됩니다. 웹에서도 채팅이나 게임, 실시간 주식 차트와 같은 실시간이 요구되는 응용프로그램의 개발을 한층 효과적으로 구현할 수 있게 되었습니다. 가상화폐의 분산화 기술의 핵심도 web socket으로 구현할 수 있다는 점 언급해두고 싶습니다.

HTTP는 통신 제약이 있는 약속입니다.
AJAX로 HTTP의 통신 제약으로부터 조금 벗어날 수 있었습니다.
Websocket은 HTTP의 통신 제약을 해결한 새로운 약속입니다.

https://medium.com/@chullino/http%EC%97%90%EC%84%9C%EB%B6%80%ED%84%B0-websocket%EA%B9%8C%EC%A7%80-94df91988788

## 웹 최적화

https://znznzn.tistory.com/29

## 브라우저 동작

https://kim6394.tistory.com/217

### 그외

#### 요가..

### CSR & SSR

https://velog.io/@rjs1197/SSR%EA%B3%BC-CSR%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

https://velog.io/@zansol/%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C%EB%A0%8C%EB%8D%94%EB%A7%81SSR-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%82%AC%EC%9D%B4%EB%93%9C%EB%A0%8C%EB%8D%94%EB%A7%81CSR

클라이언트 사이드렌더링.Simgle Page Application

SPA는 최초 한 번 페이지 전체를 로딩한 후 데이터만 변경하여 사용할 수 잇는 애플리케이션.

SPA 는 클라이언트사이드 렌더링 방식. 기본적으로 페이지 로드가 없고 모든 페이지는 단순히 HTML5 History에 의해 렌더링 된다.

그래서 언제 새로운 데이터를 불러와야 할지 스스로 정해서 구현해야 한다.

전통적인 웹방식 SSR 은 이 SPA 방식에 비해 성능 문제 이슈가 있었다.

전통적인 웹 대부분은 서버사이드 렌더링 방식인데. 브라우저에 나타나는 형태 그대로를 HTML로 만들어 제공하고

브라우저는 HTML을 표시하는 방식이었다.

웹에서 제공되는 정보가 정말 많기 때문에 전통적인 방식은 성능 문제에 이슈를 낳았다. 요청시마다 새로고침이 일어나며 페이지를 로딩할때마다 서버로부터 리소스를 전달받아 해석하고 화면에 렌더링 하는 방식이기 때문에.

이것은! 사용자와 인터랙션이 많은 요즘 웹앱에게 충분하지 않는 방법일 수 있다.

렌더링을 서버쪽에서 하는 것은 그만큼 렌더링을 위한 서버자원이 사용되는 것이고 불필요한 트래픽도 낭비되는것.

### 덕타이핑

https://ko.wikipedia.org/wiki/%EB%8D%95_%ED%83%80%EC%9D%B4%ED%95%91

### 노드 & 런타임

https://asfirstalways.tistory.com/99

### webpack

https://gompro.postype.com/post/1699968

https://brightparagon.wordpress.com/2018/06/27/webpack-v4-development-configuration/

https://perfectacle.github.io/2016/11/14/Webpack-devtool-option-Performance/

https://zuminternet.github.io/ZUM-Webpack-dev-proxy-part1/

### useMemo

https://medium.com/@iamssen/react-16-7-useeffect-usememo-usecallback-%EC%9D%98-second-parameter-inputs-775298f2d291

https://nikgrozev.com/2019/04/07/reacts-usecallback-and-usememo-hooks-by-example/

https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/

https://www.codebeast.dev/react-memoize-hooks-useRef-useCallback-useMemo/

### 네이티브앱에서 웹앱으로: 모바일 웹앱의 현주소

프로그레시브 웹 앱 : 탭에서 벗어나기
https://d2.naver.com/helloworld/179084

REST API 액세스 토큰(access token)
https://devhaks.github.io/2019/05/31/oauth2/
https://tansfil.tistory.com/59
https://docs.iamport.kr/tech/access-token
아임포트 REST API서비스는 여러분의 가맹점의 결제 상세정보를 조회하거나 환불 요청 또는 에스크로 결제를 처리할 수 있는 기능을 제공합니다. 하지만 이는 가맹점의 사적 리소스(private resource)를 다루기 때문에 해당 리소스의 소유권을 인증한 후 접근할 수 있습니다.
이때 액세스 토큰(aceess token)을 발급받고 API 요청에 포함하여 가맹점의 소유권을 증명하고 사적 리소스(private resource)에 접근할 수 있습니다.
액세스 토큰(access token)이란?
아임포트 REST API서비스는 토큰 기반 인증을 사용합니다. 사적 리소스(private resource)에 접근하는 아임포트 REST API에 대한 모든 요청에 토큰이 포함되어 있는지, 또 해당 토큰이 유효한지의 여부를 검증함으로써 인증 절차를 수행합니다.
이때 사용하는 토큰을 액세스 토큰(access token)이라 부릅니다.

oAuth 로그인

https://tansfil.tistory.com/60

쉽게 알아보는 서버 인증 3편(SNS 로그인, OAuth 2.0)

OAuth 프로토콜의 기능 중 하나로 SNS 로그인이 있는겁니다!

지금부터 OAuth 의 정의를 시작으로 어떤 방식으로 SNS 로그인이 작동되는지 차근차근 알아보도록 하겠습니다.

참고 포스팅

http://tansfil.tistory.com/58 (세션/쿠키, JWT를 이용한 인증)

http://tansfil.tistory.com/59 (Access Token + Refresh Token을 이용한 인증)

고차 함수(higher-order function)의 정의는 무엇인가요?
고차 함수는 다른 함수를 매개 변수로 사용하여 어떤 데이터를 처리하거나, 결과로 함수를 반환하는 함수입니다. 고차 함수는 반복적으로 수행되는 어떤 연산을 추상화하기 위한 것입니다. 전형적인 예시는 배열과 함수를 인수로 취하는 map입니다. map은 고차 함수를 사용하여 배열의 각 항목을 변환하고, 변환된 데이터로 새로운 배열을 반환합니다. JavaScript에서 흔히 볼 수 있는 다른 예로 forEach, filter, reduce가 있습니다. 다른 함수에서 함수를 반환하는 많은 사용사례가 있기 때문에 고차 함수는 배열을 조작할 필요가 없습니다. Array.prototype.bind는 JavaScript에서 그러한 예시 중 하나입니다.

Map

ttribute"와 "property"의 차이점은 무엇인가요?
attribute는 HTML 마크업에 정의되지만 property는 DOM에 정의됩니다. 차이점을 설명하기 위해 HTML에 다음 텍스트 필드가 있다고 가정해 봅시다: <input type="text" value="Hello">.

const input = document.querySelector('input')
console.log(input.getAttribute('value')) // Hello
console.log(input.value) // Hello
그러나 텍스트 필드에 "World!"를 추가하면 이렇게 될것입니다.

console.log(input.getAttribute('value')) // Hello
console.log(input.value) // Hello World!

////

S.I.T(Site Integration Test) : 현장 통합 시험

S.A.T(Site Acceptance Test) : 현장 인수 시험

F.A.T(Factory Acceptance Test) : 공장 인수 시험

UAT(User Acceptance Testing)

: 새로운 시스팀이나 변경된 시스템의 공식적 승락을 받는 시험.

최종 사용자들이 시스템을 사용해 보고 만족해야 UAT에 통과할 수 있다.

프록시를 사용하는이유
찰스 피들러
https://withpg.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%A4%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95

클라이언트 사이드 서버사이드

https://www.popit.kr/react-%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81/

네이티브앱 vs 모바일웹앱 vs 하이브리드앱

https://m.blog.naver.com/acornedu/221012420292

Charles
https://www.charlesproxy.com/documentation/ios/

react 상속 합성

https://ko.reactjs.org/docs/composition-vs-inheritance.html
https://blog.sonim1.com/186

면접
https://hackernoon.com/10-react-js-articles-every-web-developer-should-read-f5b745a348dc
https://www.freecodecamp.org/news/grabs-front-end-guide-for-large-teams-484d4033cc41/
https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Korean/questions/javascript-questions.md

https://basarat.gitbooks.io/typescript/docs/tips/barrel.html

barrel



테스트? tdd bdd ddd
https://asfirstalways.tistory.com/296

리덕스 사가 모달?

클라이언트 사이드렌더링 서버 사이드 렌더링 차이점과 리엑트의 우수한점????

코드 커버리지
https://afrobambacar.github.io/2018/10/code-coverage-with-jest.html

https://medium.com/@pakss328/%EC%BD%94%EB%93%9C%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-code-coverage-991e79da9e5f

https://medium.com/@rinae/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%A6%AC%EB%8D%95%EC%8A%A4-%EC%95%B1%EC%9D%84-jest%EC%99%80-enzyme%EC%9C%BC%EB%A1%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%98%EB%A9%B0-%EC%96%BB%EC%9D%80-%EA%B5%90%ED%9B%88-8fc3e2c6615d

dummy stub mock

https://m.blog.naver.com/PostView.nhn?blogId=palfuni&logNo=120154483985&proxyReferer=https%3A%2F%2Fwww.google.com%2F

https://www.jpstory.net/2013/07/26/know-your-test-doubles/

1. 모든 프로그램이 개발하고 테스트할 때 완성되어 있는 것은 아니다. 그래서 필요한 것이 Stub이다.

Dummy
가장 기본적인 유형으로, 매개변수 값과 같이 작업을 수행하는 메소드가 없는, 값 전달만을 위한 객체를 말한다.

Stub은 로직이 없고 단지 원하는 값을 반환합니다. 테스트시에 “이 객체는 무조건 이 값을 반환한다”고 가정할 경우 사용할 수 있습니다. Stub은 보통 작성하기 쉽지만 불필요한 boilerplate 코드를 줄이기 위해서 Mocking Framework을 이용하는게 편합니다.

Mock은 “어떤 메소드가 호출 될 것이다”라는 행위에 대한 예상을 가지고 있습니다. 만약 그 예상대로 메소드가 호출 되지 않을 경우 테스트는 실패합니다. 이렇듯 Mock은 객체 사이의 행위(interaction)를 테스트하기 위해 사용합니다. 식별 할 수 있는 상태 변경이 없거나 반환 값으로 확인 할 수 없는 경우에 유용합니다. 예를 들면 어떤 코드가 디스크에서 read 작업을 하는데 하나 이상의 디스크에서 read 작업을 수행하지 않도록 하려는 경우, read 작업을 수행하는 메소드가 한번만 호출 되었는지 검증하기 위해 Mock을 사용할 수 있습니다.

테스트 코드를 정말 작성해야 하는가?
https://blog.outsider.ne.kr/1275

UI오ㅓ UX
https://m.blog.naver.com/moolsaess/221159385304

웹앱? 웹뷰?

웹팩
http://jeonghwan-kim.github.io/js/2017/05/15/webpack.html

확장성을 고려한 컴포넌트
https://velog.io/@kyusung/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B5%90%EA%B3%BC%EC%84%9C-%ED%99%95%EC%9E%A5%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8

스토리북 입문 가이드
https://hyunseob.github.io/2018/01/08/storybook-beginners-guide/

컴포넌트 제대로 만들기
https://hyunseob.github.io/2019/06/02/react-component-the-right-way/

리엑트 모듈
https://gloriajun.github.io/frontend/2019/04/11/react-code-splitting.html#the-async-component-hoc

8-point 그리드란?
http://uidesignguides.com/8-point-%EA%B7%B8%EB%A6%AC%EB%93%9C%EB%A1%9C-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/
https://brunch.co.kr/@blackindigo-red/8
https://spec.fm/specifics/8-pt-grid

React를 이용해 재사용성을 갖춘 디자인 시스템 구축하기
https://code.tutsplus.com/ko/tutorials/build-a-reusable-design-system-with-react--cms-29954

Babel과 Webpack을 이용한 ES6 환경 구축
https://poiemaweb.com/es6-babel-webpack-1
https://poiemaweb.com/es6-babel-webpack-2

Webpack4 for React (리액트를 위한 웹팩4) - 1
https://velog.io/@padakim/Webpack4-for-React-%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9B%B9%ED%8C%A94-1-

## 블로그

https://www.robinwieruch.de/conditional-rendering-react/
https://blog.logrocket.com/how-to-use-react-createref-ea014ad09dba/

http://cplusplus5.egloos.com/

## go 크로스 컴파일

https://mingrammer.com/cgo-cross-compile-for-mac-for-linux/

## 디자인 패턴

## 검색 알고리즘

트리, 라운드로빈

## 웹 개발 생태계

- https://clay1987.blog.me/221405825662

## nextjs

https://blueshw.github.io/2018/04/15/why-nextjs/

nextjs 로 프로젝트를 진행한지도 반년 가까이 흘렀습니다. nextjs는 서버사이드렌더링(SSR)과 code splitting 등을 지원하는 reactjs 전용 프레임워크입니다. 2 년도 채 안되는 시간에 벌써 5.x(곧 버전 6 도 나올것 같네요) 버전까지 등장했습니다. 그만큼 많은 사람들의 관심속에 발전하고 있다는 뜻이겠죠. 사용법은 충분히 익숙해졌지만, 시간에 쫓기고 일정에 쫓기다보니 nextjs 가 동작하는 방식에대한 이해는 부족하다 느껴집니다. nextjs 가 reactjs 코드를 어떻게 빌드하고, SSR 은 어떤 과정을 거치며 브라우저에서 어떻게 동작하는지 살펴보도록 하겠습니다.

SSR 은 어떤 과정을 거치나?
SSR 은 말그대로 서버에서 렌더링을 한다는 것입니다. 10 여년전에 많이 유행했던 PHP 나 JSP 가 대표적인 서버렌더링 프레임워크입니다. 유저가 어떤 url 로 데이터를 요청하면 서버는 미리 html 파일을 만들어 클라이언트(브라우저)에게 전달하는 방식입니다. next 에서 SSR 도 크게 다르지 않습니다. 서버(node)를 띄우고 유저가 요청하면 html 을 생성하여 브라우저에 전달합니다. 구조는 동일합니다. 다른점이 있다면, 모든 요청에 대해 서버에서 렌더링을 진행하지는 않고 초기 렌더링만 서버가 담당합니다. 그 이후에는 next/router를 이용하여 클라이언트에서 렌더링합니다. next 가 해주는 일은 이게 전부입니다. 간단하지만, 이 방식으로 SPA 의 단점으로 꼽히는 긴 초기 렌더링 시간을 대폭 줄일 수 있습니다.

---
layout: post
title: TODO
categories: TODO
---

## module.exports module export default 차이는?



## pragma

http://sarghis.com/blog/941/
https://mayu.tistory.com/8
https://en.wikipedia.org/wiki/Pragma_once
https://jasonformat.com/wtf-is-jsx/

. JSX Pragma: transpile to h()
https://preactjs.com/guide/v8/switching-to-preact/

Rendering JSX
https://preactjs.com/guide/v8/getting-started/#rendering-jsx

## ts 핸드북 & jsxFactory
https://joshua1988.github.io/ts/config/tsconfig.html#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC-%EC%86%8D%EC%84%B1
https://www.typescriptlang.org/docs/handbook/compiler-options.html



## 모듈
https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript
https://www.freecodecamp.org/news/javascript-modules-a-beginner-s-guide-783f7d7a5fcc/?source=latest---------1
https://www.freecodecamp.org/news/javascript-modules-part-2-module-bundling-5020383cf306/#.hgguh3g4o
모듈 패턴
객체 리터럴 표기법
AMD 모듈
CommonJS 모듈
ECMAScript 하모니 모듈

## js 디자인 패턴 & 모듈패턴
https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript
http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html





## preact
https://preactjs.com/guide/v8/differences-to-react/#whats-added
import React from 'react' -> import {h} form 'preact'
plugin-transform-react-jsx
rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"],
            plugins: [
              [
                "@babel/plugin-transform-react-jsx",
                {
                  pragma: "h",
                  pragmaFrag: "Fragment",
                },
              ],
            ],
          },
        },
      },
className -> class
this.handleXX -> linkstate
https://medium.com/@janavianand/preact-cef54475648b

## bundle
https://www.freecodecamp.org/news/javascript-modules-part-2-module-bundling-5020383cf306/#.hgguh3g4o

## bfcache
https://jang8584.tistory.com/239
https://ifuwanna.tistory.com/63
https://programmingsummaries.tistory.com/tag/BFCache
https://m.blog.naver.com/PostView.nhn?blogId=youreme&logNo=110162034595&proxyReferer=https:%2F%2Fwww.google.com%2F
https://tnsgud.tistory.com/387
https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Working_with_BFCache


## mvc12
https://nickjoit.tistory.com/9
https://tapasnote.tistory.com/5
https://seongmun-hong.github.io/spring/MVC1-MVC2
https://creator0609.tistory.com/entry/MVC1-MVC2-%EC%B0%A8%EC%9D%B4


## arr & set
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Set


## SPA
https://poiemaweb.com/js-spa


## DAO

https://jungwoon.github.io/common%20sense/2017/11/16/DAO-VO-DTO/

https://gmlwjd9405.github.io/2018/12/25/difference-dao-dto-entity.html


## 웹팩
https://hoilzz.github.io/webpack/5-production/

development

강력한 소스 맵
실시간 재로드 또는 핫 모듈 교체가 가능한 localhost 서버
production

축소 번들
더 가벼운 무게 소스 맵
로드 시간을 개선하기위한 최적화 된 자산
webpack 공홈으로 인해 웹팩 설정 작성하기를 권장한다.

common.js

엔트리, 출력, babel-loader
플러그인은 HMR은 개발이 필요합니다
dev.js

HMR, devServer, devtool
prod.js

모드 : 생산

process.env.NODE_ENV === 'production'드롭 할 것입니다. webpack v4부터는 mode자동으로 DefinePlugin(NODE_ENV 같은 환경 변수 설정)

여튼 모드 : 생산이 자동으로 NODE_ENV가 생산으로 설정됩니다.


소스 매핑
생산 대표, 벤치 마크 테스트 (?) devtool: source-map을 권장한다. 빌드 속도가 아주 빠르면서 생산 모드에서 쓰기 적합하다.

inline-***과 eval-***은 생산에서 쓰지 말자. 전체 크기.

## 배열과 링크드 리스트?
...

## 요가
https://class101.net/products/yoga

## 부트스트랩하다

둘러보기로 가기검색하러 가기
부트스트랩(bootstrap) 또는 부트스트래핑(bootstrapping)은 "현재 상황에서 어떻게든 한다"는 뜻이다. 또, 사물의 초기 단계에서 단순 요소로부터 복잡한 체계를 구축하는 과정을 가리키는 경우도 있다.

부트스트랩 (컴퓨팅): 더 복잡한 도구를 만들 수 있도록 도와 주는 단순 도구를 만들거나 적재함으로써 복잡한 소프트웨어 도구를 만들거나 컴퓨터를 시작하는 것을 말한다. 줄여서 시동이라고도 할 수 있으며, 이는 컴퓨터를 시작하는 과정을 서술해 준다.
부트스트랩 (컴파일러): 언어 그 자체를 사용하여 컴퓨터 언어에 맞춰 컴파일을 기록하는 것을 말한다.

https://ko.wikipedia.org/wiki/%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9

https://ict-nroo.tistory.com/21

https://namu.wiki/w/Bootstrap
https://learningcarrot.wordpress.com/2015/11/12/%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-bootstrapping/


https://medium.com/javascript-in-plain-english/i-tested-a-react-app-with-jest-testing-library-and-cypress-here-are-the-differences-3192eae03850
내가 지적하고 싶은 한 가지는 CRA (Create-React-App)를 사용하여 React 앱을 부트 스트랩했다는 것입니다. 이는 Jest가 기본적으로 설치되어 제공됨을 의미합니다. Jest는 실제로 Jest 설정보다 더 많은 장소에서 편리하기 때문에 우리는 설정에서 이것을 제거하지 않을 것입니다. 원하는 경우 물론 완전히 제거 할 수도 있습니다.


## 코딩가이드
https://itmining.tistory.com/72
https://www.mimul.com/blog/why-we-argue-style/
## polyfill 적용
https://okchangwon.tistory.com/3

## pacakge @
extract-text-webpack-plugin으로 인스톨 하면 webpack 버전3가 호환이 되어있는 패키지가 인스톨되어 버리므로 webpack4과의 호환을 위해서 @next를 붙이자.

※extract-text-webpack-plugin 대신에 mini-css-extract-plugin을 사용해도 해결된다고 함

npm i extract-text-webpack-plugin@next -–save-dev


## 모듈러
https://perfectacle.github.io/2016/11/18/Module-bundling-with-Webpck/
## 번들러
https://www.freecodecamp.org/news/javascript-modules-part-2-module-bundling-5020383cf306/#.hgguh3g4o

이 문제를 해결하기 위해 요청 수를 줄이기 위해 모든 파일을 하나의 큰 파일 (또는 경우에 따라 몇 개의 파일)로 묶거나 "연결"합니다. 개발자가 "빌드 단계"또는 "빌드 프로세스"에 대해 이야기하는 것을들을 때, 이것이 그들이 말하는 것입니다.

번들링 작업 속도를 높이는 또 다른 일반적인 방법은 번들 코드를 "최소화"하는 것입니다. 축소는 코드의 기능을 변경하지 않고 내용의 전체 크기를 줄이기 위해 소스 코드에서 불필요한 문자 (예 : 공백, 주석, 줄 바꿈 문자 등)를 제거하는 프로세스입니다.

데이터가 적을수록 브라우저 처리 시간이 줄어들어 파일을 다운로드하는 데 걸리는 시간이 줄어 듭니다. “ underscore-min.js ” 와 같이“최소”확장자를 가진 파일을 본 적이 있다면 축소 버전이 정식 버전에 비해 매우 작고 읽을 수없는 것 입니다.

Gulp 및 Grunt와 같은 작업 실행기는 개발자가 연결 및 축소를 간단하게 수행하므로 사람이 읽을 수있는 코드가 개발자에게 노출 된 상태를 유지하면서 컴퓨터에 최적화 된 코드가 브라우저에 번들로 제공됩니다.


## devtool
https://trustyoo86.github.io/webpack/2018/01/10/webpack-configuration.html


module.exports module export default 차이는?

## 알아보기


module loose 모드?
활성화 하지 않으면 호환성이 없는 코드로 트랜스파일링 된다?


## webpack 설정


https://velog.io/@padakim/Webpack4-for-React-%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9B%B9%ED%8C%A94-1-
react : 리액트를 사용하기 위하 필수 라이브러리 입니다.
react-dom: 리액트 라이브러리 입니다. 브라우저를 위한 DOM 메소드를 제공합니다.
react-router-dom: 브라우저를 위한 라우팅 기능을 제공합니다.
@babel/core: 바벨을 사용하기 위한 필수 라이브러리입니다.

바벨은 ES6/ES7 코드를 ES5 코드로 트랜스파일링 하기 위한 도구입니다.
@babel-polyfill: ES2015의 새로운 객체와 메소드를 사용할 수 있도록 도와줍니다.
@babel/preset-env: 최신 자바스크립트 기능을 ES5로 트랜스파일 해주는 라이브러리입니다.

바벨 7버전부터 사용 가능한 라이브러리입니다. 바벨 7버전 아래의 경우 stage-0, stage-1, stage-2, stage-3을 설치하여 트랜스파일 해줘야합니다.
@babel/preset-react: 리액트 환경(JSX)을 위한 라이브러리입니다.
@babel/plugin-proposal-class-properties: 클래스 프로퍼티를 사용할 수 있도록 도와주는 바벨 플러그인입니다.
babel-loader: 바벨과 웹팩을 이용해 자바스크립트 파일을 트랜스파일링 합니다.
html-webpack-plugin: 웹팩 번들에 html파일을 제공하는 웹팩 라이브러리입니다.
css-loader: css 파일을 import 또는 require할 수 있도록 도와주는 웹팩 라이브러리입니다.
style-loader: 읽은 css파일을 style태그로 만들어 head태그에 삽입해주는 웹팩 라이브러리입니다.
webpack: 웹팩을 사용하기 위한 필수 라이브러리입니다.
webpack-cli: 웹팩 커맨드라인 인터페이스 라이브러리입니다.
webpack-dev-server: 웹팩 개발서버 라이브러리입니다.

https://hoilzz.github.io/webpack/2-add-babel/
https://trustyoo86.github.io/webpack/2018/01/10/webpack-configuration.html
https://okchangwon.tistory.com/3
https://www.zerocho.com/category/Webpack/post/58aa916d745ca90018e5301d
https://medium.com/@simsimjae/webpack4-splitchunksplugin-%EC%98%B5%EC%85%98-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0-19f5de32425a
https://programmingsummaries.tistory.com/401
https://hyeribo.github.io/frontend/react-quick-starter/#

## preset
https://velog.io/@pop8682/%EB%B2%88%EC%97%AD-%EC%99%9C-babel-preset%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%98%EA%B3%A0-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%9C%EA%B0%80-yhk03drm7q

## babel 모듈
https://velog.io/@pop8682/%EB%B2%88%EC%97%AD-React-webpack-%EC%84%A4%EC%A0%95-%EC%B2%98%EC%9D%8C%EB%B6%80%ED%84%B0-%ED%95%B4%EB%B3%B4%EA%B8%B0

## npx
https://geonlee.tistory.com/32

## 바벨로더

## unhandled promise reject
async함수 안에서 예상치 못한 에러가 발생하는 경우, 프로미스를 반환하여 에러처리를 하지 않는 경우, 내부적으로는 서비스는 실행되나 unhandled promise rejction 문구를 출력한다. express 는 에러발생을 인식하지 못한채 응답만 지연되게 한다.

해결안, express에서 라우팅핸들러함수에서 오류가 발생한경우 내부적으로 미들웨어의 세번째 파라메터인 next함수를 호출하여 error를 전달하여 마지막 에러처리 미들웨어에서 받아 적절하게 처리할 수 있도록 한다.

async awiat 함수는 기본적으로 promise를 리턴해주는 구조이다. 그렇다는 건 그안에서 발생한 오류를 단순하게 바깥으로 던져서 잡는게 아니라 promise의 catch함수를 통해 처리해주어야 한다는 의미이다. 
라우팅 핸들러함수가 리턴한 reject된 promise를 적절하게 처리해주지 않고 있어서 발생

https://programmingsummaries.tistory.com/?page=3
async await 는 try catch 로 에러가 잡히지 않는가?
async함수에서 발생한 오류는 일반 함수내에서 try/catch로 잡을 수 없다. 해결안으로 함수를 또 async에서 호출한당.. 아니면 프로미스를 받아 catch로 reject처리


async function err () {
   throw new Error('오류 발생');
}

(function () {
    try {
        err();
    }
    catch (e) {
        console.log('에러', e);
    }
}) ();
// Uncaught (in promise) Error

## node 하모니 옵션
https://nodejs.org/ko/docs/es6/
https://stackoverflow.com/questions/13351965/what-does-node-harmony-do
이전 버전의 nodejs에서 ECMAScript 6 기능을 실행하려는 경우 --harmony 플래그를 사용할 수 있습니다. 최신 버전의 노드는 ES6을 지원하므로 --harmony 플래그가 필요하지 않습니다.



## enzyme
https://www.vobour.com/jest%EC%99%80-enzyme%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-react-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8-te

https://shs400.github.io/2019/01/23/enzyme/

\\\



https://appear.github.io/2018/11/23/REACT/react-translate-13/

https://www.robinwieruch.de/react-function-component


## NODE JS - 모듈이란? , module.export 와 exports의 차이

출처: https://dydals5678.tistory.com/97 [아빠개발자의 노트] 
https://programmingsummaries.tistory.com/340

## npm Dependencies devDependencies

package.json 파일 내의 dependencies, devDependencies의 차이를 알기 위해서 구글링을 하던 중, 보아도 잘 모르겠는 부분이 있어서 우리 drfts프로젝트인 lib-tz의 package.json파일을 보았지만.. 잘 모르겠어서 구글링의 도움을 받았습니다.

결과 1 => 프로젝트를 개발/테스트하려는 것이 아니라 활용만 하려는 목적이라면 개발의존성을 설치하는 것이 불필요하므로, devDependencies의 패키지를 제외하고 설치할 수도 있다. 

결과 2 => dependencies, devDependencies는 해당 패키지가 다른 패키지에 의존할 경우 의존성에 대한 항목이다

결과 3 => dependencies와 devDependencies의 차이는 배포용 패키지(실제 상품에서 사용할 패키지)와 개발용 패키지(목, 테스트 패키지 등)의 차이다.

결과 4 => dependencies 는 이 패키지에 의존하는 `다른 프로젝트에서 구동`시키기 위한 의존성이다. `즉, 이 패키지를 활용할 때 필요한 의존성을 명시`한다. npm install --save 명령을 통해 패키지를 설치하면 이 항목에 프로젝트 정보가 저장된다.

devDependencies 에는 `이 패키지를 테스트하거나 개발할 때 필요한 패키지들을 명시`한다. npm install --save-dev 명령을 통해 패키지를 설치하면 이 항목에 프로젝트 정보가 저장된다.



::: 결론 ::: 우리가 개발 시 필요한 (컴파일러 같은) 라이브러리들은 devDependencies에 적어주고, 진짜 우리 프로젝트에서 기술스펙으로 사용되어야할 라이브러리들은 dependencies에 적어줍니다.


어떤 라이브러리가 프로젝트의 컴파일(빌드) 타임에 필요하면 devDependencies에 넣고, 런타임에도 계속 쓰이는 것이면 dependencies에 넣어야 합니다.

원래는 컴파일을 하면 컴퓨터는 알아듣지만, 인간이 이해하기에 상당히 난해한, 바이너리(0,1)로 결과가 나오는데, 트랜스파일은 컴퓨터가 알아들을 수 있는 형태가 아닌 브라우저가 알아들을 수 있는 형태로 코드를 바꿉니다. 근데 그 결과를 인간이 딱히 못알아보는 것도 아니예요. 결과가 바이너리도 아니고요. 사실 번역하는 과정에 가깝죠. 번역한다는 말의 translate 와 compile을 그냥 합쳐서 만들어둔 단어입니다.

https://github.com/saeromCho/shumblr/wiki/package.json-%ED%8C%8C%EC%9D%BC-%EB%82%B4%EC%9D%98-dependencies%EC%99%80-devDependencies%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EA%B3%BC-%EC%B6%94%EA%B0%80%EC%A0%81%EC%9D%B8-%EA%B3%B5%EB%B6%80(About-Babel)


## npm 버전
틸트 캐럿 골벵이
틸트는 첨부터 끝까지
캐럿은 API호환성이 깨지는 경우를 대비해 1점때 2점때만 자동 버전업


~(틸트)와 ^(캐럿)의 차이는 아래와 같다.

~(틸트)는 패치 버전 범위 내에서 업데이트한다. :

~0.0.1 : 0.0.1 <= version < 0.1.0
~0.1.1 : 0.1.1 <= version < 0.2.0
^(캐럿)는 마이너 버전 범위 내에서 업데이트한다. :

^1.0.2 : 1.0.2 <= version < 2.0
npm semver calculator에 방문하면 패키지 별로 버전 표기법을 사용하여 업데이트 버전 범위를 확인할 수 있다.

버전에 대한 보다 자세한 사항은 semver : The semantic versioner for npm를 참조하기 바란다.



https://blog.outsider.ne.kr/1041


## UX와 CX는 어떻게 다른가?
- UX: User 제품/시스템/서비스를 이용하는 데 있어 사용자의 인지 반응, 사용상 기대하는 바
User: 무언가를 이용하거나 사용하는 사람. 고객일수도 고객은 아닐 수도 있음

사용자연구
페르소나
사용자 Journey 경로
사용성테스트
정보구조
인터랙션 디자인
디자인법칙
가이드라인

=> 서비스오 제품에 잘 적용되도록


- CX: Customer 서비스 공급자와 고객의 관계가 지속됨에 따라 관련하여 고객이 체험하는 모든 경험 총체
Customer: 고객 또는 잠재고객

고객조사
페르소나
고객 Journey
프로토타입
디자인
비즈니스 전략
비즈니스/서비스 사례
KPI

회사의 브랜드전략, 비즈니스 전략, 사업상 성과지표 함께 염두하고 고민

UI는 인터페이스 디자이너, UI개발자, 사용자 조사를 경험할 수 있는 사람, 즉 개발자는 UI를 고민할 수 있다. 



고민한다. CX를 경험하는 사람은 마케팅매니저, 프러덕트매니저, 시장조사, 비지니스 분석, 고객전략 매니저업무를 경험한 사람이 적합하다.


!! 둘의 공통점은 사람 또는 그들의 니즈에 대한 것! 공감.

접근 방식이 다르다. 
제품을 사용함에 있어 니즈를 조사하고 분석. 인터페이스 설계 검증 테스트

벗, 제품 서비스에만 한하지 않고 전반적인 라이프스타일부터 구체적인 이즈가 무엇인지 이해해야 한다. 브랭ㄴ드와 만나는 접점을 고민. 고객경험을 더 좋게 만듦으로써 궁극적으로는 비즈니스 목표를달성시키는 것이 최종 목표이다. 전략안!

https://uxd-trend.tistory.com/37

## ITSM IT Service Management
서비스 요청 프로세스
서비스 요청관리는 서비스문의, 업무지원요청, 개발요청 인프라 변경요청등 고객으로부터 접수되는 모든 유형의 요청을 관리



## 자료구조 알고리즘

## 제트인덱스와 오퍼시티

## 리펙터링
사전적 의미는?

리팩터링은 소프트웨어 공학에서 '결과의 변경 없이 코드의 구조를 재조정함'을 뜻한다. 주로 가독성을 높이고 유지보수를 편하게 한다. 버그를 없애거나 새로운 기능을 추가하는 행위는 아니다. 사용자가 보는 외부 화면은 그대로 두면서 내부 논리나 구조를 바꾸고 개선하는 유지보수 행위이다. 

외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법입니다. 코드가 작성된 후에 디자인을 개선하는 작업입니다.?

https://asfirstalways.tistory.com/373


## 호출스택 쌓이는 순서
지역변수 흐름 파악 필요

## 키프레임
??

## 모달
??

## history api
History API 를 위해서는 세션 히스토리(Session History) 개념을 이해하는 것이 좋다.

세션 히스토리 개념을 위해 간단하게 브라우저 로딩부터 설명하겠다.


https://falsy.me/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%9D%B4%ED%95%B4-2-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EA%B7%B8%EB%A6%AC%EA%B3%A0-history-api/
https://mygumi.tistory.com/299
https://developer.mozilla.org/ko/docs/Web/API/History_API

```js
window.onpopstate = function(event) {
  alert(`location: ${document.location}, state: ${JSON.stringify(event.state)}`)
}

history.pushState({page: 1}, "title 1", "?page=1")
history.pushState({page: 2}, "title 2", "?page=2")
history.replaceState({page: 3}, "title 3", "?page=3")
history.back() // alerts "location: http://example.com/example.html?page=1, state: {"page":1}"
history.back() // alerts "location: http://example.com/example.html, state: null"
history.go(2)  // alerts "location: http://example.com/example.html?page=3, state: {"page":3}"
```

## 웹팩 플러그인
https://lazymankook.tistory.com/82

http://jeonghwan-kim.github.io/js/2017/05/15/webpack.html

## 웹 프론트엔드 프래임웍
앵귤러 리엑트 뷰

https://www.samsungsds.com/global/ko/support/insights/frameworks.html

## 웹컴포넌트?
https://d2.naver.com/helloworld/188655

## 반응형 웹
https://www.samsungsds.com/global/ko/support/insights/Responsive_web_1.html


## 자바스크립트 개발자라면 알아야 할 33가지 개념

https://www.google.com/search?q=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4+%EC%95%8C%EC%95%84%EC%95%BC+%ED%95%A0+33%EA%B0%80%EC%A7%80+%EA%B0%9C%EB%85%90&oq=%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4+%EC%95%8C%EC%95%84%EC%95%BC+%ED%95%A0+33%EA%B0%80%EC%A7%80+%EA%B0%9C%EB%85%90&aqs=chrome..69i57j69i60l2j69i61.118j0j4&sourceid=chrome&ie=UTF-8

## 리소스 우선순위 정하기
https://beomy.github.io/tech/browser/preload-preconnect-prefetch/

## 인증서 동작
https://medium.com/@icehongssii/%EA%B9%9C%EC%B0%8D%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EB%93%A4%EC%9D%84-%EC%9C%84%ED%95%9C-%EA%B0%84%EB%8B%A8%ED%95%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%83%81%EC%8B%9D-4-https-%EC%99%80-ssl-%EA%B2%89%ED%95%A5%EA%B8%B0-78ff41071720

https://blog.naver.com/PostView.nhn?blogId=alice_k106&logNo=221468341565&parentCategoryNo=&categoryNo=16&viewDate=&isShowPopularPosts=true&from=search

## 스누핑
https://limkydev.tistory.com/191

## 리디렉션 301 & 302
http://www.japong.com/tutorials/seo/301_redirect.html
301과 302는 사용자가 브라우저를 통해 웹서버에 요청했을때 돌려받는 웹서버의 상태코드인데, 301은 요청한 정보가 새로운 주소로 영구적으로 옮겨갔다는 신호이고, 302는 일시적으로 옮겨갔다는 신호이다. 표면상으로는 둘 다 자동으로 페이지를 이동하게 하므로 육안으로는 구별할수 없으나 검색엔진의 크롤러는 그 차이를 알수 있고, 이 두가지가 검색엔진 최적화에 미치는 영향은 꽤 크다.

## TIL / eject
https://helloinyong.tistory.com/174
https://medium.com/@jsh901220/create-react-app%EC%97%90%EC%84%9C-eject%EC%82%AC%EC%9A%A9%EC%95%88%ED%95%98%EA%B8%B0-customize-cra-react-app-rewired-10a83522ace0

## oAuth 로그인(인증+권한)
- https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/
- http://blog.weirdx.io/post/39955

OAuth는 Open Authorization, Open Authentication 뜻하는 것으로 애플리케이션(페이스북,구글,트위터)(Service Provider)의 유저의 비밀번호를 Third party앱에 제공 없이 인증,인가를 할 수 있는 오픈 스탠다드 프로토콜이다. OAuth 인증을 통해 애플리케이션 API를 유저대신에 접근할 수 있는 권한을 얻을 수 있다. OAuth가 사용되기 전에는 외부 사이트와 인증기반의 데이터를 연동할 때 인증방식의 표준이 없었기 때문에 기존의 기본인증인 아이디와 비밀번호를 사용하였는데, 이는 보안상 취약한 구조였다. 유저의 비밀번호가 노출될 가망성이 크기 때문이다. 그렇기 때문에 이 문제를 보안하기 위해 OAuth의 인증은 API를 제공하는 서버에서 진행하고, 유저가 인증되었다는 Access Token을 발급하였다. 그 발급된 Access token으로 Third party(Consumer)애플리케이션에서는 Service Provider의 API를 안전하고 쉽게 사용할 수 있게 되었다.

OpenID로 개발된 표준 인증 방식, API인증과 사용자인증에 사용된다. Oauth는 외부서비스의 인증 및 권한부여를 관리하는 범용적인 프로토콜입니다. OAuth는 인증뿐만 아니라 권한도 관리합니다. 사용자의 권한에 따라 접근할 수 있는 데이터가 다르도록 설정이 가능합니다.

[그외 인증 방법]

- 세션/쿠키, JWT를 이용한 인증
- Access Token + Refresh Token을 이용한 인증
- SNS 로그인은 간단하게 봤을 때 OAuth2.0 + 서버 인증(세션/쿠키, 토큰기반 인증)으로 구성

(사용자 <-> 어플리케이션 서버) 인증 절차였던 세션/쿠키, 토큰 기반 인증 방식을 완전히 대체하는게 아니라는 점입니다. 즉 SNS 로그인 기능을 넣더라도 결국은 세션/쿠키 방식이나 토큰을 활용해 인증을 거쳐야 합니다.

### Authorization Code Grant 방식을 예

- Resource Owner: User, 즉 일반 사용자를 칭합니다.
- Client: 우리가 관리하는 어플리케이션 서버(User와 혼동될 수 있는데 아닙니다!)
- Authorization Server: 권한을 관리하는 서버입니다. Access Token, Refresh Token을 발급, 재발급 해주는 역할을 합니다.
- Resource Server: OAuth2.0을 관리하는 서버(Google, Facebook, Naver 등) 의 자원을 관리하는 서버입니다. 주의할 점은 우리가 만드는 서버의 자원을 관리하는 곳이 아닙니다. Oauth 2.0 관리 서버의 자체 API를 의미합니다.

## 최슨 브라우저 동작 및 내부
https://d2.naver.com/helloworld/9274593

## 프로세스 소통 ipc

https://jhnyang.tistory.com/24


## URLSearchParams

URLSearchParams 생성자는 전체 URL을 분석하지 않습니다. 그러나, 맨 앞의 ?는 제거합니다.
https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams


## set
let difference = arr1.filter(x => !arr2.includes(x)); 

let difference = arr1.filter(x => arr2.includes(x)); 
https://p-iknow.netlify.com/data-structure/set

읽어봐 3개
https://www.zerocho.com/category/HTML&DOM/post/5b3ae84fb3dabd001b53b9ab

## 웹워커
https://developer.mozilla.org/ko/docs/Web/API/Web_Workers_API
https://medium.com/@pks2974/web-worker-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-4ec90055aa4d

Web Worker는 script 실행을 메인 쓰레드가 아니라 백그라운드 쓰레드에서 실행할 수 있도록 해주는 기술 입니다. 이 기술을 통해 무거운 작업을 분리된 쓰레드에서 처리할 수 있으며, 이를 통해 메인 쓰레드(일반적으로 UI 쓰레드)는 멈춤, 속도저하 없이 동작할 수 있게 됩니다.

네이티브에서 웹으로 접근
웹에서 네이티브(하이드브리드인 경우 많이 사용됨

Web Worker의 개념과 활용
Worker는 Worker() 생성자를 통해 생성되며 지정된 Javascript 파일에 포함된 코드를 Worker 쓰레드에서 실행합니다. (Worker는 현재 Window와 분리된 DuplicatedWorkerGlobalScope라는 별도의 Global context에서 동작합니다.) Worker 쓰레드에서 어떠한 코드도 실행할 수 있지만, 몇가지 예외가 있습니다. 예를들어 Worker 내에서는 DOM을 직접 다룰 수 없습니다. 또한 Window의 기본 메서드와 속성을 사용할 수 없습니다. 보다 자세한 정보는 Functions and classes available to workers를 참조해주세요.)

다음과 같은 롱 타임 스크립트 작업에 웹워커는 안성맞춤일 것이다.

- 매우 복잡한 수학적 계산 작업

- 원격지에 있는 리소스에 대한 액세스 작업(또는 로컬 스토리지를 액세스 하는 경우)

- 백그라운드에서 조용히 오랜시간 작업애햐 하는 경우

- UI 쓰레드에 방해 없이 지속적으로 수행해야 하는 작업 등

예제 
https://iamawebdeveloper.tistory.com/105

## 웹서버 통신
https://owlgwang.tistory.com/1

## Cache-Control Header
https://kdevkr.github.io/archives/2018/understanding-cache-control/

## 반응형 이미지
https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images

## ppi & dpi
https://blank2.tistory.com/3



## 에셋의 배율
http://suiux.com/gui_specification/

도트 퍼 인치(Dots per inch, DPI)는 인쇄와 디스플레이 해상도의 측정 단위이며, 특히 1 제곱인치 (2.54 제곱센티미터) 공간 안에 만들어진 점이나 화소의 수를 말한다.
<p>Low density (120dpi) (0.75x): ldpi<br>
Medium density (160dpi) (baseline) : mdpi<br>
High density (240dpi) (1.5x) : hdpi<br>
Extra High density (320dpi) (2x) : xhdpi<br>
Extra Extra High density (480dpi) (3x) : xxhdpi<br>
Extra Extra Extra High density (480dpi) (4x) : xxhdpi</p>

## 크롤링
https://www.fun-coding.org/crawl_basic2.html

## mainfest json
https://developer.mozilla.org/ko/docs/Web/Progressive_web_apps/Installable_PWAs

https://ko.wikipedia.org/wiki/%EB%A7%A4%EB%8B%88%ED%8E%98%EC%8A%A4%ED%8A%B8_%ED%8C%8C%EC%9D%BC
매니페스트 파일(manifest file)은 컴퓨팅에서 집합의 일부 또는 논리정연한 단위인 파일들의 그룹을 위한 메타데이터를 포함하는 파일이다. 예를 들어, 컴퓨터 프로그램의 파일들은 이름, 버전 번호, 라이선스, 프로그램의 구성 파일들을 가질 수 있다.


## http 분석 요청 응답 헤더
https://developer.mozilla.org/ko/docs/Web/HTTP/Overview
https://goddaehee.tistory.com/169?category=281064

## 캐시
https://goddaehee.tistory.com/171
https://hahahoho5915.tistory.com/33

## 에러코드
https://joshua1988.github.io/web-development/http-part1/

## 웹서버통신

https://yoonjaepark.github.io/2019-01-01/how-to-request-browser

https://velog.io/@onikss793/%EC%84%9C%EB%B2%84-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80

## 웹서버 캐시
http res 304?
https://developer.mozilla.org/ko/docs/Web/HTTP/Conditional_requests

리소스가 변경되지 않았다면, 서버는 304 Not Modified 응답을 회신하게 되는데, 이는 캐시를 다시 신선한 것으로 만들어주며 클라이언트는 그 캐시된 리소스를 사용하게 됩니다. 비록 어떤 리소스를 소비하는 응답/요청 라운드 트립이 있다고 하더라도, 연결을 통해 다시 전체 리소스를 전송하는 것보다는 더 효율적입니다.


https://pjh3749.tistory.com/264
https://www.zerocho.com/category/HTTP/post/5b594dd3c06fa2001b89feb9
https://goddaehee.tistory.com/171
https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=ko


## http tcp
https://medium.com/@chrisjune_13837/web-http-tcp-ip-%EB%A9%94%EC%8B%9C%EC%A7%80%EB%9E%80-4b2721fe296f
클라이언트로부터 특정 주소로 요청이 들어오면 DNS 상에서 IP주소를 받아옵니다 → HTTP 계층에서 HTTP 메시지를 작성합니다 → TCP 계층에서 HTTP 메시지를 패킷으로 분해합니다. → IP계층에서 전송위치를 확인하고 → 네트워크를 통하여 전송합니다. 그 이후는 위의 과정의 역순으로 진행하여 처리합니다.

https://asfirstalways.tistory.com/85

## will-change
애니메이션 성능 향상시키기
https://riptutorial.com/ko/css/example/1930/-will-change--%EC%86%8D%EC%84%B1%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%95%A0%EB%8B%88%EB%A9%94%EC%9D%B4%EC%85%98-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EA%B8%B0

## transition
?? GPU가속을 사용합니다.



## vsync
화면의 디스플레이 주기 tick
프레임 버퍼에 있는 내용을 어떤 주기로 가져올거냐 fetch

## 크롤링
??


## 다른 준비
- amp
https://d2.naver.com/news/8185757
https://byline.network/2016/05/1-169/


https://kakaomobility.recruiter.co.kr/app/jobnotice/view?systemKindCode=MRS2&jobnoticeSn=23180
https://kakaomobility.recruiter.co.kr/app/jobnotice/view?systemKindCode=MRS2&jobnoticeSn=16131

- 메신저 pim 기능


## rel
https://m.blog.naver.com/PostView.nhn?blogId=zoomen1004&logNo=220693042851&proxyReferer=https%3A%2F%2Fwww.google.com%2F
https://linuxism.ustd.ip.or.kr/633

## 웹지엘

## JavaScript HTML5 Canvas Animated Background
keyword: javascript canvas-bg
https://onaircode.com/javascript-html5-canvas-animated-background/
https://codepen.io/jkiss/pen/OVEeqK
https://codepen.io/VincentGarreau/pen/pnlso

## 웹 워커
웹 워커
 무거운 연산 작업 시 웹워커를 도입하여 스레드를 나눠서 렌더링을 동시에 진행할 수 있습니다.
자바스크립트는 싱글스레드이지만, 브라우저에서 멀티 쓰레드를 사용할 수 있도록 웹워커 (html5)를 지원합니다.
각 브라우저 엔진에 따라 쓰레드의 개수가 다르지만, 크롬은 5개, 파이어폭스는 4개로 알려져 있습니다.
브라우저 버전별로 웹워커를 사용 유무는 다르기 때문에 웹워커를 통해 분산하여 연산 및 비동기처리를 하기 위해서는 브라우저별 처리가 필요합니다.
internet explorer는 10 이상 지원합니다. webpack을 쓰는 프로젝트의 경우는 worker-loader(https://www.npmjs.com/package/worker-loader)플러그인을 사용할 수 있습니다.


## offsetWidth
??
https://ohgyun.com/571
https://github.com/jinyowo/JS-Calendar/wiki/**offsetHeight,-innerWidth-%EC%99%80-%EB%B9%84%EC%8A%B7%ED%95%9C-%EC%86%8D%EC%84%B1%EB%93%A4-%EC%A0%95%EB%A6%AC

일반적으로 엘리먼트의 전체 크기를 알고 싶다면, `offsetWidth`와 `offsetHeight` 속성을 가져오면 된다.
이 속성은 엘리먼트의 패딩과 보더, 스크롤바의 사이즈를 포함한 값을 리턴한다.


clientWidth, clientHeight

만약, 실제로 보여지고 있는 컨텐츠가 얼마만큼의 공간을 차지하고 있는지 확인하고 싶다면,
`clientWidth`와 `clientHeight` 속성을 사용하는 것이 좋다.

이 속성은 보더와 스크롤바의 크기를 제외한 실제 컨텐츠의 크기를 리턴한다. (패딩은 포함하고 있다)

scrollWidth, scrollHeight

만약, 보이는 것과 상관 없이 실제 컨텐츠 영역이 얼마만큼의 크기를 갖고 있는지 확인하고 싶다면,
`scrollWidth`와 `scrollHeight` 속성을 확인하면 된다.

이 속성은 전체 스크롤바를 사용하게 되어 숨겨진 영역까지 포함한 크기를 리턴한다.

## 최적화 방안
https://medium.com/myrealtrip-product/fe-website-perf-part2-e0c7462ef822

웹사이트 성능 측정 및 최적화 Part 2. 렌더링


사람의 눈은 1초당 60개 이상의 프레임(60 fps, 프레임당 16.7ms)으로 이뤄진 애니메이션을 볼 때 움직임이 자연스럽다고 느낍니다. 반대로 60 fps를 초과할수록 움직임이 버벅인다는걸 느끼게 됩니다.

화면에 프레임을 추가하는 순서
자바스크립트로 스타일을 변경하는 구문이 있는지 확인한 뒤 해당되는 DOM 요소에 CSS class 또는 inline 스타일로 반영합니다.
Style: 현재 버전의 CSS를 어떤 DOM 요소에 적용해야 할지 계산합니다.
Layout: 각 요소의 너비나 위치를 갱신에 화면 상에 배치합니다.
Paint: 각 요소에 배경색, 글자 색과 같이 픽셀을 채우는 과정입니다.
Composite: 이전 과정에서 생성된 레이어를 병합합니다.
위 과정의 처리 시간이 16.7ms 을 초과하는 횟수가 늘어날수록 전체 렌더링 시간이 지연됩니다. 결국 앞서 나온 애니메이션 예제와 같이 여행자가 인지할만큼 반응이 느려지는 결과를 가져옵니다.

애플리케이션에 많은 부담을 주는 경우 레이아웃 트리거를 완전히 피하려고 노력해야 합니다!

크고 복잡한 레이아웃 및 레이아웃 스래싱 피하기 / 강제 동기식 레이아웃 레이아웃 스레싱
https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?hl=ko

https://thisblogfor.me/web/raf_perform/


이때 rAF를 사용하여 DOM을 읽는 로직은 현재 프레임에서 실행하고, DOM을 수정하기 위한 로직은 rAf와 함께 사용해 다음 프레임에서 함께 실행하도록 예약하여 레이아웃 스레싱이 줄일 수 있다.(데모)

이 패턴은 아주 훌륭하기 때문에, 다음과 같이 헬퍼 메서드를 만들어 사용하는 것을 제안한다.




---


## position
absolute

## 지원
엔지 / 카카오

## 터치 스타트 무브? 차이

## css

“브라우저에서 하나의 애니메이션 프레임을 처리한다는 것은 애니메이션 구현에 필요한 모든 계산 과정과 계산을 통해 얻어진 픽셀 자리를 업데이트 하는 것까지 포함합니다. 목표는 브라우저가 이 과정에서 할일을 최대로 줄여서 초당 60프레임 정도의 부드러운 애니메이션을 만드는 것입니다. CSS 애니메이션 구현 비용과 직접적으로 연관되어 있는 것은 재조정(reflow)와 재색칠(repaint)를 일으키지 않는 속성들입니다.”
즉, 부드러운 애니메이션을 적용하려면 reflow와 repaint를 최소화 시켜야 합니다.

transform translate willchange 

### transform
http://tcpschool.com/css/css3_transform_2Dtransform

CSS3에서는 transform 속성을 사용하여 HTML 요소의 모양, 크기, 위치 등을 자유롭게 바꿀 수 있습니다. transform 속성은 HTML 요소에 대해 다음과 같은 동작을 제공합니다.

- 해당 요소를 움직입니다.
- 해당 요소를 회전시킵니다.
- 해당 요소의 크기를 변경합니다.
- 해당 요소를 기울입니다.
- 해당 요소에 위의 네 가지 동작 중 원하는 동작들을 한 번에 적용시킵니다.

CSS3에서는 transform 속성을 사용하여 2D 변형(transform)과 3D 변형(transform)을 모두 제공합니다.

1. translate()
2. rotate()
3. scale()
4. skew()
5. matrix()


rotate // 회전하기
scale // 크기변경
translate // 이동
skew // 기울이기
(matrix // a,b,c,d,x,y를 기준)

###  will-change
https://wit.nts-corp.com/2017/06/05/4571

will-change는 변화가 예상되는 요소를 브라우저에게 미리 알려줍니다. 브라우저는 실제 요소가 변화되기 전에 적절하게 최적화를 할 수 있습니다. 큰 비용이 드는 변화도 최적화로 인해 페이지의 반응성을 증가시킬 수 있습니다. will-change 속성을 사용하면 해당 레이어는 GPU에 업로드 됩니다.



will-change 속성은 4가지가 있습니다.
```
will-change: auto;
will-change: scroll-position;
will-change: contents;
will-change: transform;
will-change: top, left;
```

주의사항. 브라우저는 모든 요소에 대해 이미 최적화를 시키려고 시도하고 있습니다. will-change 속성이 사용된 요소는 최적화를 하기 위해 많은 자원을 소모하기 때문입니다. 과도한 메모리 사용과 더 복잡한 렌더링으로 성능이 더 안좋아 질 수 있습니다.

#### 사용법
브라우저에게 미리 will-change 사용을 알려주어야 합니다.
변화가 일어날 요소에 will-change를 직접 선언하면 적용이 되지 않습니다.

/* 변화할 요소와 will-change가 같이 있으므로 적용이 안 됨 */
.box {
    transform: rotate(180deg);
    transition: transform 1s linear;
    will-change: transform;
}
그러므로 선택자 :hover, 자바스크립트 mouseenter 등을 통하여 미리 알려주어야 합니다.

/* hover를 통해서 will-change를 선언 했으므로 적용 */
.box:hover {
    will-change: transform;
}
.box {
    transition: transform 1s linear;
}
.box:active {
    transform: rotate(180deg);
}

## 차트 라이브러리

## 지원하기

## 프론트앤드 프래임
rAF v-sync
https://thisblogfor.me/web/raf_perform/

https://medium.com/myrealtrip-product/fe-website-perf-part2-e0c7462ef822
https://cyberx.tistory.com/38

1초당 60개 이상의 프레임

## 모달

## 캔버스 공부

## 개발
- 타입스크립트 & 스토리북: https://velog.io/@velopert/design-system-using-typescript-and-storybook
- 캔버스 스네이크: https://www.youtube.com/watch?v=9TcU2C1AACw&t=252s


## 서비스 워커
https://developer.mozilla.org/ko/docs/Web/Progressive_web_apps/%EC%86%8C%EA%B0%9C
https://developers.google.com/web/fundamentals/primers/service-workers/

## 웹앱 매니페스트
https://web.dev/add-manifest/



리엑트 프로젝트

http call lib
Axios? fetch? fetch data?
await?

리덕스 활용 프로젝트 목록
https://velopert.com/3365

멀티 카운트
https://velopert.com/3346

리덕스 플래인 프로젝트 (생활코딩)
https://www.youtube.com/watch?v=bn-8isrtx0k&list=PLuHgQVnccGMB-iGMgONoRPArZfjRuRNVc&index=6


리엑트 배열 다루기
(튜토리얼 전체 목록) https://velopert.com/3613
https://velopert.com/3638#comment-1968

제스트 테스트 케이스
https://velopert.com/3587

react-hooks 훅 프로젝트활용 promise 개선
https://velog.io/@velopert/react-hooks




## Preload, Prefetch And Priorities in Chrome

What is the caching behavior for <link rel=”preload”> and <link rel=”prefetch”>?
크롬에는 네 가지의 캐시가 있다. the HTTP cache, memory cache, Service Worker cache & Push cache 이다. Preload, precache된 자원은 모두 http cache에 저장된다.
, preload는 선언적 fetch이다. Document의 onload event를 막지 않으면서 브라우저가 자원을 요청하도록 강제할 수 있다.
Prefetch는 자원이 필요할수도 있다는 것은 브라우저에게 힌트를 주지만, 로딩할지 말지는 브라우저가 결정하게 한다.


prefetch는 구글에서 광범위하게 사용되고 있고, 검색결과 페이지에서 목적 페이지를 렌더링하는데 걸리는 시간을 줄일 목적으로, 중요한 자원을 prefetch하기 위해 여전히 사용하고 있다.
Preload는 여러 케이스에서 실배포된 큰 사이트에서 사용하고 있고, 이 글에서 이에 대한 내용을 볼 수 있다. 그 전에, 우선 network stack이 preload와 prefetch를 어떻게 다르게 다루는지 알아보자.

현재 페이지서 사용될거라 확신이 드는 자원들은 preload하여라. 미래의 여러 navigation boundaries에서 사용될거라 생각되는 자원들은 prefetch하라.

https://medium.com/@koh.yesl/preload-prefetch-and-priorities-in-chrome-15d77326f646

## 클라이언트사이드 렌더링
https://blog.woolta.com/categories/9/posts/141
https://velopert.com/3425
https://jaroinside.tistory.com/24

## 웹개발의 이해
https://eunajjing.github.io/2019/07/16/boostcouse-webdev/

## Web Dev 웹 브라우저에 URL을 입력하면 어떤 일이 일어날까?
https://owlgwang.tistory.com/1


## http와 ajax
예를 들어보겠습니다. 제가 과거에 썼던 포스트가 있는데, 이 주소는 링크와 같습니다. 이 링크를 누르면, 사용자가 사용하는 웹 브라우저(크롬, 웨일, 사파리, 파이어폭스, 인터넷 익스플로러 등등)가 HTTP 규약에 따라 미디엄 서버에 해당 URL에 해당하는 웹페이지를 요청합니다. 그러면, 서버가 해당 요청에 응답하며, 그 결과인 html 문서가 브라우저 창에 뿌려지는 식입니다.


AJAX를 쓰면, 유저는 새로운 HTML을 서버로부터 받는 것이 아닙니다. 즉, 유저는 (유저가 정말 새로운 웹페이지로 이동하기를 원하는 것이 아닌 한)새로운 웹페이지로 이동하는 것이 아닙니다. 대신, 동일한 웹페이지 내에서 DOM을 변경하게 됩니다.

사용자의 이벤트로부터 Javascript는 해당 이름과 내용이 쓰여진 DOM을 읽습니다. 그리고는 XMLHttpRequest 객체를 통해 웹서버에 해당 이름과 내용을 전송합니다. 웹서버는 요청을 처리하고 XML, Text 혹은 JSON을 XMLHttpRequest 객체에 전송합니다. 그러면, Javascript가 해당 응답 정보를 DOM에 씁니다. 그렇게 결과페이지가 만들어집니다.
AJAX를 쓰면 새로운 HTML을 서버로부터 받아야 하는 것이 아닙니다. 동일한 페이지의 일부를 수정할 수도 있는 가능성이 생깁니다. 결과적으로 사용자 입장에서는 페이지 이동이 발생되지 않고 페이지 내부 변화만 일어나게 됩니다. HTML 페이지 전체를 다 바꿔야 하는 것이 아니라 부분만 바꿀 수 있게 되는 것입니다.
.


나이브 HTTP는 클라이언트쪽에서 Request를 보내고 Server쪽에서 Response를 받으면 이어졌던 연결이 끊기게 되어있습니다. 그래서 화면의 내용을 갱신하기 위해서는 다시 request를 하고 response를 하면서 페이지 전체를 갱신하게 됩니다.
AJAX는 html 페이지 전체가 아닌 일부분만 갱신할수 있도록 XMLHttpRequest객체를 통해 서버에 request 합니다. XMLHttpRequest는 서버와의 연결을 잡아둡니다. Json이나 xml형태로 필요한 데이터만 주고 받으며 DOM을 갱신하기 때문에 그만큼의 자원과 시간을 아낄 수 있습니다.

나이브한 HTTP는 웹브라우저가 서버에 요청합니다.
AJAX는 XMLHttpRequest 객체가 서버에 요청합니다.



나이브한 HTTP는 항상 페이지를 이동합니다.
AJAX는 조그마한 변경이 필요할 때, 해당 페이지 내에서 변경이 가능합니다.



그러나 여전히 AJAX로 여전히 수행하지 못하는 것들이 있습니다.
.
.
왜냐하면, AJAX도 여전히 HTTP로 서버와 통신하기 때문입니다. 즉, AJAX도 HTTP의 한계를 완전히 벗어나지 못했습니다. HTTP는 “클라이언트의 요청이 있고 그 다음 서버로부터 응답을 받는 상황”인데, 이 틀로부터 벗어나지 못했습니다.
“클라이언트의 요청이 있고 그 다음 서버로부터 응답을 받는 상황”에서 벗어나는 예를 들어보겠습니다. “클라이언트의 요청이 없음에도, 서버로부터 응답을 받는 상황”을 들어보고자 합니다.




클라이언트의 요청이 없음에도, 서버로부터 응답을 받는 상황”에 대한 미봉책[RFC6202]이었습니다. 즉, 데이터 수신을 위해 서버가 클라이언트에게 전송해 주는 푸시(push)방식이 아니라 여전히클라이언트가 서버에에게 요청하는 폴링(polling) 방식이었습니다.
이와 같은 애로사항은 HTML5 개발 과정에 녹아들었습니다. 결국, HTML5은 순수 웹 환경에서 실시간 양방향 통신이 가능해지게 만들어졌습니다. 그 스펙의 명칭이 바로 ‘웹 소켓(Web Socket)’ 입니다.

이제 동시대 즉 웹소켓의 시대로 넘어왔습니다. 2014년 10월 28일의 HTML5 버전이 나올 때 함께 등장했던 웹소켓은 2016년 11월 1일 HTML5.1 버전이 나오고 2017년 12월 14일 HTML5.2 버전이 나올 때까지 더더욱 발전했습니다.
웹소켓은 약속입니다. HTTP와 같이 약속입니다. 브라우저와 서버가 양방향 통신을 할 수 있도록 지원하는 프로토콜입니다.

웹소켓은 HTTP의 문제를 해결해주는 약속입니다. HTTP에서 원리적으로 해결할 수 없었던 문제는 “클라이언트의 요청이 없음에도, 그 다음 서버로부터 응답을 받는 상황”이었는데요. 웹소켓은 HTTP가 해결할 수 없었던 이 문제를 해결하는 새로운 약속이었습니다. 즉, 브라우저가 서버에 데이터를 요청하고 서버가 브라우저에 데이터를 보내기 위해 별다른 제약이 없습니다.
웹소켓에서는 서버와 브라우저 사이에 양방향 소통이 가능합니다. 브라우저는 서버가 직접 보내는 데이터를 받아들일 수 있고, 사용자가 다른 웹사이트로 이동하지 않아도 최신 데이터가 적용된 웹을 볼 수 있게 해줍니다. 웹페이지를 ‘새로고침’하거나 다른 주소로 이동할 때 덧붙인 부가 정보를 통해서만 새로운 데이터를 제공하는 웹서비스 환경의 빗장을 본질적으로 풀어준 셈입니다.
웹소켓 약속 하에서는 실시간 소통이 편안해지게 됩니다. 웹에서도 채팅이나 게임, 실시간 주식 차트와 같은 실시간이 요구되는 응용프로그램의 개발을 한층 효과적으로 구현할 수 있게 되었습니다. 가상화폐의 분산화 기술의 핵심도 web socket으로 구현할 수 있다는 점 언급해두고 싶습니다.




HTTP는 통신 제약이 있는 약속입니다.
AJAX로 HTTP의 통신 제약으로부터 조금 벗어날 수 있었습니다.
Websocket은 HTTP의 통신 제약을 해결한 새로운 약속입니다.

https://medium.com/@chullino/http%EC%97%90%EC%84%9C%EB%B6%80%ED%84%B0-websocket%EA%B9%8C%EC%A7%80-94df91988788


## 웹 최적화
https://znznzn.tistory.com/29

## 브라우저 동작
https://kim6394.tistory.com/217

### 그외
#### 요가..




### CSR & SSR
https://velog.io/@rjs1197/SSR%EA%B3%BC-CSR%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90


https://velog.io/@zansol/%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C%EB%A0%8C%EB%8D%94%EB%A7%81SSR-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%82%AC%EC%9D%B4%EB%93%9C%EB%A0%8C%EB%8D%94%EB%A7%81CSR

 

 

클라이언트 사이드렌더링.Simgle Page Application

 

SPA는 최초 한 번 페이지 전체를 로딩한 후 데이터만 변경하여 사용할 수 잇는 애플리케이션.

 

 

SPA 는 클라이언트사이드 렌더링 방식. 기본적으로 페이지 로드가 없고 모든 페이지는 단순히 HTML5 History에 의해 렌더링 된다.

그래서 언제 새로운 데이터를 불러와야 할지 스스로 정해서 구현해야 한다.

 

전통적인 웹방식 SSR 은 이 SPA 방식에 비해 성능 문제 이슈가 있었다.

전통적인 웹 대부분은 서버사이드 렌더링 방식인데. 브라우저에 나타나는 형태 그대로를 HTML로 만들어 제공하고

브라우저는 HTML을 표시하는 방식이었다.

 

웹에서 제공되는 정보가 정말 많기 때문에 전통적인 방식은 성능 문제에 이슈를 낳았다. 요청시마다 새로고침이 일어나며 페이지를 로딩할때마다 서버로부터 리소스를 전달받아 해석하고 화면에 렌더링 하는 방식이기 때문에.

 

이것은! 사용자와 인터랙션이 많은 요즘 웹앱에게 충분하지 않는 방법일 수 있다. 

렌더링을 서버쪽에서 하는 것은 그만큼 렌더링을 위한 서버자원이 사용되는 것이고 불필요한 트래픽도 낭비되는것.

 


### 덕타이핑
https://ko.wikipedia.org/wiki/%EB%8D%95_%ED%83%80%EC%9D%B4%ED%95%91


### 노드 & 런타임
https://asfirstalways.tistory.com/99


### webpack
https://gompro.postype.com/post/1699968

https://brightparagon.wordpress.com/2018/06/27/webpack-v4-development-configuration/

https://perfectacle.github.io/2016/11/14/Webpack-devtool-option-Performance/

https://zuminternet.github.io/ZUM-Webpack-dev-proxy-part1/



### useMemo
https://medium.com/@iamssen/react-16-7-useeffect-usememo-usecallback-%EC%9D%98-second-parameter-inputs-775298f2d291 

 

https://nikgrozev.com/2019/04/07/reacts-usecallback-and-usememo-hooks-by-example/ 

 

https://www.codebeast.dev/usestate-vs-useref-re-render-or-not/ 

 

https://www.codebeast.dev/react-memoize-hooks-useRef-useCallback-useMemo/ 


### 네이티브앱에서 웹앱으로: 모바일 웹앱의 현주소
프로그레시브 웹 앱 : 탭에서 벗어나기
https://d2.naver.com/helloworld/179084


REST API 액세스 토큰(access token)
https://devhaks.github.io/2019/05/31/oauth2/
https://tansfil.tistory.com/59
https://docs.iamport.kr/tech/access-token
아임포트 REST API서비스는 여러분의 가맹점의 결제 상세정보를 조회하거나 환불 요청 또는 에스크로 결제를 처리할 수 있는 기능을 제공합니다. 하지만 이는 가맹점의 사적 리소스(private resource)를 다루기 때문에 해당 리소스의 소유권을 인증한 후 접근할 수 있습니다.
이때 액세스 토큰(aceess token)을 발급받고 API 요청에 포함하여 가맹점의 소유권을 증명하고 사적 리소스(private resource)에 접근할 수 있습니다.
액세스 토큰(access token)이란?
아임포트 REST API서비스는 토큰 기반 인증을 사용합니다. 사적 리소스(private resource)에 접근하는 아임포트 REST API에 대한 모든 요청에 토큰이 포함되어 있는지, 또 해당 토큰이 유효한지의 여부를 검증함으로써 인증 절차를 수행합니다.
이때 사용하는 토큰을 액세스 토큰(access token)이라 부릅니다.


oAuth 로그인

https://tansfil.tistory.com/60

쉽게 알아보는 서버 인증 3편(SNS 로그인, OAuth 2.0)

OAuth 프로토콜의 기능 중 하나로 SNS 로그인이 있는겁니다!



지금부터 OAuth 의 정의를 시작으로 어떤 방식으로 SNS 로그인이 작동되는지 차근차근 알아보도록 하겠습니다. 



참고 포스팅



 http://tansfil.tistory.com/58 (세션/쿠키, JWT를 이용한 인증)

 http://tansfil.tistory.com/59 (Access Token + Refresh Token을 이용한 인증)



 
고차 함수(higher-order function)의 정의는 무엇인가요?
고차 함수는 다른 함수를 매개 변수로 사용하여 어떤 데이터를 처리하거나, 결과로 함수를 반환하는 함수입니다. 고차 함수는 반복적으로 수행되는 어떤 연산을 추상화하기 위한 것입니다. 전형적인 예시는 배열과 함수를 인수로 취하는 map입니다. map은 고차 함수를 사용하여 배열의 각 항목을 변환하고, 변환된 데이터로 새로운 배열을 반환합니다. JavaScript에서 흔히 볼 수 있는 다른 예로 forEach, filter, reduce가 있습니다. 다른 함수에서 함수를 반환하는 많은 사용사례가 있기 때문에 고차 함수는 배열을 조작할 필요가 없습니다. Array.prototype.bind는 JavaScript에서 그러한 예시 중 하나입니다.

Map


ttribute"와 "property"의 차이점은 무엇인가요?
attribute는 HTML 마크업에 정의되지만 property는 DOM에 정의됩니다. 차이점을 설명하기 위해 HTML에 다음 텍스트 필드가 있다고 가정해 봅시다: <input type="text" value="Hello">.

const input = document.querySelector('input')
console.log(input.getAttribute('value')) // Hello
console.log(input.value) // Hello
그러나 텍스트 필드에 "World!"를 추가하면 이렇게 될것입니다.

console.log(input.getAttribute('value')) // Hello
console.log(input.value) // Hello World!


////



S.I.T(Site Integration Test) : 현장 통합 시험

S.A.T(Site Acceptance Test) : 현장 인수 시험

F.A.T(Factory Acceptance Test) : 공장 인수 시험

UAT(User Acceptance Testing)

: 새로운 시스팀이나 변경된 시스템의 공식적 승락을 받는 시험.

최종 사용자들이 시스템을 사용해 보고 만족해야 UAT에 통과할 수 있다.



프록시를 사용하는이유
찰스 피들러
https://withpg.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%A4%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95



클라이언트 사이드 서버사이드

https://www.popit.kr/react-%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81/


네이티브앱 vs 모바일웹앱 vs 하이브리드앱

https://m.blog.naver.com/acornedu/221012420292

Charles
https://www.charlesproxy.com/documentation/ios/


react 상속 합성

https://ko.reactjs.org/docs/composition-vs-inheritance.html
https://blog.sonim1.com/186



면접
https://hackernoon.com/10-react-js-articles-every-web-developer-should-read-f5b745a348dc
https://www.freecodecamp.org/news/grabs-front-end-guide-for-large-teams-484d4033cc41/
https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Korean/questions/javascript-questions.md


https://basarat.gitbooks.io/typescript/docs/tips/barrel.html

barrel


```js
// demo/foo.ts
export class Foo {}

// demo/bar.ts
export class Bar {}

// demo/baz.ts
export class Baz {}
Without a barrel, a consumer would need three import statements:
import { Foo } from '../demo/foo';
import { Bar } from '../demo/bar';
import { Baz } from '../demo/baz';
You can instead add a barrel demo/index.ts containing the following:
// demo/index.ts
export * from './foo'; // re-export all of its exports
export * from './bar'; // re-export all of its exports
export * from './baz'; // re-export all of its exports
Now the consumer can import what it needs from the barrel:
import { Foo, Bar, Baz } from '../demo'; // demo/index.ts is implied


```

이것은 왜 typeof가 안전하지 않은가(typeof is no longer safe)를 알고있는 것이 중요합니다.



```js
<form onSubmit={this.handleSubmit}>
        <input
          type="email"
          placeholder="이메일"
          onChange={this.handleChangeEmail}
        />
      </form>
```


```js
<form onSubmit={this.handleSubmit}>
        <input
          type="email"
          placeholder="이메일"
          value={email}
          onChange={this.handleChangeEmail}
        />
      </form>
```
Uncontrolled component & Controlled Component
Uncontrolled 컴포넌트는 방금도 말씀드렸지만 상태를 직접 React 에서 제어하지 않는다는 의미에서 Uncontrolled 컴포넌트로 불립니다. React 생태계에서는 사실 잘 쓰이지 않아요. 이렇게 상태를 프로그래머가 제어해야할 일이 종종 생기기 때문입니다. 하지만 아까도 말씀드렸듯이 렌더를 아예 타지않는다는 장점이 있기 때문에 상태를 제어할 일이 없다면 쓰는 것도 좋다고 생각해요.


이제 초기화 버튼까지 아주 잘 동작하네요! 지금 보신 이게 바로 Controlled 컴포넌트 입니다. 아까 보았던 State 가 없는 방식이 Uncontrolled 컴포넌트이고요.



컴포넌트 내부에서 상태를 가지면 스스로 프롭으로 변경해서 데이터를 업데이트하고
부모컴포넌트에서 초기화를 어덯게 시키나? 새로 그린다. 리랜더를 한다. 자식 컴포넌트 key속성을 사용한다. 초기화에만 쓰는상태를 추가한다.



```js
import React from 'react'

import Input from './Input'

class JoinForm extends React.Component {
  email = ''
  password = ''
  state = {
    reset: 0
  }
  
  render() {
    const { reset } = this.state

    return (
      <form onSubmit={this.handleSubmit}>
        <Input
          // key={reset + 'email'}
          type="email"
          placeholder="이메일"
          onChange={this.handleChangeEmail}
        />
        <Input
          // key={reset + 'password'}
          type="password"
          placeholder="비밀번호"
          onChange={this.handleChangePassword}
        />
        <button type="submit">가입하기</button>
        <button type="button" onClick={this.handleReset}>초기화</button>
      </form>
    );
  }

  handleChangeEmail = (value) => {
    this.email = value
  }
  
  handleChangePassword = (value) => {
    this.password = value
  }

  handleSubmit = () => {
    console.log(this.email, this.password)
  }

  handleReset = () => {
    this.email = ''
    this.password = ''
    this.setState({
      reset: this.state.reset + 1
    })
  }
}

export default JoinForm
```


위 링크에서 이 기법에 대한 더 자세한 정보를 확인하실 수 있어요. 이렇게 컴포넌트를 제거하고 새로 만드는 작업은 당연하게도 State를 단순히 초기화하는 것보다 성능이 나쁠 거라고 예상하게 되지만, 실제로는 성능차이가 별로 중요하지 않은 수준이고 특정 상황에서는 State를 초기화는 것보다도 빠를 수 있다고 해요. 저는 사실 Uncontrolled Component를 선호하는 편입니다. State가 외부에 공개되지 않아서(캡슐화) 가지는 장점이 크다고 생각해요.

하지만 이 방법도 근본적으로 완벽하지는 않습니다. 우선 초기화에만 쓰는 상태가 하나 추가 되었다는 단점이 있고요. 또, JoinForm 입장에서 봤을 때 Input 컴포넌트를 원하는 값으로 만들어줄 방법이 없죠. 이제 두 번째 방법을 알아봅시다.


이 예제를 보시면 마찬가지로 PureComponent를 사용함에도 불구하고, 관련없는 두개의 Input이 서로 렌더링되고 있는걸 확인하실 수 있습니다. 왜일까요?

바로 이전의 예제와 이 예제의 차이점은 이 예제에서는 인라인 함수를 썼다는 것입니다. 인라인 함수를 render 메소드 내에서 쓰면 매 render 실행시마다 함수 인스턴스가 새로 생성되겠죠? 따라서 이 코드를 실행되면 결과는 false로 출력됩니다.

1
(() => null) === (() => null); // false
이 말은 매 render 실행마다 Input에 Props로 내려오는 함수가 모두 다르다는 것이고, 함수의 실행과는 관계 없이 Shallow compare로 함수 자체가 다른지를 비교하기 때문에 항상 다르다는 결과를 반환하겠죠. 결론적으로 항상 re-render 되는 것입니다.

이런 상황은 인라인 함수 사용이 대표적이지만 이것 말고도 여러가지가 있습니다. 자주 부딪치는 문제중에서는 렌더 메소드 내에서 객체를 새로 만드는 케이스가 있죠. 이렇게요.

1
2
3
4
5
class Parent extends React.Component {
  render() {
    return <Child foo={{ bar: "baz" }} />;
  }
}
또 한 가지 정말 쉽게 실수할 수 있는 케이스는 ReactNode를 넘길 때, children등을 사용할 때 인데요, 이 부분은 조금 이따가 Component Composition을 할 때 다뤄보겠습니다.


정리

Uncontrolled Component는 사용자가 상태를 제어하지 않는 컴포넌트다.
Uncontrolled Component는 key Props를 이용해 초기화 할 수 있다.
Controlled Component는 사용자가 상태를 제어할 수 있는 컴포넌트다.
PureComponent를 이용해 render 를 최적화 할 수 있다.
PureComponent는 Props와 State를 얕은 비교해서 이전과 같으면 render를 실행시키지 않는다
PureComponent를 잘못 사용하면 일반적인 Component보다도 성능이 나빠질 수 있다.

https://hyunseob.github.io/2019/06/02/react-component-the-right-way/










그렇지만.. Dialog의 render를 최적화할 방법은 없을까요? 이렇게 부모 컴포넌트의 상태가 업데이트 될 때마다 불필요한 render 호출은 합성된 컴포넌트에서 반드시 받아들여야 하는 일일까요?

물론 절대 그렇지 않습니다. 간단하게 Dialog를 래핑한 컴포넌트를 하나 더 만들기만 하면 문제는 해결됩니다.


Recap
Portal 컴포넌트는 논리적으로 하위 컴포넌트지만 시각적으로는 상위 컴포넌트여야 할 때 사용한다.
React에서는 합성, Composition을 통해 컴포넌트를 재사용할 수 있다.
Composition을 지원하는 컴포넌트의 경우 PureComponent를 사용하면 성능이 나쁠 수 있다.
Composition을 지원하는 컴포넌트를 최적화 하고 싶으면 특수화를 적용한다.






Specialization
WelcomeDialog라는 컴포넌트를 하나 더 만들었어요. PureComponent로요. Dialog는 Component로 고치고요. WelcomeDialog의 render 메소드내에서는 ReactNode를 그냥 생성하고 있죠. 왜냐하면 WelcomeDialog는 PureComponent이고, Props를 전혀 받지 않고 있기 때문에 render 가 다시 실행될 일이 없거든요. 따라서 Dialog도 다시 render 되지 않습니다.

이것을 React에서는 Specialization(특수화)이라고 부릅니다. 일반적인 목적의 컴포넌트를 좀 더 특수한 목적에 대응하는 컴포넌트로 만드는 것이죠.

https://reactjs.org/docs/composition-vs-inheritance.html#specialization


프로그래밍 패러다임
어떻게가 아닌 무엇을.


https://velog.io/@kyusung/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9A%94%EC%95%BD
=======
테스트?  tdd bdd ddd
https://asfirstalways.tistory.com/296

리덕스 사가 모달?

클라이언트 사이드렌더링 서버 사이드 렌더링 차이점과 리엑트의 우수한점????


코드 커버리지
https://afrobambacar.github.io/2018/10/code-coverage-with-jest.html

https://medium.com/@pakss328/%EC%BD%94%EB%93%9C%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-code-coverage-991e79da9e5f

https://medium.com/@rinae/%EB%B2%88%EC%97%AD-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%A6%AC%EB%8D%95%EC%8A%A4-%EC%95%B1%EC%9D%84-jest%EC%99%80-enzyme%EC%9C%BC%EB%A1%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%95%98%EB%A9%B0-%EC%96%BB%EC%9D%80-%EA%B5%90%ED%9B%88-8fc3e2c6615d

dummy stub mock

https://m.blog.naver.com/PostView.nhn?blogId=palfuni&logNo=120154483985&proxyReferer=https%3A%2F%2Fwww.google.com%2F

https://www.jpstory.net/2013/07/26/know-your-test-doubles/

1. 모든 프로그램이 개발하고 테스트할 때 완성되어 있는 것은 아니다. 그래서 필요한 것이 Stub이다.

Dummy
가장 기본적인 유형으로, 매개변수 값과 같이 작업을 수행하는 메소드가 없는, 값 전달만을 위한 객체를 말한다.

Stub은 로직이 없고 단지 원하는 값을 반환합니다. 테스트시에 “이 객체는 무조건 이 값을 반환한다”고 가정할 경우 사용할 수 있습니다. Stub은 보통 작성하기 쉽지만 불필요한 boilerplate 코드를 줄이기 위해서 Mocking Framework을 이용하는게 편합니다.

Mock은 “어떤 메소드가 호출 될 것이다”라는 행위에 대한 예상을 가지고 있습니다. 만약 그 예상대로 메소드가 호출 되지 않을 경우 테스트는 실패합니다. 이렇듯 Mock은 객체 사이의 행위(interaction)를 테스트하기 위해 사용합니다. 식별 할 수 있는 상태 변경이 없거나 반환 값으로 확인 할 수 없는 경우에 유용합니다. 예를 들면 어떤 코드가 디스크에서 read 작업을 하는데 하나 이상의 디스크에서 read 작업을 수행하지 않도록 하려는 경우, read 작업을 수행하는 메소드가 한번만 호출 되었는지 검증하기 위해 Mock을 사용할 수 있습니다.




테스트 코드를 정말 작성해야 하는가?
https://blog.outsider.ne.kr/1275

UI오ㅓ UX
https://m.blog.naver.com/moolsaess/221159385304

웹앱? 웹뷰?

웹팩
http://jeonghwan-kim.github.io/js/2017/05/15/webpack.html


확장성을 고려한 컴포넌트 
https://velog.io/@kyusung/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B5%90%EA%B3%BC%EC%84%9C-%ED%99%95%EC%9E%A5%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8

스토리북 입문 가이드
https://hyunseob.github.io/2018/01/08/storybook-beginners-guide/

컴포넌트 제대로 만들기
https://hyunseob.github.io/2019/06/02/react-component-the-right-way/

리엑트 모듈
https://gloriajun.github.io/frontend/2019/04/11/react-code-splitting.html#the-async-component-hoc


8-point 그리드란?
http://uidesignguides.com/8-point-%EA%B7%B8%EB%A6%AC%EB%93%9C%EB%A1%9C-%EB%94%94%EC%9E%90%EC%9D%B8%ED%95%98%EA%B8%B0/
https://brunch.co.kr/@blackindigo-red/8
https://spec.fm/specifics/8-pt-grid

React를 이용해 재사용성을 갖춘 디자인 시스템 구축하기
https://code.tutsplus.com/ko/tutorials/build-a-reusable-design-system-with-react--cms-29954

Babel과 Webpack을 이용한 ES6 환경 구축 
https://poiemaweb.com/es6-babel-webpack-1
https://poiemaweb.com/es6-babel-webpack-2


Webpack4 for React (리액트를 위한 웹팩4) - 1
https://velog.io/@padakim/Webpack4-for-React-%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%9B%B9%ED%8C%A94-1-

## 블로그
https://www.robinwieruch.de/conditional-rendering-react/
https://blog.logrocket.com/how-to-use-react-createref-ea014ad09dba/

http://cplusplus5.egloos.com/

## go 크로스 컴파일
https://mingrammer.com/cgo-cross-compile-for-mac-for-linux/

## 디자인 패턴


## 검색 알고리즘
트리, 라운드로빈

## 웹 개발 생태계

- https://clay1987.blog.me/221405825662



## nextjs
https://blueshw.github.io/2018/04/15/why-nextjs/

nextjs 로 프로젝트를 진행한지도 반년 가까이 흘렀습니다. nextjs는 서버사이드렌더링(SSR)과 code splitting 등을 지원하는 reactjs 전용 프레임워크입니다. 2 년도 채 안되는 시간에 벌써 5.x(곧 버전 6 도 나올것 같네요) 버전까지 등장했습니다. 그만큼 많은 사람들의 관심속에 발전하고 있다는 뜻이겠죠. 사용법은 충분히 익숙해졌지만, 시간에 쫓기고 일정에 쫓기다보니 nextjs 가 동작하는 방식에대한 이해는 부족하다 느껴집니다. nextjs 가 reactjs 코드를 어떻게 빌드하고, SSR 은 어떤 과정을 거치며 브라우저에서 어떻게 동작하는지 살펴보도록 하겠습니다.

SSR 은 어떤 과정을 거치나?
SSR 은 말그대로 서버에서 렌더링을 한다는 것입니다. 10 여년전에 많이 유행했던 PHP 나 JSP 가 대표적인 서버렌더링 프레임워크입니다. 유저가 어떤 url 로 데이터를 요청하면 서버는 미리 html 파일을 만들어 클라이언트(브라우저)에게 전달하는 방식입니다. next 에서 SSR 도 크게 다르지 않습니다. 서버(node)를 띄우고 유저가 요청하면 html 을 생성하여 브라우저에 전달합니다. 구조는 동일합니다. 다른점이 있다면, 모든 요청에 대해 서버에서 렌더링을 진행하지는 않고 초기 렌더링만 서버가 담당합니다. 그 이후에는 next/router를 이용하여 클라이언트에서 렌더링합니다. next 가 해주는 일은 이게 전부입니다. 간단하지만, 이 방식으로 SPA 의 단점으로 꼽히는 긴 초기 렌더링 시간을 대폭 줄일 수 있습니다.
---
layout: post
title: 브라우저의 JavaScript 코드 실행 과정
categories: JavaScript
---

브라우저의 JavaScript 코드 실행 과정에 대해 알아 봅시다. 이는 브라우저에 내장된 자바스크립트 엔진(인터프리터기)의 동작원리와도 같습니다. 자바스크립트의 작동방식을 이해하기 위해서는 다음과 같은 개념들에 대해 먼저 알아야 합니다.

- 브라우저의 엔진 구분: 렌더링 엔진 / 자바스크립트 엔진 (v8포함)
- 브라우저 APIs
- 자바스크립트 엔진: Call Stack / Memory Heap / Task Queue(=Event Queue) / Event Loop
- Non-Blocking

## 브라우저의 엔진
브라우저는 크게 렌더링 엔진, 자바스크립트 엔진으로 나뉩니다. 브라우저는 사용자가 참조하고자 하는 페이지를 서버에게 요청 후 그에 대한 응답을 화면에 보여주는 일을 합니다.

- 렌더링 엔진: 서버로부터 받은 HTML, CSS은 브라우저 렌더링 엔진의 HTML 파서, CSS 파서에 의해 DOM, CSSOM 트리가 만들어지고 렌더 트리로 결합된다. 렌더 트리를 기반으로 브라우저는 웹페이지를 표시합니다.
- 자바스크립트 엔진: 자바스크립트 엔진은 자바스크립트 코드를 실행하는 프로그램 혹은 인터프리터를 말합니다. 


## 자바스크립트 엔진
자바스크립트 엔진은 표준적인 인터프리터로 구현될 수도 있고 혹은 자바스크립트 코드를 바이트코드로 컴파일하는 저스트인타임(just-in-time) 컴파일로러 구현할 수도 있습니다. 다음과 같은 다양한 자바스크립트 엔진들이 존재 합니다.

- V8: 오픈소스, 구글에서 개발, C++로 작성됨
- Rhino: 모질라파운데이션에서 관리, 오픈소스, 전체가 자바로 개발됨
- SpiderMonkey : 최초의 자바스크립트 엔진. 예전에는 넷스케이프 네비게이터에 사용됐고 지금은 파이어폭스에 사용됨
- JavaScriptCore: 오픈소스, 니트로라는 이름으로도 알려져 있으며 애플이 사파리를 위해 개발함
- KJS: KDE의 엔진으로서 KDE프로젝트의 컨커러 웹 브라우저를 위해 해리 포텐이 개발함
- Chakra (JScript9): 인터넷익스플로러
- Chakra (JavaScript): 마이크로소프트엣지
- Nashorn: 오픈JDK의 일환으로 오픈소스이며 오라클 자바언어와 툴그롭으로 작성됨
- JerryScript: 사물인터넷을 위한 경량 엔진

자바스크립트 처리는 자바스크립트 엔진이 하며 JS로 작성한 코드를 해석하고 실행하는 인터프리터입니다. 렌더링 엔진의 HTML 파서가 DOM 생성 프로세스를 하던 중 스크립트 태그를 만나면, 자바스크립트 코드를 실행시키기 위해 자바스크립트 엔진에게 제어권한을 넘겨 주게 됩니다. DOM 트리가 다 형성되지 않았는데 자바스크립트에서 해당 DOM을 조작하려고 하면 문제가 발생하기 때문에 script 태그는 html의 body 태그 제일 아래에 놓는 것이 좋습니다.

### v8 엔진
자바스크립트 엔진의 대표적인 예는 Google V8 엔진입니다. V8 엔진은 구글이 만들었으며 오픈소스이고 C++로 제작됩니다. 구글크롬에서 사용 중입니다. 그리고 다른 엔진들과 차이점은 노드js의 런타임으로도 사용된다는 점입니다. V8은 웹 브라우저 내부에서 자바스크립트 수행 속도의 개선을 목표로 처음 고안되었습니다. 속도 향상을 위해 V8은 인터프리터를 사용하는 대신 자바스크립트 코드를 더 효율적인 머신 코드로 번역합니다. 저스트인타임 컴파일러를 구현함으로써 코드를 실행 시에 자바스크립트 코드를 머신 코드로 컴파일하는데, 이는 스파이더몽키나 리노와 같은 현대적인 다른 자바스크립트 엔진에서도 마찬가지입니다. 주된 차이는 V8은 바이트코드와 같은 중간 코드를 생산하지 않는다는 점입니다.

V8엔진은 JIT(Just In Time) 컴파일을 채택하였습니다. 인터프리터와 정적 컴파일러의 중간단계라고 볼 수 있습니다. 인터프리터처럼 실행하면서 코드를 읽어들여 그에 대응하는 기계어 코드를 생성하고, 해당 코드를 캐싱해둡니다. 

## 자바스크립트 엔진 영역
자바스크립트는 싱글 스레드 언어로 한번에 하나의 태스크만 처리할 수 있습니다. 구글에서 개발한 V8를 비롯해 대부분의 자바스크립트 엔진은 크게 세 영역으로 나뉩니다.

- Call Stack
- Heap
- Task Queue(Evnet Queue)


### 호출 스택(Call Stack)
호출 스택(call stack)은 스택 형태의 저장소로, JavaScript 엔진은 함수 호출과 관련된 정보를 이 곳에서 관리합니다. 자바스크립트는 단 하나의 호출 스택(call stack)을 사용합니다. 싱글 스레드 기반 언어, 즉 호출 스택이 하나라는 뜻으로 한 번에 한 작업만 처리할 수 있습니다. 이는 하나의 함수가 실행되면 이 함수의 실행이 끝날 때까지 다른 어떤 task도 수행될 수 없다는 의미입니다. 요청이 들어올 때마다 해당 요청을 순차적으로 호출 스택에 담아 처리합니다. 

참고) 스택(stack)은 제한적으로 접근할 수 있는 나열 구조이다. 그 접근 방법은 언제나 목록의 끝에서만 일어난다. 끝먼저내기 목록(Pushdown list)이라고도 한다. 스택은 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조(LIFO - Last In First Out)으로 되어 있다. 

#### 호출 스택 동작 순서 
여러개의 호출이 들어 오는 경우, 호출된 작업은 호출 스택에 하나씩 쌓이게 되고 가장 마지막에 들어온 스택을 먼저 실행하여 스택에서 제거 하는 방식으로 스택이 비워질때까지 반복합니다. 

호출 스택에 저장되는 각 항목을 실행 맥락(execution context)이라고 부릅니다. 실행 맥락에는 아래와 같은 정보들이 저장됩니다.

- 함수 내부에서 사용되는 변수
- 스코프 체인
- this가 가리키는 객체

참고) 실행 컨텍스트는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이지만 물리적으로는 객체의 형태를 갖는다. 전역EC와 함수별EC를 가질수 있다.


브라우저가 JavaScript 코드를 실행시킬 때, 호출 스택을 다음과 같이 조작합니다.
- 스크립트를 불러올 때, 전역 실행 맥락(global execution context)을 호출 스택에 추가합니다.
- 함수가 호출되면, 해당 호출에 대한 실행 맥락을 생성해서 호출 스택에 추가(push)합니다.
- 변수에 대입이 일어나면, 호출 스택에 저장되어 있는 변수의 내용을 변경합니다.
- 함수의 실행이 끝나면, 결과값을 반환하고 호출 스택 가장 위에 있는 실행 맥락을 제거(pop)합니다.
- 스크립트의 실행이 모두 끝나면, 전역 실행 맥락을 호출 스택에서 제거(pop)합니다.
- 이를 통해, 변수에 값을 대입한다거나, 함수가 여러 번 중첩되어 호출되는 등의 복잡한 코드의 동작을 단순한 자료구조로 표현할 수 있게 됩니다.

함수를 호출하면 호출 스택에 실행 맥락으로 저장이 되고, 웹 브라우저는 호출 스택에 실행 맥락이 존재하는 동안에 즉 실행 중인 함수가 존재하는 동안(함수 실행이 끝나기 전까지)에는 다른 동작을 하지 않습니다. 즉, 대략 16ms 안에 코드의 실행을 완료하지 못하면 브라우저의 애니메이션이 뚝뚝 끊기는 현상이 나타나고 이는 사용자 경험에 악영향을 미칠 수 있습니다.

참고) 브라우저는 대개 60fps(스크린은 1초에 화면을 60번 그린다)로 동작합니다. 만약 브라우저가 1초에 60프레임을 그려내지 못하게 되면, 웹페이지에서 스크롤을 내린다거나 드래그해서 뭔가를 움직인다거나 할 때 버벅버벅거리는 현상이 생기게 됩니다. (이러한 현상을 쟁크 `Jank`라고 합니다.) 혹은 애초에 페이지 자체가 뜨는 데까지 오랜시간이 걸릴 수도 있습니다. 이런 경우에는 최적화(Optimization)가 필요합니다. 

#### 스택 프레임(Stack Frame)
호출 스택의 각 단계를 스택 프레임(Stack Frame)이라고 합니다. 그리고 보통 예외가 발생했을 때 콘솔 로그 상에서 나타나는 스택 트레이스(Stack Trace)가 오류가 발생하기까지의 스택 트레이스들로 구성됩니다. 간단히 말해서 에러가 났을 때의 호출 스택의 단계를 의미하는 것 입니다. 호출스택은 메소드가 실행될 때, Call Stack에 새로운 프레임이 생기고 push되고 메소드의 실행이 끝나면 해당 프레임은 pop되는 원리입니다.

참고) 크롬 브라우저는 16000 프레임의 제한된 스택을 가지고 있어서 이 범위를 넘어서게 된다면 Max Stack Error Reached 라는 상태가 되고 실행 중이던 것을 죽입니다.

### Heap
동적으로 생성된 객체(인스턴스)는 힙(heap)에 할당됩니다. 대부분 구조화되지 않는 '더미'같은 메모리 영역을 heap이라 표현합니다. 메모리 힙은 동적으로 만들어진 객체(인스턴스)가 메모리에 할당되는 곳입니다. 자바스크립트 싱글 스레드에서 코드를 실행하는 건 상당히 제약이 많습니다. 한 개의 호출 스택을 갖고 있는 자바스크립트의 실행이 느려지면 다음 호출 스택을 실행하지 못하게 됩니다. 브라우저는 아무 작업도 하지 못하고 대기 상태가 되는 것입니다. 페이지를 그리지도 못하고 어느 코드도 실행하지 못하는 사태 입니다. 매끄럽고 자연스러운 화면 UI를 가진 앱에서는 이런 방식이 문제가 됩니다. 또한, 브라우저가 호출 스택의 정말 많은 작업들을 처리하다 보면 화면이 아마 오랫동안 응답하지 않게 됩니다. 이 경우에 대부분의 브라우저는 에러를 띄우면서 페이지를 종료할 것인지를 묻게 됩니다. 페이지 렌더링 동작을 방해하지 않고 브라우저의 응답도 끊지 않으면서 연산량이 많은 코드를 실행할 수 있을까요? 정답은 바로 비동기 콜백 입니다. 우리 코드의 일부를 실행하고 나중에 실행될 콜백함수를 제공합니다. `비동기 콜백은 즉시 호출 스택에 쌓이지 않고 Event Queue에서 기다렸다가 호출 스택이 비어있는 시점에 실행`됩니다.

### Task Queue(Event Queue)
자바스크립트의 런타임 환경(JavaScript Runtime Environment)에서는 처리해야 하는 Task들을 임시 저장하는 대기 큐가 존재합니다. 그 대기 큐를 Task Queue or Event Queue라고 합니다. 그리고 Call Stack이 비어졌을 때 먼저 대기열에 들어온 순서대로 수행됩니다. 자바스크립트에서 비동기로 호출되는 함수들은 Call Stack에 쌓이지 않고 Task Queue에 들어 갑니다. 

부드러운 화면을 위해 모든 작업을 16ms 안에 처리할 수는 없습니다. 어떤 사건(event)이 일어날 때까지 기다리거나, 혹은 큰 데이터에 대한 계산이 완료될 때까지 기다리는 데에는 시간이 오래 걸리기 마련입니다. 자바스크립트에서는 이벤트에 의해 실행되는 함수(핸들러)들이 비동기로 실행됩니다. 자바스크립트 엔진이 아닌 브라우저 APIs(Web API) 영역에 따로 정의되어 있는 함수들은 비동기로 실행됩니다. 이런 경우, 브라우저에서는 다음과 같은 절차를 통해 오래 기다려야 하는 일을 처리할 수 있습니다. 

- 기다려야 하는 일을 JavaScript 엔진에서 직접 처리하는 것이 아니라 API를 통해 브라우저에 위임합니다. 이 때, 일이 끝나면 실행시킬 콜백을 같이 등록합니다.
- 위임된 일이 끝나면, 그 결과와 콜백을 작업 큐(task queue)에 추가합니다.
- 브라우저는 호출 스택이 비워질 때마다 작업 큐에서 가장 오래된 작업을 꺼내와서 해당 작업에 대한 콜백을 실행시킵니다. 브라우저는 이 과정을 끊임없이 반복하는데, 이를 이벤트 루프(event loop)라고 부릅니다.

#### 브라우저 APIs
자바스크립트는 v8에서 제공하는 기본 API와 브라우저에서 제공하는 API(Web API)를 사용하여 작성됩니다. 자바스크립트는 한번에 하나의 일 밖에 할 수 없지만, 브라우저가 Web API들은 자바스크립트에서 호출 할 수 있는 쓰레드를 제공합니다. (DOM, ajax, setTimout..등) 웹 브라우저에는 함수를 특정 시간이 지난 뒤에 실행시키거나, 혹은 함수를 주기적으로 실행시키는 작업을 할 수 있게 해 주는 함수가 내장되어 있습니다.

#### 이벤트 루프(Event Loop)
브라우저가 제공하는 Web API들은 자바스크립트에서 호출 할 수 있는 쓰레드를 제공한다고 하였습니다. setTimout API를 호출 한다고 했을때, 요청되는 함수는 호출스택에 쌓여있다가 호출되면 바로 제거 되지만 setTimeout API 는 브라우저 API 영역에서 실제 처리 되고, 비동기 처리가 완료되면 호출되는 콜백함수를 TaskQueue에 넣어 둡니다. 이벤트 루프는 CallStck과 TaskQueue를 감시하다가 콜스택이 비어있는 시점에, TaskQueue에서 처리된 콜백을 꺼내와 CallStack영역으로 가져 오게 됩니다. 이벤트루프는 콜백함수를 콜백큐에서 가져다가 콜스택에 밀어넣습니다.

이벤트 루프는 시간의 흐름에 따라 코드의 수행을 처리하며 그 때마다 자바스크립트 엔진을 작동시킵니다. 비동기 호출의 경우, 브라우저는 네트워크로부터의 응답에 대기하고 있다가 반환할 거리가 생겼을 때 콜백 함수가 수행될 수 있도록 이벤트 루프에 삽입하는 것으로 스케쥴링을 수행합니다. 이벤트루프는 하나의 단순한 임무만 갖고 있습니다. 콜스택과 콜백큐를 감시하는 것입니다. 만약 콜스택이 비어있으면 이벤트루프는 큐에서 첫 번째 이벤트를 가져다가 콜스택에 밀어 넣을 것이며 결과적으로는 해당 이벤트가 실행됩니다.

이벤트 큐는 대기하다가 스택이 비는 시점에 이벤트 루프를 돌려 해당 콜백 함수를 스택에 넣습니다. 이벤트 루프의 기본 역할은 큐와 스택 두 부분을 지켜보고 있다가 스택이 비는 시점에 콜백을 실행시켜 주는 것입니다. 이러한 반복을 이벤트 루프에서는 틱(tick)이라고 부릅니다. 각각의 이벤트는 단순히 함수를 실행하는 것입니다.

다음은 이벤트 큐와 이벤트 루프의 동작을 잘 보여주는 setTimeout 예입니다.
```js
setTimeout(function() {
  console.log("first");
}, 0);
console.log("second");

// console >>
// second
// first
```
setTimeout에 0ms를 주었으니 바로 실행되는 것이 아닙니다. setTimeout은 호출 스택에서 실행된 후 Web API의 Timer API를 호출합니다. Web API에 의해 setTimeout의 콜백함수는 이벤트 큐에 enqueue 됩니다. 만약 addEventlitenser(
'click', clickHandler) 라면 클릭되는 순간 Web API가 이벤트 큐에 clickHandler를 추가시킵니다. console.log('second') 가 호출 스택에 쌓이고 second가 실행된 후 호출 스택이 비었을 때 first가 콘솔창에 나타나게 되는것 입니다.

참고) setTimeout의 delay를 0으로 주더라도 0초 보다 더 걸리는 이유는 콜 스택에서 모든 프레임이 실행될 때까지 기다려야하기 때문.

### 잡 큐(Job Queue)
ES6에서는 새로운 컨셉인 '잡 큐(Job Queue)'가 도입되었습니다. 이것은 이벤트루프 큐 위에 존재하는 계층으로서 아마도 프로미스의 비동기성을 다루다 보면 마주치게 될 것입니다(후에 프로미스에 대해서도 다룹니다). 잡큐는 이벤트 루프 큐에서 모든 틱의 끝에 부착되어 있는 큐라고 생각하면 됩니다. 이벤트루프의 틱 도중에 일어날 수 있는 특정 비동기 행동은 새로운 이벤트 전체가 이벤트 루프 큐에 추가되도록 하지는 않지만 잡과 같은 아이템 하나는 현재 틱의 잡 큐 끝에 추가시킬 수 있습니다.

이는 나중에 실행될 수 있는 또 다른 기능을 추가시킬 수 있다는 의미가 되며 우리는 이것이 바로 다음 순서로, 다른 무엇 보다도 우선해서 실행될 것이라고 확신할 수 있습니다. 잡으로 인해 더 많은 잡들이 같은 큐에 추가될 수 있습니다. 이론적으로 하나의 잡 루프(계속해서 다른 잡을 추가하는 잡)가 무한히 돌면서 프로그램이 다음 이벤트 루프 틱을 실행하는데 필요한 자원을 고갈시킬 수 있습니다. 개념적으로 이는 오랫동안 실행되거나 영원히 반복되는 코드(while(true) {...})와 비슷합니다. 잡은 setTimeout(callback, 0) 핵과도 유사하지만 훨씬 더 잘 정의되고 순서가 보장되는 방법으로 구현되어 있습니다. (나중에 수행해라. 하지만 가능한 빨리.)

## Non-Blocking
Non-Blocking은 I/O 방식 중 하나인데, I/O는 컴퓨터가 데이터를 주고받을 때의 입출력 프로세스를 말합니다. Event Loop를 잘 활용하면 오래걸리는 작업을 효율적으로 처리할 수 있습니다. Non-Blocking 방식은 마치 멀티 쓰레드를 가진것처럼 시스템을 호출한 직후에 프로그램으로 제어가 다시 돌아와서 시스템 호출의 종료를 기다리지 않고 다음 처리로 넘어갈 수 있습니다. 참고로 Blocking방식은 한 함수가 프로세스가 시스템을 호출 하고나서 결과가 반환되기까지 다음 처리로 넘어가지 않습니다.



----
해당 내용은 다음 글을 참고 하였습니다.
- https://k39335.tistory.com/9
- https://joshua1988.github.io/web-development/translation/javascript/how-js-works-inside-engine/
- https://huurray.github.io/js/2019/01/05/js-callStack/
- https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84-Event-Loop-Event-Queue-Call-Stack
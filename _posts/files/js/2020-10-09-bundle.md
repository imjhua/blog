---
layout: post
title: 모듈 번들링(Http/2에서의 번들링)
categories: JavaScript
---

모듈 번들링은 모듈 그룹 (및 해당 종속성)을 올바른 순서로 단일 파일 (또는 파일 그룹)로 연결하는 프로세스입니다.

## 배경

기존의 프론트엔드 자바스크립트는 특별히 모듈화나 디펜던시관리에 대한 방법이 없어 필요한 자바스크립트 파일을 정해진 순서에 맞게 직접 스크립트 태그로 로드하고 각각 약속된 네임스페이스에 담아 공유하였습니다. 옛날 자바스크립트는 모듈 개념이 없었기 때문에 파일이 나누어져 있어도 변수 스코프를 생각하면서 개발을 해야했습니다. 웹페이지에서는 페이지를 보여주기 위한 수 많은 자바스크립트 파일을 서버에 요청합니다. 이를 통해 웹페이지를 보여주기 위해 서버와 여러번 통신하게 되는게 비효율적이다 라고 볼 수 있습니다. 이런 방식은 프로젝트가 커질수록 그리고 참여 개발자가 많을수록 문제를 일으켰습니다.

- 문제점:

* 서버요청 비효율적
* 스크립트가 이순서대로 진행됨 -> 이러한 순서를 신경 써야함.
* dependency가 꼬일 수있음
  이를 해결하기위해 모듈의 개념이 등장하였습니다.

## 모듈을 번들링하는 이유

스크립트를 HTML에서 로드될때 브라우저가 하는 DOM파싱작업을 블로킹 시킵니다. 요청수가 많다면 그만큼 파싱하는데 오랜 시간이 걸립니다. 이 문제를 해결하기 위해, 즉 요청 수를 줄이기 위해 모든 파일을 하나의 큰 파일 (또는 경우에 따라 몇 개의 파일)로 묶을 수 있습니다.

번들링 작업 속도를 높이기위한 또 다른 일반적인 접근 방식은 번들 코드를 "축소"하는 것입니다. 축소는 코드의 기능을 변경하지 않고 콘텐츠의 전체 크기를 줄이기 위해 소스 코드에서 불필요한 문자 (예: 공백, 주석, 줄 바꿈 문자 등)를 제거하는 프로세스입니다.

### 단점

수 많은 자바스크립트 파일이 하나의 파일로 묶인다면 초기 로딩 속도가 어마어마해 질 수 있습니다. 모듈 번들러들은 이런 문제를 해결하기 위해 청크, 캐시, 코드 스플릿 개념들을 도입하면서 문제들을 해결하고 있습니다.

## 번들링 종류

### CommonJS 번들링

CommonJS는 모듈을 동기식으로로드합니다. Browserify라는 모듈 번 들러입니다. Browserify는 브라우저 용 CommonJS 모듈을 컴파일하는 도구입니다.

### AMD 번들링

AMD를 사용하는 경우 RequireJS 또는 Curl과 같은 AMD 로더 를 사용하는 것이 좋습니다. 모듈 로더 (번 들러 대비)는 프로그램이 실행해야하는 모듈을 동적으로로드합니다.

### ES6 모듈

현재 JS 모듈 형식 (CommonJS, AMD)과 ES6 모듈의 가장 중요한 차이점은 ES6 모듈이 정적 분석을 염두에두고 설계되었다는 것입니다. 이것이 의미하는 바는 모듈을 가져올 때 컴파일 시간, 즉 스크립트 실행이 시작되기 전에 가져 오기가 해결된다는 것입니다. 이를 통해 프로그램을 실행하기 전에 다른 모듈에서 사용하지 않는 내보내기를 제거 할 수 있습니다. 사용하지 않는 내보내기를 제거하면 공간이 크게 절약되어 브라우저의 스트레스를 줄일 수 있습니다.

ES6 모듈을 다르게 만드는 것은 "트리 쉐이킹"이라고하는 사용하지 않는 코드에 대한 접근 방식입니다. 트리 쉐이킹을 통해 사용하지않는 코드가 번들에서 제거하고 필요한 코드만 합치게됩니다.

단, 아래와 같은 이유로 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적입니다.

- IE를 포함한 구형 브라우저는 ES6 모듈을 지원하지 않는다.
- 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하다.
- 아직 지원하지 않는 기능(Bare import 등)이 있다. (ECMAScript modules in browsers 참고)
- 점차 해결되고는 있지만 아직 몇가지 이슈가 있다. (ECMAScript modules in browsers 참고)

### 웹팩

CommonJS, AMD 또는 ES6를 적절하게 사용할 수 있도록 사용하는 모듈 시스템에 구애받지 않도록 설계되었습니다.

## Http/2에서의 번들

기존 HTTP/1에서는 TCP 연결 당 하나의 요청 만 허용됩니다. 이로인해 여러 리소스를로드 할 때 여러 요청이 필요하였습니다. HTTP/2를 사용하면 TCP연결당 하나의 요청의 제한에서 좀더 자유로울 수 있습니다. 여러 요청과 응답이 동시에 가능하여 결과적으로 단일 연결로 여러 요청을 동시에 처리 할 수 ​​있습니다. HTTP 요청 당 비용이 HTTP/1보다 훨씬 낮기 때문에 여러 모듈을로드하는 것이 장기적으로 큰 성능 문제가되지는 않습니다.

참고) 2018년 10월 기준 약 30% 가량의 웹 사이트는 HTTP/2 를 지원하고 있습니다.

HTTP/2 는 멀티 리소스 로딩도 빠른데, HTTP/2가 모듈 번 들러를 쓸모 없게 만들까요? 그렇다면, HTTP/2요청에서는 번들이 필요하지 않을까요?
이것은 분명 상황에 따라 다를것입니다. 예를들어, 캐싱이 필요한 환경이라면, HTTP/1에서 대안으로 제공했던 하나의 큰 bundle파일로 처리하기 보다는 Grouping된 여럿의 작은 bundles가 더 효과적일 것 입니다. 작은 하나가 변경된다고 큰 하나를 불러올 필요가 없기 때문에 여러개의 작은 bundle 파일들은 캐싱에도 더욱 효과적입니다.

## 정리

번들링은 멀티리소스(여러요청)에 대한 HTTP 요청 오버헤드를 줄일 수 있는 한가지 방안입니다. 여러개의 필요한 자원을 하나로 만들어 요청오버헤드를 줄이고, 성능 개선을 도모하자!는 것입니다.

요청오버헤드는 리소스 요청에 대해 Connection이 여러번 발생하는 것이 가장 많은 부분들 차지하게되는데,

- 장점: 하나의 파일로 bundling하여 http connection을 최소화 한다
- 단점: 하나의 작은 파일 변경에도 (bundle.js에 포함된 하나의 css파일이 변경되었다 하더라도)
  전체를 다시 bundling 하기 때문에, bundle.js라는 큰 파일에 대한 캐싱이 어렵다

그러나, http 연결과 캐싱의 trade-off에서, connection 최소화에 더 많은 성능 개선이 있기때문에
HTTP/1 에서 webpack을 통한 bundling을 하는 이유라고 할 수 있겠습니다.

HTTP/2의 주요 목표는 지연 시간을 줄이는 것이며 이를 위해 전체 요청 및 응답 다중화를 지원하고, HTTP 헤더 필드의 효율적 압축을 통해 프로토콜 오버헤드를 최소화하고, 요청 우선순위 지정 및 서버 푸시를 지원합니다. 이러한 요구사항을 구현하기 위해 다양한 프로토콜 개선사항(예: 새로운 흐름 제어, 오류 처리 및 업그레이드 메커니즘)이 지원되지만, 무엇보다 모든 웹 개발자들이 이해하고 애플리케이션에 활용해야 하는 가장 중요한 것들은 바로 이러한 기능들입니다.

---

해당 내용은 다음 글을 참고 하였습니다.

- https://www.freecodecamp.org/news/javascript-modules-part-2-module-bundling-5020383cf306/
- https://velog.io/@doondoony/HTTP2-and-Webpack

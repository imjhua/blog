---
layout: post
title: JavaScript
categories: TODO
---

## tabl
- https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-1/tabs.html
- https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/tabs-1/js/tabs.js
- https://www.w3.org/TR/wai-aria-practices-1.1/examples/tabs/css/tabs.css

## 이벤트 캡쳐링 버블링
표준 DOM이벤트에서 정의한 이벤트 흐름엔 3가지 단계가 있다.
1. 캡쳐링: 이벤트가 하위요소로 전파되는 단계
2. 타겟: 이벤트가 실제 타겟 요소에 전달되는 단계
3. 버블링: 이벤트가 상위요소로 전파되는 단계, 이벤트가 발생하는 가장 안쪽부터 바깥쪽, 하위노드에서 상위노드로 이벤트가 전파되는 과정

이벤트는 최상위요소 window부터 시작해 아래로 전파되고(캡쳐링) 이벤트가 타겟 요소에 도착해 실행된 후(타겟단계) 다시 위로 전파된다.(버블링) 이런 과정을 통해 요소에 할당된 이벤트 핸들러가 호출된다.

예를 들면 테이블, 리스트...

[이벤트위임]

이벤트 위임은 이벤트 리스너를 하위 요소에 추가하는 대신 상위 요소에 추가하는 기법입니다. 리스너는 DOM의 event bubbling으로 인해 하위 요소에서 이벤트가 발생될 때마다 실행됩니다. 이 기술의 이점은 다음과 같습니다.

각 하위 항목에 이벤트 핸들러를 연결하지 않고, 상위 요소에 하나의 단일 핸들러만 필요하기 때문에 메모리 사용 공간이 줄어듭니다.
제거된 요소에서 핸들러를 해제하고 새 요소에 대해 이벤트를 바인딩할 필요가 없습니다.

하위요소에 각각 이벤트를 붙이지 않고 상위요소에서 하위요소의 이벤트들을 제어하는 방식. 이벤트가 하위요소로 전파되는 단계인 캡쳐링을 이용한다.

참고) 거의 모든 이벤트는 버블링 됩니다.
키워드는 ‘거의’ 입니다. focus 이벤트와 같이 버블링 되지 않는 이벤트도 있습니다. 버블링 되지 않는 이벤트의 종류에 대해선 조금 후에 알아보겠습니다. 몇몇 이벤트를 제외하곤 대부분의 이벤트는 버블링 됩니다.


[이벤트 api]

- event.preventDefault(): 현재 이벤트의 기본 동작을 중단한다.
- event.stopPropagation(): 현재 이벤트가 상위로 전파되지 않도록 중단한다.
- event.stopImmediatePropagation(): 현재 이벤트가 상위뿐 아니라 현재 레벨에 걸린 다른 이벤트도 동작하지 않도록 중단한다.


- event.stopPropagation():  위쪽으로 일어나는 버블링은 막아주지만, 다른 핸들러들이 동작하는 건 막지 못합니다.
- event.stopImmediatePropagation(): 한 요소의 특정 이벤트를 처리하는 핸들러가 여러개인 상황에서, 핸들러 중 하나가 버블링을 멈추더라도 나머지 핸들러는 여전히 동작합니다. 

버블링을 멈추고, 요소에 할당된 다른 핸들러의 동작도 막으려면 event.stopImmediatePropagation()을 사용해야 합니다. 이 메서드를 사용하면 요소에 할당된 특정 이벤트를 처리하는 핸들러 모두가 동작하지 않습니다.


## 블로그 번역

- https://blueshw.github.io/

## requestIdleCallback
requestIdleCallback API는 우선 순위가 낮은 작업을 콜백 함수로 전달해 브라우저 메인 스레드가 한가해지는 시점(idle 상태)에 호출합니다. 이를 통해 불필요한 프레임 지연을 줄여 렌더링을 개선할 수 있습니다.
대표적으로 웹사이트 활동을 추적해 수집하는 스크립트에 적용이 가능합니다. 호텔 상세 페이지에 진입하면 호텔 정보를 보여주는게 최우선이기 때문에 진입 이벤트 전송은 그 이후 해도 무방할 것입니다.

```js
window.requestIdleCallback(() => {
  sendEvent('viewHotel', { hotelId: 123 });
});
```

## IntersectionObserver
IntersectionObserver API는 당신이보기에 때 요소의 스크롤을 통보받을 수 있습니다. 이것은 지연 로딩 이미지 및 스크롤 애니메이션과 같은 작업에 매우 유용합니다. 이전 getBoundingClientRect()에는 메인 스레드의 루프에서 실행되는 것과 같은 메서드를 사용해야 만 가능했습니다 . 이제 이것은 브라우저에 의해 비동기 적으로 수행되어 값 비싼 DOM 쿼리의 메인 스레드를 확보 할 수 있습니다.

## 강제 동기식 레이아웃 & 레이아웃 스레싱
- https://thisblogfor.me/web/raf_perform/
- https://medium.com/myrealtrip-product/fe-website-perf-part2-e0c7462ef822
- https://www.viget.com/articles/animation-performance-101-optimizing-javascript/ 

아이디어!
여기서 해결책 은 첫 번째 예제에서했던 것처럼 DOM 쓰기 전에 DOM 읽기를 수행하는 것 입니다. 이렇게하면 캐시 된 값을 활용하고 브라우저가 올바른 순서로 렌더링을 실행할 수 있습니다.

브라우저가 열심히 스타일을 계산해 위치를 정하고 있는데 스타일 정보를 조회하거나 변경하는 경우 (강제 동기식 레이아웃, Forced Synchronous Layout)

반복문과 같이 빠른 주기로 실행되는 코드에 픽셀 파이프라인을 유발하는 부분이 있는 경우 (레이아웃 스래싱, Layout Thrashing)
레이아웃 스 래싱 은 여러 강제 동기 레이아웃을 빠르게 연속적으로 트리거하는 경우입니다. 움직이는 상자 애니메이션으로 볼 수 있습니다 .







## 애니메이션 성능
- https://wit.nts-corp.com/2020/06/05/6134

## 이벤트 스크롤 최적화
- https://jbee.io/web/optimize-scroll-event/

## 동기 비동기
- 음..

## 모던 튜터리얼
- https://ko.javascript.info/template-element



---


해당 내용은 다음 글을 참고 하였습니다.

- https://velog.io/@jakeseo_me/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%AC%B8%EC%A0%9C-%EB%8B%B5%ED%95%B4%EB%B3%B4%EA%B8%B0-1
- https://mishka.kr/
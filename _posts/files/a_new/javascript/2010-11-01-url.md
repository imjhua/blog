---
layout: post
title: JavaScript
categories: TODO
---

## requestIdleCallback
requestIdleCallback API는 우선 순위가 낮은 작업을 콜백 함수로 전달해 브라우저 메인 스레드가 한가해지는 시점(idle 상태)에 호출합니다. 이를 통해 불필요한 프레임 지연을 줄여 렌더링을 개선할 수 있습니다.
대표적으로 웹사이트 활동을 추적해 수집하는 스크립트에 적용이 가능합니다. 호텔 상세 페이지에 진입하면 호텔 정보를 보여주는게 최우선이기 때문에 진입 이벤트 전송은 그 이후 해도 무방할 것입니다.

```js
window.requestIdleCallback(() => {
  sendEvent('viewHotel', { hotelId: 123 });
});
```

## IntersectionObserver
IntersectionObserver API는 당신이보기에 때 요소의 스크롤을 통보받을 수 있습니다. 이것은 지연 로딩 이미지 및 스크롤 애니메이션과 같은 작업에 매우 유용합니다. 이전 getBoundingClientRect()에는 메인 스레드의 루프에서 실행되는 것과 같은 메서드를 사용해야 만 가능했습니다 . 이제 이것은 브라우저에 의해 비동기 적으로 수행되어 값 비싼 DOM 쿼리의 메인 스레드를 확보 할 수 있습니다.

## 강제 동기식 레이아웃 & 레이아웃 스레싱
- https://thisblogfor.me/web/raf_perform/
- https://medium.com/myrealtrip-product/fe-website-perf-part2-e0c7462ef822
- https://www.viget.com/articles/animation-performance-101-optimizing-javascript/ 

아이디어!
여기서 해결책 은 첫 번째 예제에서했던 것처럼 DOM 쓰기 전에 DOM 읽기를 수행하는 것 입니다. 이렇게하면 캐시 된 값을 활용하고 브라우저가 올바른 순서로 렌더링을 실행할 수 있습니다.

브라우저가 열심히 스타일을 계산해 위치를 정하고 있는데 스타일 정보를 조회하거나 변경하는 경우 (강제 동기식 레이아웃, Forced Synchronous Layout)

반복문과 같이 빠른 주기로 실행되는 코드에 픽셀 파이프라인을 유발하는 부분이 있는 경우 (레이아웃 스래싱, Layout Thrashing)
레이아웃 스 래싱 은 여러 강제 동기 레이아웃을 빠르게 연속적으로 트리거하는 경우입니다. 움직이는 상자 애니메이션으로 볼 수 있습니다 .



//

따라서 Javascript를 사용하여 레이아웃을 트리거 할 수도 있다는 것을 아는 것이 중요합니다. 레이아웃을 쿼리하여 DOM에서 읽는 방법과 레이아웃을 변경하여 DOM에 쓰는 두 가지 방법이 있습니다.
```js
function() {
  // 콘솔 스냅샷?
  console.log(box.offsetWidth); // read from DOM, query layout
  box.style.width = newWidth; // write to DOM, change layout

  doMoreWork();
}

function() {
  // 스냅샷 무효화??
  // offsetWidth는 읽기전에 레이아웃을 계산한다.
  // 레이아웃 계산을 뒤로 미룬다.
  // 그러나 읽기 전에 DOM에 쓰는 경우 브라우저가 레이아웃을 일찍 실행하도록 강제 할 수 있습니다 .
  box.style.width = newWidth; // write to DOM, invalidating previous snapshot
  console.log(box.offsetWidth); // read from DOM, forcing Layout because previous snapshot was invalidated

  doMoreWork();
}

```
먼저 레이아웃을 변경하여 이전 프레임의 스냅 샷을 무효화하여 콘솔 로그 문이 더 이상 캐시 된 값에서 읽을 수 없도록 만듭니다. 브라우저는 업데이트 된 값을 제공하기 위해 이전 doMoreWork() 에 레이아웃을 실행해야 합니다. 이를 강제 동기 레이아웃 이라고 합니다 . 기본적으로 브라우저가 원하는 것보다 먼저 레이아웃을 실행하도록

- https://www.viget.com/articles/animation-performance-101-optimizing-javascript/


## setinterval
- https://dev.opera.com/articles/better-performance-with-requestanimationframe/

setTimeout API는 설정된 시간 동안 지연된 뒤 event loop에 밀려 있는 작업량에 관계없이 대기 작업으로 추가합니다. 이 때문에 렌더링과 관련된 코드가 적합하지 않은 시점에 실행될 수 있습니다. 반면 requestAnimationFrame API는 호출한 시점을 기준으로 다음 애니메이션 프레임이 시작될 때 전달된 콜백 함수가 실행되는 것을 보장합니다.
그 덕분에 특정 시간동안 지속적으로 프레임을 생성하는 경우 부드러운 애니메이션을 제공할 수 있습니다. 단, 콜백 함수의 실행 시간이 프레임 속도의 기준인 16ms를 넘어가지 않도록 유의해야 합니다.
이 API를 달력을 여는 시점의 스크롤 제어로 인해 강제 동기식 레이아웃이 발생하는 코드에 적용해봤습니다.


## 애니메이션 성능
- https://wit.nts-corp.com/2020/06/05/6134

## 이벤트 스크롤 최적화
- https://jbee.io/web/optimize-scroll-event/

## 동기 비동기
- 음..

## 모던 튜터리얼
- https://ko.javascript.info/template-element



---


해당 내용은 다음 글을 참고 하였습니다.

- https://velog.io/@jakeseo_me/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EB%AC%B8%EC%A0%9C-%EB%8B%B5%ED%95%B4%EB%B3%B4%EA%B8%B0-1
- https://mishka.kr/
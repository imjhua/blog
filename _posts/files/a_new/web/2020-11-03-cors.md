---
layout: post
title: 교차 출처 리소스 공유 (CORS, Cross-Origin Resource Sharing)
categories: Web
---

동일-출처 정책(same-origin policy)은 웹 애플리케이션의 중요한 보안 모델입니다. 주로 스크립트로부터의 데이터 접근에 적용됩니다. 일치하는 HTML 태그를 경유하는 이미지, CSS, 스크립트 등 출처를 경유하여 리소스를 임베드하는 것은 제한되지 않지만 교차출처에 대한 리소스 공유는 허용하지 않습니다. 다른 출처에 대한 자원은 어떻게 접근해야 할 수 있을까요?

## 교차 출처 리소스 공유 (CORS)

교차 출처 리소스 공유(Cross-Origin Resource Sharing, CORS)는 추가 HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제입니다. 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 교차 출처 HTTP 요청을 실행합니다.

### CORS에러

교차출처를 요청 대한 응답으로 서버는 Access-Control-Allow-Origin 헤더를 다시 보냅니다. Access-Control-Allow-Origin 은 단일 출처를 지정하여 브라우저가 해당 출처가 리소스에 접근하도록 허용합니다. 또는 자격 증명이 없는 요청의 경우 "\*" 와일드 카드는 브라우저의 origin에 상관없이 모든 리소스에 접근하도록 허용합니다.

## preflight(사전전달) 요청

서버 데이터에 부수 효과(side effect)를 일으킬 수 있는 HTTP 요청 메서드(GET을 제외한 HTTP 메서드)에 대해, CORS 명세는 브라우저가 요청을 OPTIONS 메서드로 "프리플라이트"(preflight, 사전 전달)하여 지원하는 메서드를 요청하고, 서버의 "허가"가 떨어지면 실제 요청을 보내도록 요구하고 있습니다. 또한 서버는 클라이언트에게 요청에 "인증정보"(쿠키, HTTP 인증)를 함께 보내야 한다고 알려줄 수도 있습니다.

단순요청과는 조금 다릅니다. 프리플라이트 요청을 통해 먼저 OPTIONS 메서드를 통해 다른 도메인의 리소스로 HTTP 요청을 보내 실제 요청이 전송하기에 안전한지 확인합니다. Cross-site 요청은 유저 데이터에 영향을 줄 수 있기 때문에 이와같이 미리 전송(preflighted)합니다. 서버가 어떤 호스트(Origin), 헤더 또는 메서드를 지원하는지, 인증정보가 필요하다는 등의 정보를 알려줍니다.

기본적으로 자격증명은 보내지 않지만 인증정보(쿠키 등)를 포함하는 XML요청의 경우, credentialed 요청을 꼭 해야만 합니다. withCredentials 속성을 true로 넘겨야 합니다

```js
const invocation = new XMLHttpRequest();
const url = "http://bar.other/resources/credentialed-content/";

function callOtherDomain() {
  if (invocation) {
    invocation.open("GET", url, true);
    invocation.withCredentials = true;
    invocation.onreadystatechange = handler;
    invocation.send();
  }
}
```

## 자격증명 요청 및 와일드카드(Credentialed requests and wildcards)

단순요청의 경우 서버의 응답에서는 상관없으나, credentialed 요청 에 응답할 때 서버는 Access-Control-Allow-Origin 헤더 "\*" 와일드카드를 사용하는 대신에 반드시 에 값을 지정해야 합니다. 요청에 대한 fetch가 시작되는 위치 Origin(전체경로가 아님)을 적용하면 허용할 수 있습니다.

참고) refferer은 전체 경로를 갖는다.

## CORS 관련 HTTP Response Headers

서버에서 CORS 요청을 처리할 때 지정하는 헤더들입니다.

### Access-Control-Allow-Origin

Access-Control-Allow-Origin 헤더의 값으로 지정된 도메인으로부터의 요청만 서버의 리소스에 접근할 수 있게 합니다. Request with Credential의 경우에는 \*를 사용할 수 없습니다. 또한 보통 Access-Control-Allow-Origin 옵션은 1개의 도메인만 작성할 수 있게 되어 있습니다. 만약 1개 이상의 도메인을 적으면 에러를 발생합니다.

### Access-Control-Expose-Headers

기본적으로 브라우저에게 노출이 되지 않지만, 브라우저 측에서 접근할 수 있게 허용해주는 헤더를 지정합니다.

기본적으로 브라우저에게 노출이 되는 HTTP Response Header는 아래의 6가지 밖에 없습니다.

- Cache-Control
- Content-Language
- Content-Type
- Expires
- Last-Modified
- Pragma

### Access-Control-Max-Age

Preflight Request의 결과가 캐쉬에 얼마나 오래동안 남아있는지를 나타냅니다.

### Access-Control-Allow-Credentials

Request with Credential 방식이 사용될 수 있는지를 true/false 값으로 지정합니다.

Simple Request에 withCredentials = true가 지정되어 있는데, Response Header에 Access-Control-Allow-Credentials: true가 명시되어 있지 않다면, 그 Response는 브라우저에 의해 무시됩니다. 예비 요청에 대한 응답에 Access-Control-Allow-Credentials: false를 포함하면, 본 요청은 Request with Credential을 보낼 수 없습니다.

### Access-Control-Allow-Methods

예비 요청에 대한 Response Header에 사용되며, 서버의 리소스에 접근할 수 있는 HTTP Method 방식을 지정합니다.

### Access-Control-Allow-Headers

예비 요청에 대한 Response Header에 사용되며, 본 요청에서 사용할 수 있는 HTTP Header를 지정합니다.

## CORS 관련 HTTP Request Headers

클라이언트가 서버에 CORS 요청을 보낼 때 사용하는 헤더로, 브라우저가 자동으로 지정하며, XMLHttpRequest를 사용하는 프로그래머가 직접 지정해 줄 필요가 없습니다.

### Origin

Cross-site 요청을 날리는 요청 도메인 URI을 나타내며, access control이 적용되는 모든 요청에 Origin 헤더는 반드시 포함됩니다.

### Access-Control-Request-Method

예비 요청을 보낼 때 포함되어, 본 요청에서 어떤 HTTP Method를 사용할 지 서버에게 알려줍니다. method는 POST, GET, DELETE 등이 포함될 수 있습니다.

### Access-Control-Request-Headers

예비 요청을 보낼 때 포함되어, 본 요청에서 어떤 HTTP Header를 사용할 지 서버에게 알려줍니다. Authorization, Content-type 등이 있습니다.

## 정리

기본적을 애플리케이션은 동일-출처 정책(same-origin policy)을 가지기 때문에 교차출처에 대한 자원 요청은 이루어지지 않습니다. 이를 허용하기 위해 서버는 반드시 Access-Control-Allow-Origin 에 허용하는 오리진을 특정해야 합니다.

또 기본적으로 브라우저가 제공하는 비동기 리소스 요청 API인 XMLHttpRequest 객체나 fetch API는 별도의 옵션 없이 브라우저의 쿠키 정보나 인증과 관련된 헤더를 함부로 요청에 담지 않는데 이때 요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션으로 credentials 를 사용할 수 있습니다.

CORS 실패는 오류의 원인이지만, 보안상의 이유로 JavaScript에서는 오류의 상세 정보에 접근할 수 없으며, 알 수 있는 것은 오류가 발생했다는 사실 뿐입니다. 정확히 어떤 것이 실패했는지 알아내려면 브라우저의 콘솔을 봐야 합니다.

---

해당 내용은 다음 글을 참고 하였습니다.

- https://developer.mozilla.org/ko/docs/Web/HTTP/CORS
- https://brownbears.tistory.com/336
- https://evan-moon.github.io/2020/05/21/about-cors/

---
layout: post
title: 스크롤이벤트성능과 passive옵션
categories: Web
---

스크롤이벤트성능문제를 해결하는 방안으로 `{passive:true}`옵션설정에 대한 가이드가 있습니다. 스크롤이벤트의 성능과 해당 옵션은 어떤 관계가 있는지 알아봅니다.

<hr />

<!-- vscode-markdown-toc -->

- [이벤트 등록(addEventListener)](<#이벤트-등록(addeventlistener)>)
- [브라우저 렌더링](#브라우저-렌더링)
- [이벤트성능을 위한 렌더러 프로세스의 이해](#이벤트성능을-위한-렌더러-프로세스의-이해)
  - [렌더러 프로세스](#렌더러-프로세스)
    - [메인 스레드(주가 되는)](<#메인-스레드(주가-되는)>)
    - [레스터 스레드](#레스터-스레드)
    - [컴포지터 스레드](#컴포지터-스레드)
- [이벤트 핸들러의 동작](#이벤트-핸들러의-동작)
  - [e.preventDefault()](<#e.preventdefault()>)
- [정리](#정리)

<!-- vscode-markdown-toc-config
	numbering=false
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

## <a name='이벤트-등록(addeventlistener)'></a>이벤트 등록(addEventListener)

자바스크립트에서 스크롤 이벤트를 등록하기 위해서는 window객체에 스크롤이벤트를 등록하는 메서드인 addEventListener()를 호출해야 합니다. 메서드에는 핸들러를 등록하여 이벤트 발생시마다 호출되는 콜백을 지정할 수 있습니다. 기본적으로 버블링이벤트가 발생하며 캡쳐링을 원하는 경우 다음 구문을 통해 지정할 수 있습니다.

```js
target.addEventListener(type, listener[, options]);

target.addEventListener(type, listener[, useCapture]);
```

참고) 이벤트의 타겟(EventTarget)의 addEventListener() 메서드는 지정한 이벤트가 대상에 전달될 때마다 호출할 함수를 설정하여 이벤트를 등록할 수 있습니다.일반적인 대상은 Element, Document, Window있고, XMLHttpRequest와 같이 이벤트를 지원하는 모든 객체를 대상으로 지정할 수도 있습니다.

## <a name='브라우저-렌더링'></a>브라우저 렌더링

- Recalculate Style: 요소에 적용할 스타일을 계산.
- Layout: 요소의 레이아웃을 생성하고, 화면에 배치.
- Paint: 생성된 모든 레이아웃에 픽셀을 추가. GPU는 필요에 따라 생성한 레이어의 비트맵을 사용해 화면에 렌더링.
- Composite Layers: 생성한 레이어 계층을 합성. 이 계층을 내려다보면 모든 요소가 고유한 위치(복합 계층)를 갖는 완전한 웹 페이지로 보여짐.

마지막 단게인 Composite Layers(합성) 생성은 CPU가 애니메이션을 처리하기 위해 GPU와 통신하는 단계입니다.

## <a name='이벤트성능을-위한-렌더러-프로세스의-이해'></a>이벤트성능을 위한 렌더러 프로세스의 이해

이벤트성능을 고민해 보기 위해서는 이벤트가 어떤 과정을 통해 동작하는지 알아야 합니다. 이벤트가 실행하는 콜백(핸들러)는 이벤트발생시 변화를 감지하여 결국 렌더링을 거치게 될 것입니다. 이 렌더링은 브라우저 내부에는 웹콘텐츠를 담당하는 렌더러 프로세스가 렌더링을 하고 있습니다. 렌더러 프로세스의 주요 역할은 HTML과 CSS, JavaScript를 사용자와 상호작용을 할 수 있는 웹 페이지로 변환하는 것입니다.

### <a name='렌더러-프로세스'></a>렌더러 프로세스

컨텐츠를 담당하기 위해 브라우저 탭 내부에서 발생하는 모든 작업을 담당하는 프로세스입니다.

- 메인스레드
- 컴포지터 스레드
- 레스터스레드

#### <a name='메인-스레드(주가-되는)'></a>메인 스레드(주가 되는)

브라우저로 전송된 대부분의 코드를 처리합니다. DOM, 레이아웃 및 자바스크립트 실행과 페인팅과 합성도 담당합니다. 레이어를 사용하면 페이지의 큰 부분이 변경될 때 굉장히 많은 도움이 되는데, 레아이웃으로 나누어진 상태에서 렌더링이 일어나는 경우 페인트 작업양이 많이 줄어들어 성능이점을 얻을 수 있습니다. 단! 레이어가 도움이 되지 않는 경우가 많이 있습니다. 예를 들어, 배경색을 애니메이션으로 만들면 어쨌든 전체 레이어를 다시 칠해야 합니다. 레이어들은 많은 메모리를 차지하고 실제로 작업을 더 느리게 만들 수 있습니다. 이 레이어는 적은 양의 CSS 속성들만으로도 처리할 수 있습니다.

참고) 간혹 웹 워커나 서비스 워커를 사용하는 경우에는 워커 스레드가 JavaScript 코드의 일부를 처리하기도 한다.

#### <a name='레스터-스레드'></a>레스터 스레드

페인팅시 픽셀(pixel)단위로 색을 칠하는데, 이때 점을 연결하여 선을 만들어 어떤 도형으로 덮여 있는지 알 수 있습니다. 이 작업을 레스터화라고 합니다. 이를 담당하는 스레드가 레스터 스레드 입니다.

참고) 이제 도형으로 어떤 픽셀이 덮여있는지 알았으니, 도형 안의 각 픽셀을 통해 어떤 색상이 사용되었는지도 알 수 있다. 이것을 픽셀 셰이딩(pixel shading)이라고 한다.

#### <a name='컴포지터-스레드'></a>컴포지터 스레드

병렬처리를 담당합니다. 이 컴포지터 스레드는 GPU에서 발생한 합성 작업의 관리자가 되었습니다. 자바스크립트 실행과 같이 메인 스레드가 무언가를 하고 있다면, 컴포지터 스레드는 사용자가 스크롤할 때 콘텐츠가 스크롤되는 것처럼 사용자를 위한 것들을 처리하게 됩니다. 브라우저는 합당한 곳에서 레이어들의 결합을 필요로 하지만 그 장소를 알려주는 것은 어렵습니다. 즉, 페이지에서 서로 다른 것들이 많이 움직이면, 그냥 많은 레이어들로 끝날 수 있습니다. 이 레이어들은 메모리를 가득 채우며 컴포지터로 전송되는데 오랜 시간이 걸립니다.

합성은 웹 페이지의 각 부분을 레이어로 분리해 별도로 래스터화하고 컴포지터 스레드(compositor thread)라고 하는 별도의 스레드에서 웹 페이지로 합성하는 기술입니다. 스크롤되었을 때 레이어는 이미 래스터화되어 있으므로 새 프레임을 합성하기만 하면 됩니다. 애니메이션 역시 레이어를 움직이고 합성하는 방식으로 만들 수 있습니다.

## <a name='이벤트-핸들러의-동작'></a>이벤트 핸들러의 동작

자바스크립트에 addEventListener()를 통해 등록된 이벤트는 컴포지터 스레드가 받습니다. 이벤트가 들어오면 컴포지터 스레드는 메인 스레드에 이벤트를 넘기고 렌더링 파이프라인에 따라 layout, paint를 거쳐 Layout tree를 기다리는 것이 원래의 동작입니다. 만약, 핸들러의 동작이 크기 색상의 변화 없이, 합성만을 담당한다면 메인스레드를 거치지 않고 컴포지터스레드가 바로 처리할 수 있도록 하면 절차가 생략되므로 성능의 이점을 확인 할 수 있습니다.

```js
window.addEventListener('scroll', function(), {passive: true});
```

### <a name='e.preventdefault()'></a>e.preventDefault()

e.preventDefault()는 target의 기본 동작을 막는 메소드입니다. 이경우 메인스레드에서의 처리가 필요합니다. passive속성으로 메인스레드의 처리를 기다리지 않고 컴포지터스레드가 바로 합성을 한다고 하였는데, 메인스레드로 요청이 가면 모순이 생기겠지요? 따라서 e.preventDefault()를 통해 이벤트를 막을 필요가 있다면 passive 속성은 꼭 false가 되어야 합니다.

## <a name='정리'></a>정리

passive옵션을 허용하면, 이벤트를 받는 컴포지터 스레드에 해당 이벤트가 메인 스레드의 처리를 기다리지 않고 바로 Composite를 수행해도 된다는 힌트를 주는 것입니다.

스크롤 이벤트에서는 이미 만들어진(리플로우&리페인트) 레이어들을 합성만 하면 되는 경우, 메인스레드를 거치지 않고 합성만 담당하는 컴포지터스레드에게 바로 넘겨 핸들러가 수행되도록 할 수 있습니다. 이미 래스터화되어 있으므로 새 프레임을 합성만 하면 되는 것입니다.

이 속성이 설정되면 컴포지터 스레드는 원래의 동작대로 이벤트를 메인 스레드에 넘기기는 하지만, 처리를 기다리지 않고 바로 Composite를 수행합니다. 즉, 스크롤 이벤트를 받아 새 프레임을 바로 합성할 수 있다는 의미이고, 결과적으로 스크롤 성능이 향상되게 됩니다.

---

해당 내용은 다음 글을 참고 하였습니다.

- https://amati.io/eventlisteneroptions-passive-true/
- https://d2.naver.com/helloworld/5237120
- https://ui.toast.com/weekly-pick/ko_20171016/

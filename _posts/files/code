// you can write to stdout for debugging purposes, e.g.
// console.log('this is a debug message');

function solution(A, B) {
    // write your code in JavaScript (Node.js 8.9.4)

if(0<=A && A<=100000000 && 0<=B && B<=100000000){

let res = A * B;
let binary = res.toString(2);

let count = 0;
binary.split('').map((v, i)=>{

if(v==='1') count++;

}); 
return count;
}
}


///



// you can write to stdout for debugging purposes, e.g.
// console.log('this is a debug message');

function solution(S) {
    // write your code in JavaScript (Node.js 8.9.4)

let v = parseInt(S, 2);

let count = x(v, 0);

return count;
}


function x(v, count){
if(v<=0){
return count;
}
let newV = v%2?v-1:v/2;

return x(newV, count+1);
}


///


// you can write to stdout for debugging purposes, e.g.
// console.log('this is a debug message');

function solution(A) {
    // write your code in JavaScript (Node.js 8.9.4)

const obj = class {
constructor(index){
this.index=index;
}
value(){
return A[this.index];
}
}

const s = {
0:new obj(0),
1:new obj(1),
length:2
};

//console.log(Array.isArray(s))
// console.log(s)
// console.log(s.length)
// console.log(s[1].value() === A[1])
// console.log(!s[1].hasOwnProperty('value'))
return s;




}


///


// you can write to stdout for debugging purposes, e.g.
// console.log('this is a debug message');

function solution(A) {
    // write your code in JavaScript (Node.js 8.9.4)


const s = {
value(){
return this.x
}

}
const x = A.map((v,i)=>{
return {
 __proto__:s,
x:v
}
});

// console.log(x[0].value());

// console.log(!x[0].hasOwnProperty('value'))

return x;


/*
const obj = class {
constructor(index){
this.index=index;
}
value(){
return A[this.index];
}
}

const s = {
0:new obj(0),
1:new obj(1),
length:2
};

*/
//console.log(Array.isArray(s))
// console.log(s)
// console.log(s.length)
// console.log(s[1].value() === A[1])
// console.log(!s[1].hasOwnProperty('value'))
// return s;




}

---
layout: post
title: Apache vs Nginx
categories: Web
---

웹서버는 HTTP 프로토콜을 통해 읽힐수 있는 문서를 처리를 하며 일반적으로 웹 어플리케이션의 앞단에 배치되곤 합니다. 동적인 리소스는 WAS에게 처리하도록 하고 정적인 리소스를 보다 효율적으로 처리하기 위한 방법일 수 있습니다. Apache와 Nginx는 현재까지 가장 폭넓게 사용되는 2가지의 오픈소스 웹서버입니다. 두가지 웹서버를 비교해 보겠습니다.

## Apache

1995년 Rober McCool에 의해 만들어졌으며, 1999년 부터 Apache Software Foundation 주도에 개발되었습니다. 웹서버 데몬의 선구자로 HTTP 웹 서버의 대명사로 Apache를 많이 떠올리는 이유도 이러한 오래된 역사에서 비롯되는 것 입니다. 가장 대중적이었고, 동적 로딩 모듈 기반 시스템을 통해 다양한 소프트웨어들과 유기적으로 결합되어 스택들을 제공해 왔습니다. 대중적인 인기를 바탕으로 여전히 가장 두터운 사용자와 경험적 지식을 제공하고 있습니다.


Apache 서버는 요청 하나 당 프로세스(또는 쓰레드)가 처리하는 구조입니다. 사용자가 많으면 스레드 생성, 메모리 및 CPU낭비가 심해집니다. 즉 요청이 많을수록 CPU와 메모리 사용이 증가하기 때문에 성능 저하가 있을 수 있습니다. 또한 Apache 서버의 프로세스가 블록킹( blocking )이 되면 요청을 처리하지 못하고, 처리가 완료 될 때까지 계속 대기하는 일이 발생합니다. Keep Alive를 이용해 해결하면 성능향상을 기대 할 수 있지만, Keep Alive 때문에 대량 접속 시 효율이 떨어집니다. 

참고) Keep Alive이란 한 번 통신이 이루어지면 접속이 끊어 버리지 않고 KeepAliveTimeOut 시간 동안 끊지 않고 다음 접속 대기하는 것. 한 번 연결된 클라이언트와 통신을 유지하고 있기 때문에, 다음 통신 시에 Connection을 생성하고 끊는 작업이 필요 없게 된다. 정적 자원( html파일, 이미지 파일 등 )으로만 구성된 웹 서버에 KeepAlive On으로 설정할 경우 약 50%의 성능 향상을 보인다고 합니다. 단 이와 같은 성능 향상을 보이려면 서버가 바쁘지 않아야 하는데, 바쁜 서버 환경에서 KeepAlive On으로 설정해 놓을 경우, 모든 요청 마다 연결을 유지해야 하기 때문에 프로세스 수가 기하급수적으로 늘어나 MaxClient값을 초과하게 됩니다. 따라서 메모리를 많이 사용하게 되며 이는 곧 성능 저하의 원인이 됩니다. (대량 접속 시 효율이 떨어짐)


### 아키텍처 (MPM:Multi Processing Module 방식)
Apache는 MPM (Multi Processing Module) 아키텍쳐를 기반으로 클라이언트 요청 처리 방법을 처리하는 기술 기반을 하고 있습니다. 프로세스 중심의 접근법이고 각 요청에 대해 새로운 스레드가 필요합니다.

MPM은 다음 3가지 아키텍쳐를 근간으로 하고 있습니다. 
- mpm_prefork: 단일 스레드 로직에서 동작하며 각 서버 프로세스는 한번에 하나의 Web Request를 처리한다. (PHP 환경)
- mpm_worker: 동시에 여러 스레드를 지원한다. 이것은 Apache가 좀 더 효율적이고 확장가능하도록 돕는다.
- mpm_event: mpm_worker와 유사한 방식으로 동작하지만 최근 등장한 웹 관련 어플리케이션들을 위한 keep-alive 메카니즘이 포함되어 있다.

이러한 방식들은 커넥션마다 새로운 스레드가 필요하다는 관점에서 커넥션이 대규모로 많아 질때 성능 측면에서 많은 이슈가 발생할 수 있습니다.

#### mpm_prefork
- 하나의 자식 프로세스가 하나의 스레드를 갖는 구조로, 자식 프로세스는 최대 1024개까지 가능합니다.
- 각 프로세스는 한번에 한 연결만 처리하고 요청량이 많아질수록 프로세스는 증가한다.
- 스레드 간 메모리 공유를 하지 않습니다. (독립적이지만 메모리를 많이 사용)
- 실행 중인 프로세스를 복제하여 실행합니다. (메모리 영역까지 복제)
- 복제시 메모리영역까지 복제되어 동작하므로 프로세스간 메모리 공유가 없어 안정적입니다.
- 응답 프로세스를 미리 띄어놓고 클라이언트 요청 시 자식 프로세스가 반응하게 되는 방식입니다.
- 디버깅이 빈약한 플랫폼에서 쉬운 디버깅이 가능합니다.
- 일반적으로 Sing CPU 또는 Dual CPU에서 성능이 더 좋습니다.

#### mpm_worker
- 1개의 프로세스가 각각 여러 쓰레드를 사용합니다.
- 스레드 간에 메모리를 공유합니다.
- 쓰레드간의 메모리를 공유하며 PreFork방식보다 메모리를 덜 사용하는 장점이 있습니다.
- Prefork 보다 메모리 사용량이 적고 통신량이 많거나 동시 접속자가 많은 사이트에 적합합니다.
- 프로세스당 스레드가 최대 64개의 스레드 처리가 가능하고 각 스레드는 한 번에 한 연결을 담당합니다.
- Worker 방식은 일반적으로 Multi CPU 시스템에서 성능이 좋습니다.

#### mpm_event
Apache 2.2까지는 Event Driven 방식을 지원하지 않았습니다. Evnet MPM 방식은 Keep Alive에 대한 고민에서 출발한 새로운 MPM 방식입니다. 이 방식은 사용자 요청과 Keep Alive한 Apache의 요청을 그대로 맺어주는 것이 아니라, 요청을 처리하는 쓰레드를 따로 두어 분산된 처리를 하는데 그 목적을 두고 있습니다.


참고) Apache 2.4 버전부터 Keep Alive에 대한 고민을 해결하는 새로운 MPM 방식인, Event MPM 방식을 지원합니다. 이 밖에 Apache 2.4 버전에서는 성능 개선을 최우선 과제로 삼고, 더불어서 캐시, 프록시 모듈, 세션 제어, 비동기 읽기 및 쓰기 지원 기능을 개선 했다고 합니다. Apache가 성능 향상에 투자를 한 이유는, 최근 웹 서버가 정적 데이터 처리를 통한 속도 향상을 노리는 프록시나 캐싱 처리용 서버로 사용하는 경향이 늘면서 속도에 매우 민감해졌기 때문입니다.


## Nginx

2002년 러시아의 lgor Sysoev가 처음으로 고안하여, 2004년 비동기식 이벤트 처리 중심의 아키텍쳐를 목표로 소개되었습니다. 2000년 대 들어서면서 프론트엔드 서비스가 웹서비스 기반으로 크게 주목 받기 시작하면서, 웹 기반의 동시 처리가 매우 중요하게 되었습니다. Nginx는 경량의 자원활용과 물리적인 하드웨어로 쉽게 확장이 가능해서 더욱 주목 받기 시작했습니다. 특히 정적인 컨텐츠들을 빠르게 처리하는데 있어서 매우 탁월한 처리가 가능해서, 동적 처리를 별도로 담당하는 소프트웨어 스택들과 연계해서 고성능 서비스를 제공하는 데 적합하다고 사용자들에게 알려져 왔습니다. 이러한 이유로 Nginx는 웹서비스 뿐만 아니라 프록시 서비스 기능에도 많이 사용되고 있습니다.

Nginx는 보안과 속도를 최적화 시키려는 노력에서 탄생한 웹서버이며, 사용이 매우 심플하고 규모가 작은 서비스이면서 정적 데이터 처리가 많은 서비스에 적합합니다. Apache 에서 지원하는 수많은 기능이 필요 없고 알려진 보안 문제들은 특별한 업데이트 없이 Nginx 자체에서 처리해주고 있습니다. Nginx는 프로그램의 흐름이 이벤트에 의해 결정이 되는 Event Driven 방식의 웹 서버입니다. 즉 요청에 대한 각 상태(state)를 정해서, event가 발생할 때마다 event를 처리합니다. 적은 수의 쓰레드로 효율적인 일 처리를 하며, 쓰레드를 적게 사용 하기 때문에 쓰레드당 할당되는 메모리도 적게 사용하는 구조입니다. 또한 쓰레드를 많이 사용하지 않기 때문에 context switching 비용이 적고, 따라서 CPU 소모도 적습니다.그러나 모듈 개발이 어려우며 다양한 모듈이 없다는 것이 단점입니다.

### 아키텍처
Nginx는 프로세스 또는 스레드라는 개념을 사용하지 않고 이벤트 개념으로 접근합니다. 단일 Nginx 작업자가 동시에 수천 개의 Web 요청을 처리할 수 있다는 의미입니다. Worker가 이벤트가 트리거 될 때 마다 새로운 요청을 빠르게 선택할 수 있는 내부 루핑 시스템을 사용하는 방식입니다. 이러한 방식은 Apache와는 다르게 이벤트가 비동기식으로 처리되기 때문에 다른 이벤트들이 순차적으로 지정해서 기다릴 필요가 없습니다. 하나의 스레드에서 여러개의 요청을 처리하므로 쓰레드를 많이 사용하지 않기 때문에 contextSwitching 비용이 적고 CPU소모도 낮습니다. 적은 수의 스레드로 효율적으로 일 처리하며, 스레드당 할당되는 메모리도 적게 사용하는 구조 입니다. 



#### Event-Drive처리 방식
Event-Driven 방식이란 요청에 대한 각 상태를 정해서 Event가 발생할 때마다 event를 처리하는 것을 말합니다. Event-Driven 처리 기반 구조는 여러 개의 커넥션을 모두 Event-Handler를 통해 비 동식 방식으로 처리해 먼저 처리되는 것부터 로직이 진행하도록 합니다. 이러한 기법의 주 사용 목적은 대화형 프로그램을 만드는 데 사용하는데 PCP 처리와 유사합니다.

Event-Drive처리 방식이므로 프로세스를 Fork하거나 스레드를 사용하는 아파치와 달리 CPU와 관계없이 모든 IO들을 Event Listener로 미루기 때문에 흐름이 끊기지 않고 응답이 빠르게 진행 되어 1개의 프로세스로 더 빠른 작업이 가능하게 될 수 있습니다. 이떄문에 메모리 측면에서 Nginx가 시스템 리소스를 적게 처리한다는 장점이 있습니다.




## 결론

Nginx 는 비동기 이벤트 기반으로 요청을 처리하고, Apache 서버는 요청 당 쓰레드 또는 프로세스가 처리하는 구조 입니다. 최근 대용량의 정적 파일 및 큰 규모의 사이트가 많아짐에 따라 대량 접속에도 적은 리소스를 사용하며 빠르게 서비스를 할 수 있는 웹 사이트가 대세가 되었는데, 이런 면에서 Nginx가 각광 받기 시작했습니다. 성능 면에서 Apache 2.2는 Nginx에 뒤쳐졌기 때문에 Nginx가 성장하게 되었습니다. 그러다가 2012년에 빠른 응답 속도와 적은 리소스 사용 부분을 개선한 Apache 2.4를 발표하면서, Nginx에 대응하기 시작 했습니다. 그럼에도 Nginx가 성능 면에서는 Apahce 2.4 보다 좋다고 합니다. (엄청 큰 차이는 아닙니다.) 하지만 PHP 모듈 등을 직접 적재할 수 있는 Apache가 구조상 이점이 있기에 복잡한 웹 사이트의 경우 Apache가 적합합니다. 세션 클러스터링 같은 특별한 목적을 추가적으로 수행하는 세팅을 할 경우에는 별도의 과정을 거쳐야 하기 때문에, 이러한 별도의 작업이 많이 필요한 서비스의 경우에도 유지 보수 측면에서 Apache가 유용합니다. 즉 안정성과 확장성, 호환성에서 Apache가 우세, 성능 면에서는 Nginx가 우세하다는 것이 결론입니다.

| Apache | Nginx |
| 프로세스 중심의 접근법| 이벤트 중심의 접근 방식 |
| 각 요청에 대해 새로운 Thread 필요| 하나의 스레드에서 여러개의 요청을 처리 |
| 요청당 쓰레드 또는 프로세스가 처리하는 구조| 비동기 이벤트 기반으로 요청 |
| 모듈이 다양함| 모듈이 다양하지 않음 |
| PHP모듈 등 직접 적재 가능| 많은 접속자들 대응 가능 |
| 안정성, 확장성, 호환성 유세| 성능 우세 |
| 전통적인 파일기반 방식의 정적 컨텐츠 | 이벤트 처리/비동기식/논블로킹 방식 처리로 인해 정적 컨텐츠 제공시 고속 처리가 가능 |
| 동적 컨텐츠는 서버 내에서 처리 |  동적 컨텐츠를 처리 하지 않는다 | 
| 리눅스, BSD, UNIX , Window | 리눅스, BSD, UNIX, Window 부분지원 |


---

해당 내용은 다음 글을 참고 하였습니다.

- https://youngmind.tistory.com/entry/Apache-vs-Nginx
- https://cntechsystems.tistory.com/24
- https://victorydntmd.tistory.com/231
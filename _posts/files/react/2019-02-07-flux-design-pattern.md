---
layout: post
title: Flux Design Pattern  
categories: React
---

Flux 디자인 패턴에 대해 설명합니다. Flux는 MVC 의 한계로 인해 등장하였습니다. 먼저 MVC패턴은 Model, View, Controller 세 가지 부분으로 이루어져 있고 기본 데이터 흐름은 다음과 같습니다.

- Model: 자료(Data)를 생성, 저장, 처리하는 역할을 하는 부분이다. 
- View: Model로부터 받은 자료를 여러 가지 형태로 사용자에게 보여주는 역할을 한다. 
- Controller: 소프트웨어의 흐름을 제어하는 것으로 View와 Model 사이에서 관계를 설정하여 주는 부분을 말한다. Controller는 Model이나 View가 바뀌더라도 수정 없이 작동되어야 한다.

뷰는 데이터를 렌더링 하기 위해 데이터를 가지고 있는 모델이 뷰로 데이터를 보내게 되는데, 이때 발생하는 문제점은 Model과 View의 관계가 복잡해지는 애플리케이션 규모가 커지는 경우, 점점 복잡해 진다는 것입니다. 복잡해 진다는 것은 결국에는 고도의 예측이나 테스트가 어려워진다는 것이고 그렇다면 소프트웨어의 품질을 담보하기가 어려워 집니다. 

부모-자식(parent-child) 관계가 아닌 컴포넌트끼리 데이터를 교류 할 때엔 `글로벌 이벤트 시스템`을 설정 하는 방법으로 Flux 디자인 패턴을 사용합니다. 가장 많이 사용되고 있는 예로는 React애플리케이션에서 사용되는 Redux가 있습니다. 조금 다르기는 하지만 Redux는 리엑트(Reaact) 애플리케이션의 효율적인 데이터 교류 및 state 관리를 쉽고 효율적으로 하기 위해 사용하는 라이브러리로서 이를 사용하면 리엑트 같은 싱글 페이지 애플리케이션(SPA: Single Page Application)에서 상태적 데이터 관리를 시간 흐름에 따라 복잡해 지지 않도록 제어 할 수 있습니다. (React 외에도, jQuery 혹은 Angular 를 사용하는 어플리케이션에서도 사용 될 수 있습니다.) Redux는 자바스크립트 앱을 위한 예측 가능한 상태 컨테이너입니다.


## Flusx Design Pattern
Flux는 애플리케이션의 복잡함을 없애기 위해서 데이터의 흐름을 단방향 운영합니다. 이런 방식은 전체적인 처리 흐름을 알기 쉽지만 Angular.js 등과 비교했을 때 상대적으로 표현이나 문법이 장황한 느낌이 있습니다. 그렇지만 데이터의 흐름을 단순하게 만드는 것으로 애플리케이션의 규모가 커져 복잡화돼도 데이터나 이벤트의 흐름이 엉키지 않고 파악하기 쉬운 구조를 유지할 수 있다고 합니다. (실제로 Flux를 사용해 대규모 애플리케이션을 구현해보지 않아서 단언할 순 없습니다)

React는 단방향으로 데이터가 흐르는 구조입니다. 부모컴포넌트에서 자식 컴포넌트로 속성을 이용해 데이터를 전달하는데 이는 애플리케이션 실행에 대한 추적을 통해 어떤 상황에서 어떤 코드가 실행되는지 쉽게 파악할 수 있다는 장점이 있지만, 최상위 컴포넌트에서 상태가 자식 컴포넌트로 계층적, 반복적으로 전달되어야 하므로 이 과정에서 코드가 복잡해지고 오류가 발생할 가능성이 높아집니다. 이러한 리액트의 단점을 보완할 수 있는 아키텍쳐가 Flux입니다. 

Flux 란? 페이스북에서 클라이언트-사이드 웹 어플리케이션을 만들기 위해 사용하는 어플리케이션 아키텍쳐로서 서론에서 이야기 했듯이 단방향 데이터 흐름을 활용해 뷰 컴포넌트를 구성하는 React를 보완할 수 있는 아키텍쳐입니다. 데이터를 상위 컴포넌트에서 하위컴포넌트로 계층적으로 전달하는 것이 아니라, dispatcher라는 채널을 통해 중앙허브로서 전달하는 방식을 취하는 것입니다. 다음과 같은 구성 요소를 가집니다.


- Dispatch : 단 하나의 디스패처. Actions로부터 전달받은 메시지(Action Type, payload)를 Store에 전달하는 단일 통신 채널이다. 즉 Flux구조의 중앙 허브로서 데이터의 흐름을 관리한다. Store의 callback이 등록되어 있으며 액션 타입과 관계없이 등록된 모든 스토어로 액션을 보낸다. 이렇게 전달받은 액션을 스토어에서 구별하여 처리할지 말지를 결정한다.
- Store : 어플리케이션의 상태와 상태를 변경하는 메서드를 보유한다. 상태변경 메서드는 상태의 불변성을 유지할 수 있도록 하는 것이 좋다. Action을 전달받으면 내부의 메서드를 이용해 상태를 변경한다. 자신을 dispatcher에 등록하고 callback을 제공한다. 이 callback은 action을 파라메터로 받는다. 여러개의 store가 존재할 수 있다.
- View : Store의 상태를 UI로 나타내고, Action을 일으킬 수 있는 환경을 제공한다.
- Action : 상태를 변경하는 기능 이외의 비즈니스 로직을 배치한다. 비즈니스 로직 실행 후의 결과를 Dispatch를 거쳐 Store로 전달하여 상태를 변경한다. 모든 Action은 타입(고유이름)과 선택적인 데이터 페이로드를 가진다. 

구성요소로는 Action, Dispatcher, Store, View 가 있습니다. 시스템에서 사용자로 부터 어떠한 Action을 받았을 때, Dispatcher가 받은 Action들을 통제하여 Store에 있는 데이터를 업데이트합니다. 그리고 변동된 데이터가 있으면 View 에 리렌더링하는 방식입니다. 그리고, View에서 Dispatcher로 Action을 보낼 수도 있습니다. Dispatcher은 작업이 중첩되지 않도록 해줍니다. 즉, 어떤 Action이 Dispatcher를 통하여 Store에 있는 데이터를 처리하고, 그 작업이 끝날 때 까지 다른 Action들을 대기시킵니다. 

중요한 점! 단방향 데이터 흐름이다!

## MVC 패턴 대체
Store는 애플리케이션의 모든 데이터를 포함합니다. Dispatcher는 MVC의 Controller를 대체하며 어떠한 Action이 발생(trigger)했을 때 어떻게 Store를 갱신할지를 결정합니다. Store가 변경될 때에는 View도 동시에 갱신됩니다. 또, 선택적으로 Dispatcher가 처리할 Action을 발생시킬 수도 있습니다. 이처럼 시스템의 컴포넌트 간 데이터 흐름은 단방향으로 유지됩니다. 데이터는 단방향으로만 흐르고 각각의 Store와 View는 서로 직접적인 영향을 주지 않기 때문에 여러 개의 Store나 View를 갖는 시스템도, 하나의 Store나 View 갖는 시스템과 같다고 볼 수 있습니다.



다음 각각의 구성 요소에 대해 알아 봅시다.

### 액션(Action)
사용자가 요청하는 변경 사항입니다.

### 액션 생성자(Action Creator)
Action을 생성해 Dispatcher에 전달합니다. 액션들을 미리 준비 하고 있습니다. 뷰로부터 사용자 입력이 들어 왔다는 것을 전달 받으면 디스페처에게 어떤 메시지를 보내야 할지 알려주면 액션 생성자는 나머지 시스템이 이해할 수 있는 포맷형식으로 바꿔주는 역할을 합니다. 액션 생성자가 액션 메시지를 생성한 뒤에는 디스패처(dispatcher) 로 해당 액션 메시지를 보내주게 됩니다. 이렇게 하나의 시스템이 모든 가능한 액션들을 알게 됨으로써 갖는 효과가 있는데, 이 액션 생성자를 통해 시스템에서 제공하는 전체 API(모든 가능한 상태변경) 를 바로 확인할 수 있다는 점입니다.

### 디스패처(Dispatcher)
Dispatcher는 Flux 아키텍처의 모든 데이터 흐름을 관리하는 중앙 허브입니다. 이는 본질적으로 Store 내에서 콜백을 등록할 때 사용하는 장소입니다. 각 Store는 Dispatcher에 등록할 콜백을 제공합니다. 이 Dispatcher가 발생시킨 Action에 응답할 때 애플리케이션 내의 모든 Store는 Dispatcher에 등록한 콜백을 통해 Action에 의해 생긴 데이터를 송신합니다.

다른 아키텍처들과는 달리 액션의 타입과는 관계없이 등록된 모든 스토어에 액션을 보냅니다. 스토어는 특정 액션만 구독(subsribe)하는 것이 아니고 모든 액션을 받은 뒤 받은 액션을 처리할지 말지를 스토어가 결정합니다. 이처럼 디스패처(dispatcher)는 액션을 보낼 필요가 있는 모든 스토어(store)가 연결되어 있으며, 액션 생성자(the action creator)가 보낸 액션 메시지를 연결된 모든 스토어에게 전달해주는 역할을 합니다. 처리 방식은 동기적 방식으로 동기적으로 처리 된다는 것은 여러 액션이 들어와도 우선순위를 가진 액션 순으로 처리하기 때문에 비동기 적인 방식처럼 순서가 뒤죽박죽 되거나 복잡한 상황이 발생하지 않는다는 것을 의미 합니다.

즉, Dispatcher는 Action을 받아 등록된 callback을 실행합니다. 


### 스토어(Store)
Store는 애플리케이션의 데이터와 비즈니스 로직을 담당합니다. 애플리케이션 내의 모든 상태(State)와 그와 관련된 로직을 가지고 있습니다. 모든 상태 변경은 스토어에서 결정됩니다. 디스패처로부터 모든 액션을 받은 스토어는 내부에서 상태 변경을 결정하기 위해 switch구문을 통해 필요한 액션을 구분하게 되고 구분되어진 액션 내용 중 상태변경에 대한 내용이 포함되어 있다면 액션에서 전닯다은 상태 변경을 진행합니다. 주의할점은, 스토어는 전달받은 액션으로 부터 데이터의 상태 변경을 "결정"만 할 뿐 자체적으로 상태를 변경할 수는 없습니다. Flux의 기본 시스템 구성이 단방향 데이터 흐름인 것과 스토어에는 상태를 설정할 수 있는 설정자(setter)가 존재하지 않는 다는 것을 알아 둡시다.

그러므로 상태 변경이 필요한 경우 변경을 요청하기 위해 반드시 처음부터 모든 정해진 절차(액션 생성자->디스패처 파이프라인->스토어)를 따라 상태 변경에 대한 액션을 보내야 합니다.

그 다음 절차로 스토어에서의 일이 모두 처리되고 나면 스토어는 변경 이벤트(change event)를 컨트롤러 뷰(the controller view)에 내보내어 상태가 변경되었다는 것을 알려줍니다. 

### 컨트롤러 뷰(Controlloer View)
스토어에서 상태가 변경되었다는 사실을 전달받은 컨트롤러 뷰는 다신 아래 있는 모든 뷰(The View)에게 새로운 상태를 넘겨주고 렌더(Rendering)혹은 리렌더(Rerendering)하라고 알려줍니다. 


### 뷰(The View)
컨트롤러 뷰에게 새로운 상태를 전달 받는 뷰는 해당 내용들를 사람들이 이해할 수 있는 포맷(HTML)으로 변경하여 보여줍니다(Rendering 혹은 ReRendering). 뷰는 애플리케이션 내부에 대해서 아는바가 없습니다. 단지 보여줄 뿐입니다.


## 동작 순서

### 준비

- 스토어(Store): 디스패처(Disptcher)에게 "액션 생성자에게 액션 메세지가 오면 알려줘" 라고 말해 둔다.
- 컨트롤러 뷰(Controller View): 스토어(Store)에게 "현재 보여줘야 하는 상태가 뭐야?"라고 물어 최신 상태에 대한 답을 받아 뷰(The View)에게 전달한다.
- 뷰(The View): 최신 상태를 받으면 렌더링(Rendering) 한다.
- 컨트롤러 뷰(Controller View): 스토어(Store)에게 "상태가 바뀌면 알려줘"라고 부탁한다. 스토어를 구독하고 있다.

### 데이터 흐름
- 뷰(The View): 사용자에게 입력이 들어오면 액션 생성자(Action Creator)에게 알려준다
- 액션 생성자(Action Creator): 준비하고 있던 액션을 포맷에 맞게 가공한 다음 디스패처(Disptcher)에게 넘겨준다. 
- 디스패처(dispatcher): 들어온 액션의 순서에 따라 액션을 스토어(store)로 보낸다. 액션을 구독하고 있다.
- 스토어(store): 모든 액션을 받고 필요한 액션 만을 골라 상태(state)를 필요에 맞게 변경한다. 스토어(store)는 자신을 구독(subscribe) 하고 있는 컨트롤러 뷰(the controller view)에게 그 사실을 알린다.
- 컨트롤러 뷰(the controller view): 스토어(store)에게 변경된 상태를 요청하고, 스토어(store)는 상태(state)를 컨트롤러 뷰(the controller view)에게 전달한다. 스토어(store)에게 새로운 상태(state)를 전달받은 컨트롤러 뷰(the controller view)는 자신 아래의 모든 뷰(the view)에게 새로운 상태(state)에 맞게 렌더링(re-rendering) 하라고 알린다.


지금까지 Flux Design Pattern에 대해서 살펴 보았습니다. 내용을 정리 해보면 다음과 같습니다.

## Flux 패턴의 핵심요소
Flux에는 4가지 핵심요소가 존재합니다: action, store, dispatcher 그리고 view. 이 요소들은 아래의 역할을 수행합니다:

Action은 type 속성과 일부 데이터가 있는 단순한 객체입니다. 예를 들어 { type : "INCREMENT", local_data: { delta : 1 } } 입니다.
Store는 응용프로그램의 state와 로직이 들어있습니다. store가 응용프로그램의 특정 도메인을 관리한다고 생각하면 됩니다. Flux의 store는 아무거나 다 저장할수있기 때문에 MVC의 Model과는 좀 다릅니다.
Dispatcher은 허브역할을 합니다. Dispatcher은 작업을 처리하고(예를들면 사용자 상태 변경) store에 등록된 콜백함수를 호출합니다. Dispatcher은 MVC의 Controller와는 다릅니다. 대개 Dispatcher은 로직이 많지 않으므로 동일한 프로젝트 내에서 여러번 사용하기도 합니다.
View는 controller-view이며, GUI MVC패턴에서도 일반적인 요소입니다. 이 요소는 store가 변경사항을 말해주면 해당 부분을 다시 렌더링합니다. 또한 View는 Dispatcher에 새로운 Action을 추가할 수도 있습니다.

## Flux와 MVC의 차이점
Flux 에선 응용프로그램의 데이터 흐름이 필수요소이며 Dispatcher에 의해 매우 엄격한 규칙으로 강제화됩니다. MVC에서는 흐름이 강제되지 않으며, MVC패턴 대부분들이 이를 다르게 구현합니다. 심지어 같은 프레임워크에서도 개발자마다 다르게 구현하기도 합니다. 

- 단방향 흐름: 모든 상태 변화는 Dispatcher에 의해 진행됩니다. store는 다른 store를 직접 변경할 수 없습니다. view와 action도 마찬가지입니다. 모든 변화는 action을 거쳐 Dispatcher에서 실행됩니다. MVC에선 양방향 흐름을 가지는 것이 매우 일반적입니다.
Store은 model이 없더라도 응용프로그램과 관련된 모든 상태를 저장 할 수 있습니다. MVC에선 객체를 모델링합니다.


## 단점
Flux도 단점이 존재합니다. Store의 코드는 상태를 삭제하지 않고는 reloading이 불가능 하다는 것입니다. Flux에서는 Store가 상태와 상태변경을 위한 로직을 전부 가지고 있기 때문에 새로운 상태변경을 위한 로직을 위해 store 객체를 핫리로딩시 상태에 저장되어 있는 값조차 날아가 버린다는 단점이 생기는 것입니다. 또한 Flux에서는 시간여행디버깅을 구현하기가 매우 복잡합니다. Redux는 이러한 Flux의 단점을 보완하기 위한 아키텍쳐입니다. 즉 Flux의 기능에 hot leloading과 Time travel debugging 을 보완한 것입니다. 

간단하게 설명하면 Redux는 상태와 상태 관리 로직을 분리하여 Reducer에서 상태관리를 하도록하고, 액션이 스토어에 전달되었을 때 기존 애플리케이션 상태를 수정하는 것이 아니라 그 상태를 복제한 뒤 복제본을 수정하여 저장함으로 위의 두가지 문제를 해결하여 Flux를 보완하게됩니다. Redux에서는 Flux에 있던 Dispatcher가 사라지고 Reducer란 개념이 등장합니다. 이야기 했듯이 Hotleloading을 위해 state와 state 변경 로직을 분리한 것이 Redux인데 store에서 action과 상태정보를 전달 받아 적절한 처리를 한 후 불변성을 유지한 채로 새로운 객체를 만들어 store로 다시 리턴해 주는 것이 Reducer의 역할입니다. Flux와 달리 Redux는 Store를 한 개만 가지며 하나의 store에서 오는 정보들을 Root Reducer가 계층구조를 따라 적절한 reducer에 보내고, 해당 reducer에서 처리를 하여 리턴합니다.

----
해당 내용은 다음 글을 참고 하였습니다.
- https://m.blog.naver.com/backsajang420/221368106022
- https://lunit.gitbook.io/redux-in-korean/
- https://dogbirdfoot.tistory.com/14
- https://m.blog.naver.com/qwerchan/221262843543
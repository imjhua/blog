---
layout: post
title: React? 
categories: React
---

React의 문서에서 React는 "지속해서 데이터가 변화하는 대규모 애플리케이션을 구축하기" 위하여 만들어졌다고 써져 있습니다. 복잡한 SPA(싱글 페이지 어플리케이션) 에서는 DOM 조작이 많이 발생합니다. 그 뜻은 그 변화를 적용하기 위해 브라우저가 많이 연산을 해야한다는 것이고 전체적인 프로세스를 비효율적으로 만듭니다. 데이터가 변할 때마다 뷰를 계속 갱신해야 하는데, 이런 컴포넌트들이 늘어날 때마다 일일히 관리를 해 주는 로직을 짜야 하는 것은 끔찍한 일이며, 코드의 유지보수성을 빠른 속도로 떨어뜨리는 원인이 됩니다. 또한, 잦은 DOM의 조작은 브라우저의 복잡한 연산을 요하고, 그만큼 느려지게 됩니다. React는 이러한 문제를 Virtual DOM을 사용하여 DOM조작에 대한 비용을 최소화 하였습니다. 뷰에 변화가 있다면, 그 변화는 실제 DOM 에 적용되기전에 가상의 Virtual DOM 에 먼저 적용시키고 그 최종적인 결과를 실제 DOM 으로 전달해줍니다. 이로써, 브라우저 내에서 발생하는 연산의 양을 줄이면서 성능이 개선되는 것입니다.


## 브라우저의 Workflow
자바스크립트 엔진은 계속해서 성능이 좋아지고 있는데, 정확히 어떤 부분 때문에 DOM 이 느려질까요? 정확히는, DOM 조작이 전체 동작을 비효율적으로 만드는게 아니라, 그 이후에 일어나는 일 때문에, 작업이 느려지는 것 입니다. 브라우저엔진은 다음과 같은 과정을 통해 렌더링이 이루어 집니다.

- 구문 분석 - HTML, CSS, JS
- 렌더링 - DOM Tree 구성 -> 렌더 트리 구성 -> 렌더트리 레이아웃 배치 -> 렌더트리 그리기

Virtual DOM 을 이해하기 위해, 브라우저의 워크플로우가 어떻게 이뤄지는지 살펴보고 DOM 조작 후 어떤일이 일어나는지 대해서 알아보겠습니다.

### DOM Tree 생성
브라우저가 HTML 을 전달받으면, 브라우저의 렌더 엔진이 이를 파싱하고 DOM 노드(Node) 로 이뤄진 트리를 만듭니다. 각 노드는 각 HTML 엘리먼트들과 연관되어있습니다.

참고) 파싱은 DOM(Document Object Model) 트리를 만드는 과정으로 일반적으로 HTML, XML 파서를 각각 가지고 있음. HTML 파서는 말 그대로 HTML 문서를 해석하는데 사용되고, XML 파서는 XML 형식을 따르는 SVG, MathML 등을 처리하는데 사용함.

### Render Tree 생성
외부 CSS 파일과 각 엘리먼트의 inline 스타일을 파싱합니다. 스타일 정보를 사용하여 DOM 트리에 따라 새로운 트리, 렌더트리를 만듭니다.

브라우저 엔진 중 하나인 Webkit에서는 노드의 스타일을 처리하는 과정을 attachment라고 합니다. DOM 트리의 모든 노드들은 'attach' 메소드가 있는데 이 메소드는 `스타일 정보를 계산`해서 객체형태로 반환합니다. 이 과정은 동기적(synchronous) 작업으로 DOM 트리에 새로운 노드가 추가되면 그 노드의 attach 메소드가 실행됩니다. 렌더 트리를 만드는 과정에선, 각 요소들의 스타일이 계산되고 또 이 계산되는 과정에서 다른 요소들의 스타일 속성들을 참조합니다.

화면에 표시하기 위한 위치와 크기 정보, 그리는 순서 등을 저장하기 위한 별도의 트리 구조입니다.

### Layout (=reflow)
렌더 트리가 다 만들어지고 나면, 레이아웃 과정을 거칩니다. 각 노드들은 스크린의 좌표가 주어지고, 정확히 어디에 나타나야 할 지 위치가 주어집니다.

### Painting (=repaint)
그 다음 작업은 렌더링 된 요소들에 색을 입히는 과정입니다. 렌더링 트리를 화면의 픽셀로 변환합니다. 트리의 각 노드들을 거쳐가면서 paint() 메소드를 호출하고 그러면 스크린에 원하는 정보가 나타나게 됩니다. 

참고) `reflow`와 `repaint`는 수정된 렌더 트리를 다시 렌더링하는 과정에서 발생하는 것으로 웹 애플리케이션의 성능을 떨어뜨리는 주된 요인입니다. 극단적인 경우, CSS 효과로 인해 Javascript 의 실행 속도가 느려질 수도 있습니다다.

DOM 을 조작했을 때 어떤 작업이 이뤄지는지 알아 보았습니다. DOM에 변화생기면, 렌더트리를 재생성하고 (그러면 모든 요소들의 스타일이 다시 계산됩니다) 레이아웃을 만들고 페인팅을 하는 과정이 다시 반복되는 것입니다.


#### 참고) Jquery는 무엇이 문제였나?
jQuery로 DOM을 업데이트 하고자 한다면, jQuery.prototype.append 와 jQuery.prototype.remove 와 같은 imperative (명령형) API를 이용해 뷰 데이터를 갱신해줘야 할 것입니다. 하지만 이런 컴포넌트들이 늘어날 때마다 일일히 관리를 해 주는 로직을 짜야 하는 것은 끔찍한 일이며, 코드의 유지보수성을 빠른 속도로 떨어뜨리는 원인이 됩니다. 

Jquery는 누구나 쉽게 DOM을 조작할 수 있도록 하는 아주 멋진 도구였습니다. 그러나 Jquery는 뭔가 구조적 대안이라기 보다는 날카로운 커터칼에 가까운 것이었습니다. 앱 전체에 무분별하게 Jquery가 난무하고 있는 코드를 본 적 있으신가요? Javascript로 간단한 계산도 못해도 Jquery는 쓴다느니, 남이 쓴 Jquery를 그냥 갖다 붙이면 된다느니 하는 말이 나오는 것이 바로 Jquery의 장점과 단점을 모두 보여준다고 할 수 있습니다. Jquery가 인기있었던 이유가 바로 이 커터칼처럼 DOM을 잘라내는 방식에 있었지만, 프론트엔드 개발의 전문성이 높아지고 대형 앱의 유지/보수가 화두가 되면서 이것이 Jquery의 한계로써 드러나게 되었습니다. 결국 위의 모든 것을 가능하게 만들어주는 것, 그리고 React의 가장 큰 특징이자 뜨거운 논쟁을 불러일으키는 대상, 그것이 바로 Virtual DOM입니다.


## Vitual DOM
DOM은 웹 개발자들의 영원한 숙제입니다. DOM은 웹의 핵심으로써, 브라우저가 화면을 그리기 위한 정보가 담겨있는 문서입니다. 웹은 원래 인터넷을 통해 공유되는 문서의 규격으로써 탄생했죠. 문제는 이 DOM을 효과적으로 다루는 것이 꽤나 힘들다는 것입니다. 그래서 DOM이 성능이 좋지 않다느니 하는 말도 나오지만 사실 DOM 자체보다는 해석 과정에 문제가 있는 경우가 대부분입니다. 브라우저별로 이 DOM을 가지고 화면을 만드는 방식이 다르기도 합니다. 이 이부분에서 Virtual DOM 이 빛을 발합니다! 만약에 뷰에 변화가 있다면, 그 변화는 실제 DOM 에 적용되기전에 가상의 DOM 에 먼저 적용시키고 그 최종적인 결과를 실제 DOM 으로 전달해줍니다. 이로써, 브라우저 내에서 발생하는 연산의 양을 줄이면서 성능이 개선되는 것 입니다. 즉, 브라우저에게 DOM을 해석하고 렌더링 하는 것은 굉장히 비싼 작업이고 Virtual DOM은 그 작업을 미리 최적화시켜줄 뿐만 아니라, 컴포넌트 단위로 묶어서 관리할 수 있게 해 줍니다.


일반적으로 dom에 접근하여 여러번의 속성 변화, 여러번의 스타일 변화를 수행하면 그에따라 여러번의 Reflow, Repaint가 발생하게 됩니다. 하지만 Virtual DOM은 이렇게 변화가 일어나 Reflow, Repaint가 필요한 것들을 한번에 묶어서 dom에 전달하게 됩니다. 따라서 처리되는 Reflow, Repaint의 규모가 커질 수는 있지만 한번만 연산을 수행하게 됩니다. 이를 통해 여러번 Reflow, Repaint를 수행하며 연산이 반복적으로 일어나는 부분이 줄어들어 성능이 개선됩니다. 돔을 쉽게 조작하고, 실제 돔을 변경하면서의 불필요한 렌더링을 최소화시킵니다.

## React
React는 지속해서 데이터가 변화하는 대규모 애플리케이션을 구축하기위한 단방향 데이터 플로우입니다. 또, 변화가 적용되는 HTML Element들을 Virtual DOM을 이용해 표현한다고 했습니다. Virtual DOM은 가상의 HTML Element들을 가지고 있다가, (재)렌더링을 하면 필요한 부분만 업데이트(DOM 조작)하는 방식입니다. Virtual DOM은 사실 그 개념을 알고 나면 React의 구현 디테일에 불과합니다만, key prop 등 차후 여러 API들과 연관이 있기 때문에 개념을 알고 있을 필요는 있습니다.

### 등장
페이스북의 글로벌 Notification 창 (지구본), 페이스북 그룹 리스트, 댓글 창, 채팅 창 같은 인터페이스들은 시간이 지날 수록 다른 사람들이 댓글을 달거나 말을 걸면 신호에 따라 서버에서 데이터를 요청해 업데이트하고, 이에 맞춰 뷰를 변경해줘야 합니다. 유지보수를 신경쓰는 개발자들은 모델 데이터를 변경하는 로직과 뷰 로직을 분리하기 위해 나만의 '뷰 데이터 관리 도구'를 어딘가에 만들어, Separation of Concern (`관심사의 분리`)을 달성하게 되어 있습니다. 그렇기 때문에 Backbone.js이나 Angular.js와 같은 라이브러리들이 자연히 등장한 것입니다.


### 데이터 흐름 (원리)
React는 Reactive한 `단방향의 데이터 흐름`을 가지고 있습니다. Reactive하다는 것은 상태(일반적인 의미에서의 state)가 바뀌면 뷰도 함께 업데이트가 된다는 것이며, 단방향이라는 것은 한 방향으로 데이터가 흐른다는 것입니다. 상태는 상위 컴포넌트 (Owner)에서 하위 컴포넌트 (Ownee)로 흐르게 되어 있는데, 이 데이터는 React에서 prop이라고 지칭되며, JSX에서는 HTML의 attribute처럼 작성됩니다.  React를 살펴 보면, 생각보다 public하게 사용할 수 있는 API는 몇 개 되지 않습니다. 왜냐하면 React에서 사용하는 치환형 언어인 JSX를 통해 어떤 형태로 뷰 데이터가 보여져야 하는지에 대해 선언적으로 기술하기 때문입니다 (복잡한 로직을 가진 뷰라면 현실적으로는 완전히 선언적인 코드를 짜기는 어렵지만, 어쨌든 '우리가 보고 싶은 결과물을 써 놓는다' 라는 점은 같습니다). 명령형 API에 익숙한 입문자들이 가장 많이 하는 실수 중 하나는, jQuery의 DOM 조작 API를 이용해 render() 함수 안에서 DOM을 조작하려고 하는 것입니다. React는 중간 과정이 아닌 결과물을 기술하는 것이기 때문에 그럴 필요가 대체로 없습니다.

이런 점들 (`관심사의 분리, 선언적인 API`)을 볼 때, React라는 라이브러리가 만들어진 건 굉장히 자연스러운 웹 프론트엔드 개발의 진화의 흐름이라고 볼 수 있습니다.


### 핵심
React 컴포넌트는 render를 다시 호출하여 새로운 결과값을 return합니다. 그런데 이 return 값은 바로 DOM에 반영되지 않습니다. 바로 브라우저에 렌더링되지 않는다는 것입니다. React안에 있는 div들은 진짜 html이 아니라 Babel에 의해 컴파일되는 JSX입니다. render함수가 return하는 것은 새로운 Virtual DOM을 만들기 위한 재료입니다. React는 새로운 return 값을 가지고 새로운 Virtual DOM을 만듭니다. 그리고 현재 브라우저에 보여지고 있는 `진짜 DOM과 비교하여 어떤 부분이 달라졌는지 찾아냅니다`. 그리고 `바뀐 부분만 진짜 DOM에 적용`합니다. 그러면 브라우저는 이 DOM을 해석하여 유저에게 새로운 화면을 보여주게 됩니다.


### 생명주기
React는 컴포넌트 `라이프사이클 훅`을 제공합니다. 컴포넌트가 마운트(Owner에서 React.CreateElement 함수 호출로 새 컴포넌트 인스턴스를 만들거나, React.render로 DOM 컨테이너 위에 Render되는 순간) 되는 순간과 언마운트되는 시점, 업데이트되는 시점 등등에 불리는 함수들을 컴포넌트 스펙 오브젝트에서 인터페이스를 구현하듯이 작성해 주면 되며, 일종의 이벤트 훅 같은 것이라고 생각하면 편할 것 같습니다. 또한 모든 React 컴포넌트들은 HTML의 인라인 이벤트 핸들러같은 onClick 등의 prop을 넘김으로서 인터랙션을 표현할 수 있습니다. 

- counstructor
- `componentWillMount`(v17 deprecated)
- render
- componentDidMount
- `componentWillReceiveProps(nextProps)`(v17 deprecated -> getDerivedStateFromProps)
- shouldComponentUpdate(nextProps, nextState)
- `componentWillUpdate`(v17 deprecated -> getSnapshotBeforeUpdate)
- render
- componentDidUpdate(prevProps, prevState)
- componentWillUnmount

참고) 변경 이유

- 초기 렌더링을 제어하는 방법이 많아져서 혼란이 됨.
- 오류 처리 인터럽트 동작시에 메모리 누수 발생할 수 있음.
- React 커뮤니티에서도 가장 혼란을 야기하는 라이프 사이클


### 컴포넌트

컴포넌트의 역할을 분리해 각각 고유한 책임을 부여함으로서 재사용성을 높이고, 디버깅을 쉽게하는데 그 목적이 있다. 컴포넌트나 state를 재활용하기 위해 HOC를 많이 사용하게 된다면 Wrapper Hell을 마주하게 된다.


#### Presentational 컴포넌트

보여주는데 초점을 맞춘 이 컴포넌트는 스타일 정보만을 가지며 화면을 그리는데만 집중한다. 이 컴포넌트는 보여주는데 집중하기 때문에 복잡한 비지니스 로직을 가지지 않으므로 state를 가질 필요가 없다. 따라서 함수형 컴포넌트(Functional Component)로 많이 구현을 한다.

#### Container 컴포넌트

비지니스 로직을 가지고 있으며, Presentational Component들을 가지고 화면을 그리는 최소한의 스타일 정보만 가지고 있다.

#### 정리

- 부작용(Side-Effect)없이 프로그래밍 하는 좋은 방법 중 하나는 커다란 코드를 작은 단위로 쪼개서 작성하는 것이다. (함수나 클래스를 사용하기도 하고, React에서는 컴포넌트라는 개념)
- 컴포넌트의 역할을 분리해 각각 고유한 책임을 부여함으로서 재사용성을 높이고, 디버깅을 쉽게하는데 그 목적이 있다.
- Component 의 가독성이 매우 높고 간단하여 쉬운 유지보수, 간편한 UI 수정 및 재사용 용이
- 모듈의 단위가 컴포넌트다. 컴포넌트 단위로 코드를 재사용 할 수 있다.
- 재사용 가능한 UI 컴포넌트. 레고블럭 조립
- 목적에 맞는 컴포넌트(레이아웃으로 컨테이너/화면구성 프레젠테이셔널)구성을 통해 관리가 용이해지고 코드 공유 및 코드 재사용 가능
- 컴포넌트당 클래스를 사용하므로 css캡슐화
- 직관적인 html jsx 마크업개발자와 협업
- Portal 컴포넌트는 논리적으로 하위 컴포넌트지만 시각적으로는 상위 컴포넌트여야 할 때 사용한다.
- React에서는 합성, Composition을 통해 컴포넌트를 재사용할 수 있다.
- Composition을 지원하는 컴포넌트의 경우 PureComponent를 사용하면 성능이 나쁠 수 있다.
- Composition을 지원하는 컴포넌트를 최적화 하고 싶으면 특수화를 적용한다.
- Uncontrolled component & Controlled Component: Uncontrolled 컴포넌트는 상태를 직접 React 에서 제어하지 않는다는 의미에서 Uncontrolled 컴포넌트로 불립니다. 상태를 받는다. Controlled Component는 상태를 밀어넣어 준다. component의 prop으로 설정하고 이를 활용


### 단점

- 라이프사이클 잘 이해하고 사용해야 함. 꼬일 수 있음.
- 스테이트 관리 잘 해야함. 스테이트 관리를 잘 해야한다. 상황에 맞게 써야지 무턱대로 사용하면 불피요한 상태를 계속 관리하게 되어 더 복잡하다.
- VIEW ONLY , VIEW 이외의 기능은 써드파티 라이브러리(Third party library, =패키지, 모듈로 불리기도함)를 이용하거나 직접 구현해야함
- IE8 이하 지원하지 않음 (IE8 이하 버전을 지원해야 할 경우 v0.14 버전을 사용 해야함)
- React는 inline-template 과 JSX 를 사용하는데, 일부 개발자들에게는 적응이 안 될 수 있음

## 정리
Javascript Web Front-End Rendering 라이브러리 중 하나입니다. 보통 Single Page Application Framework가 대부분의 기능을 포함 하고 있는 반면에 React는 대부분의 기능을 포함하고 있는 Framework가 아니라 View를 Rendering 하는 것이 주 기능이며 나머지 기타 기능들(router, ajax등등)은 서드파티 라이브러리를 추가적으로 사용해야 합니다. React를 사용하면 변경사항에 빠르게 대응하여 보여지는 View만 집중할 수 있습니다.


----
해당 내용은 다음 글을 참고 하였습니다.
- https://velopert.com/3236
- https://medium.com/@RianCommunity/react%EC%9D%98-%ED%83%84%EC%83%9D%EB%B0%B0%EA%B2%BD%EA%B3%BC-%ED%8A%B9%EC%A7%95-4190d47a28f
- http://webframeworks.kr/tutorials/react/getting-started/
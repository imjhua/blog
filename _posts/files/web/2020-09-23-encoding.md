---
layout: post
title: 인코딩? 유니코드? UTF? ASCII? (꿱)
categories: Web
---

너무나도 햇갈리기만 하는 인코딩을 정리해보자!

## 인코딩

사용자가 입력한 문자나 기호들을 컴퓨터가 이용할 수 있는 신호로 만드는 것을 말합니다.

- 인코딩(부호화): 컴퓨터가 이해할 수 있는 신호로 문자 변환(모스부호도 인코딩의 한 종류)
- 디코딩(복호화): 사용자가 이해할 수 있도록 문자 해독

참고) 컴퓨터의 기본 저장 단위는 바이트(byte)입니다. 1바이트(byte)는 8비트(bit)입니다. 1byte에는 2의 8승에 해당하는 256개의 고유한 값을 저장할 수 있다.

### 문자 집합(charaterSet)

인코딩. 즉 사용자가 입력한 문자를 컴퓨터가 이해할 수 있는 신호로 바꾸기 위해서는 숫자와 문자를 매핑해둔 테이블이 필요합니다. 이것이 문자집합 즉 케릭터셋입니다. 신호를 입력하는 인코딩과 문자를 해독하는 디코딩하기 위해선 미리 정해진 기준을 바탕으로 입력과 해독이 처리되어야 합니다.

초기 charaterSet은 아스키나 EBCDIC이 표준이었으나, 표현해야 할 문자가 많아지면서 대체방식들이 개발되었고 유니코드가 등장하였습니다.

### 문자 인코딩 형태(character encoding form, CEF)

컴퓨터가 읽어들이는 언어(보통 2진수)를 몇 바이트 단위로 끊어서 읽을지에 대한 약속을 위해 형태를 지정합니다. 문자 인코딩 형태(character encoding form, CEF)는 특정한 문자 집합 안의 문자들을 컴퓨터 시스템에서 사용할 목적으로 일정한 범위 안의 정수(코드값)들로 변환하는 방법입니다. 여기에는 유니코드 코드 포인트를 8비트 숫자의 집합으로 나타내는 UTF-8이나, 16비트 숫자의 집합으로 나타내는 UTF-16, 그리고 대부분의 일반적인 문자 인코딩들이 포함됩니다. 만약 문자인코딩과 디코딩의 형태가 맞지 않다면, 즉 꿱꿱과 같은 식별가능하나 의미없는 이상한 문자들로 보여지게 됩니다.

### 잘못된 인코딩 예

- 16진수 이스케이프 시퀀스: '\x41\x42\x43' -> 'ABC' (\x41이 U+0041이고 라틴 대문자 A가리킴)
- 유니코드 이스케이프 시퀀스: '\u0041\u0042\u0043' -> 'ABC' (ex ♡)
- 유니코드 코드포인트 이스케이프: '\u{41}\u{42}\u{43}' -> 'ABC' (중괄호 안에 16진수를 6자리까지 쓸 수있다 ex 💩)
- ASCII ↔ UTF-16: Bush hid the facts ↔ 畂桳栠摩琠敨映捡獴
- EUC-CN ↔ EUC-KR/MS949: 猫叉 Master ↔ 챔꿩Master
- EUC-KR/CP949 ↔ ISO/IEC 8859-1 또는 Windows-1252: 문자 깨짐 테스트 ↔ ¹®ÀÚ ±úÁü Å×½ºÆ®
- NFC(Windows) ↔ NFD(macOS): 똠방각하 ↔ ㄸㅗㅁㅂㅏㅇㄱㅏㄱㅎㅏ
- UTF-8 ↔ EUC-KR: 한글이 깨져요 ↔ �쒓��� 源 ⑥졇��
- URL인코딩/퍼센트 인코딩: 영문 알파벳과 숫자를 제외한 나머지 문제는 16진수로 표현하는 방식으로 웹페이지의 주소에 주로 쓰인다. 또한 알파벳과 숫자 이외의 주소를 해석하지 못하는 경우를 위해 사용
- �: 정보자체 유실

참고) js에서 URL인코딩을 위해 2가지 WebAPI를 제공한다. &또는? 문자의 인코딩 유무로 확인 할 수 있다.

- encodeURI: http get/post할 수 없다. 제외 문자열 A-Z a-z 0-9 ; , / ? : @ & = + \$ - \_ . ! ~ \* ' ( ) #
- encodeURIComponent: post요청에 사용할 수 있다. 제외문자열은 A-Z a-z 0-9 - \_ . ! ~ \* ' ( )

#### 정보 자체가 손실된 경우

텍스트 저장 과정에서 문제가 생긴 경우로, 원문을 완전히 복원해 낼 수 없다. UTF-8로 문서를 저장할 때 저장 과정에 문제가 생겨 일부 텍스트가 �(U+FFFD, REPLACEMENT CHARACTER)로 변하는 경우 등이 이에 해당됩니다.

현재 사용 중인 문자 인코딩이 처리할 수 없는 문자를 넣고 저장한 경우에도 이런 문제가 생긴다(예: 한글이 섞인 문서를 Shift_JIS로 저장한 경우). 이 경우는 보통 저장 과정에서 해당 문자가 ?나 �로 대체되므로 원문을 복원해 낼 수 없습니다.

## 아스키(ASCII)

아스키(ASCII: American Standard Code for Information Interchange) 풀네임에서 알 수 있듯이 가장 처음 1960년대 미국에서 정의한 표준화한 부호체계입니다. 여러 가지 이유로 아스키코드는 7비트 즉, 128개의 고유한 값만 사용합니다, 컴퓨터의 기본 저장 단위는 1바이트(8비트)인데, 아스키는 7비트만을 활요하며 1비트는 통신에러 검출을 위해 사용합니다.

참고) 통신 에러 검출을 위한 비트를 Parity Bit라고 한다.

### 고유값 할당

0부터 시작하여 127까지 총 128개의 고유한 값을 맵핑하고 있습니다.

- 0 ~ 32: 인쇄와 전송 제어용으로 사용되는 알 수 없는 용어들 할당
- 33 ~ 126: 숫자, 알파벳 소문자, 알파벳 대문자, 특수기호 등이 할당

## ANSI

아스키코드의 7비트로는 다른 언어를 표현하기에 부족하여 8비트로 확장한 아스키 코드가 등장하였습니다. 이를 ANSI 코드라고 합니다.

7비트에서 8비트로 확장되었으니 사람들이 활용할 수 있는 문자는 1비트가 늘어났으니 2개가 아닌! 128개 입니다. 제곱으로 연산되어야 합니다.

- 2^7: 128
- 2^8: 256

그러나 비유럽 국가 특히 한국, 중국, 일본과 같은 문자가 많은 국가에서는 여전히 제한적이었습니다. 그래서 유니코드(Unicode)라는 전 세계 언어의 문자를 정의하기 위한 국제 표준 코드가 등장하게 되었습니다.

참고) 우리나라의 경우 KSC5601 표준이라는 고유한 인코딩 방법으로 문자를 표현했다. ms 윈도우에 표준 인코딩으로 채택하였다.

## 유니코드

한글은 자음과 모음의 조합 가능 개수만 따져도 가뿐히 128개를 넘고 중국어 역시 한자의 개수가 만 개가 넘습니다. 아스키 이상의 용량을 크게 확장한 2byte (2의 16승 = 65536)의 유니코드가 등장하게 되었습니다. 유니코드 또한 각 문자에 대한 정수값이 맵핑된 정보입니다. 다양한 문자들을 위한, 영어 알파벳을 기준으로 하는 ASCII를 대체하는 목적일 뿐입니다. 유니코드를 통해 아스키의 한계를 넘어 모든 언어들의 맵핑정보를 가져 인코딩이 가능하게 되었습니다.

- UTF: Universal Coded Character Set + Transformation Format
- UTF-8
- UTF-16
- UTF-32

참고) Universal Coded Character Set는 Unicode입니다.

### UTF-8

web에서 구현되어 있는 인코딩입니다. 8-bit를 사용하여 1 ~ 4byte 표현 가능합니다. 가변 길이 문자 인코딩입니다.

- 영문 byte 수: 1byte (ASCII를 그대로 사용 / 하위호환성 / 아스키와 동일 인코딩)
- 한글 byte 수: 3byte

### UTF-16

window와 java에서 구현되어 있는 인코딩입니다. 16-bit를 사용하여 2 또는 4 byte 표현이 가능합니다.

- 영문 byte 수: 2byte
- 한글 byte 수: 2byte

### UTF-32

unix에서 구현되어 있는 인코딩입니다. 32-bit를 사용하여 4byte 표현이 가능합니다.

### UTF들의 차이

Encoding 방식의 큰 차이는 최소 8bit가 필요하다 16bit가 필요하냐에 따라 다른 것입니다. 최적의 상황(저쟝, 통신 용량을 아껴야할 때)이 필요하다면, 어떤 CodePoint를 주로 사용하냐에 따라 UTF-8 또는 UTF-16을 선택하는 기준이 달라질 것입니다.

예를 들어 영문자들로 가득찬 문서의 경우 UTF-8로 표현하면 대부분 1byte로 표현되고 UTF-16으로 표현하면 2byte로 표현되니 UTF-8이 유리하고, 한글의 경우 UTF-8은 3byte, UTF-16은 2byte로 표현되니 UTF-16이 유리합니다.

- 영문: UTF-8
- 한글: UTF-16

문서에서 많이 사용된 CodePoint들이 몇 Byte로 표현될지 고민 후 결정하면 저장, 통신 용량을 아낄 수 있습니다.

## 엔티티코드
&nbsp;? 웹서핑 중 만날 수 있는 문자입니다. &nbsp;, &copy; 처럼 앰퍼센드(&)로 시작해서 세미콜론(;)으로 끝나는 문자셋입니다. 웹이라는 환경에서만 볼 수 있는 문자이며 이를 엔티티 문자(entity code)라고 합니다. 웹페이지 상의 띄어쓰기나 유니코드로 직접 입력하기 어려운 자주 쓰는 문자들의 묶음입니다. 

## 한글 변환을 위한 코드

js에서 문자열의 byte를 체크하는 경우, 인코딩에 따라 한글의 바이트 계산이 달라질 수 있습니다.

```js
export function getByte(str: string) {
  /* 
   입력되는 문자열들을 유니코드로 변환 후, 각 문자당 byte를 계산한다. 
   - charCodeAt() 메서드는 주어진 인덱스에 대한 UTF-16 코드를 나타낸다.
   - UTF-16 형식으로 변환된 문자를 1024(2^10)로 나누어 떨어지면 2바이트
   - 그보다 작은 128(2^7)로 나누었을 때 몫이 있으면 128보다 큰 유니코드이므로 2바이트
   - 나머지 경우엔 1바이트를 할당
   하는 방식으로 비트 연산을 활용
   참고) 한글은 UTF-8 인코딩 방식에서 3byte, UTF-16 인코딩 방식 2byte로 표현된다.
   */
  return str
    .split("") // 문자열을 배열로
    .map((s) => s.charCodeAt(0)) // map으로 각 문자의 문자코드 배열을 만든다
    .reduce((prev, c) => {
      // 합을 구한다
      // 한글 3바이트(UTF-8)
      return prev + (c >> 11 ? 3 : c >> 7 ? 2 : 1);
      // 한글 2바이트(UTF-16)
      // return prev + (c === 10 ? 2 : c >> 7 ? 2 : 1);
    }, 0);
}
```

---

해당 내용은 다음 글을 참고 하였습니다.

- https://whatisthenext.tistory.com/103
- https://pickykang.tistory.com/13
- https://goodgid.github.io/Unicode-And-UTF-Encoding/

---
layout: post
title: 브라우저 렌더링
categories: Web
---

## 렌더링 과정과 이벤트 핸들러의 동작

렌더링에 필요한 다섯 가지 주요 영역이 있습니다.

- JS / CSS > 스타일 > [레이아웃] > [페인트] > [합성](Compositing)

### 렌더링 과정

렌더링이란 논리적인 문서의 표현식을 그래픽 표현식으로 변형시키는 과정입니다. 이 과정은 다음과 같이 크게 2단계를 거쳐 이뤄집니다.

- DOM 요소와 스타일에 기반을 둔 레이아웃 계산
- 계산된 요소의 화면 표현

순서는..

1. DOM트리 생성
2. 스타일 구조체 생성
3. 렌더트리 생성
4. 레이아웃 처리 -> (렌더트리가 변경되어) 리플로우
5. 페인트 -> 리페인트
6. 합성

#### 레이아웃(크기와 위치)

브라우저가 요소에 어떤 규칙을 적용할지 알게 되면 화면에서 얼마의 공간을 차지하고 어디에 배치되는지 계산하기 시작할 수 있습니다. 웹의 레이아웃 모델은 한 요소가 다른 요소에 영향을 줄 수 있음을 의미합니다. 예를 들어, <body> 요소의 너비는 일반적으로 하위 요소의 너비 등 트리의 위아래 모든 곳에 영향을 주며, 따라서 이 프로세스는 브라우저에 상당한 영향을 줄 수 있습니다.

또한 브라우저는 레이아웃 계산을 출력되는 화면의 해상도보다 높은 해상도로 처리합니다. 그래서 사용자가 화면을 확대 또는 축소했을 경우를 대비해 추가적인 계산없이 원본 크기 상태의 픽셀 좌표값과 매핑해 배율에 상관없이 올바르게 배치되게 합니다.

#### 페인트(색칠): 스타일변경시 무조건

렌더링 엔진은 요소가 어디에 표현돼야 할지 알고 있으므로 렌더 트리를 순회하면서 페인트 함수를 호출해 노드를 화면에 표현합니다. 페인트는 픽셀을 채우는 프로세스입니다. 이는 텍스트, 색, 이미지, 경계 및 그림자 등 요소의 모든 시각적 부분을 그리는 작업을 포함합니다. 그리기는 일반적으로 레이어라고 하는 다수의 표면에서 수행됩니다.

#### 합성(Compositing)

페이지의 여러 부분이 잠재적으로 여러 레이어로 그려졌기 때문에 페이지가 정확히 렌더링되려면 정확한 순서로 화면에 그려야 합니다. 실수로 한 요소가 다른 요소 위에 잘못 나타날 수 있기 때문에 이는 다른 요소와 겹치는 요소가 있는 경우에 특히 중요합니다.

참고) 브라우저 렌더링 엔진간에 가장 차이점이 두드러지는 부분은 페인팅과 합성이다. 단일 플랫폼 브라우저(Edge 및 Safari)는 멀티 플랫폼 브라우저 (Firefox 및 Chrome)와 조금 다르게 동작한다.

### CPU & GPU

브라우저의 메인 스레드가 페인트 및 합성 작업을 하는데 소비하는 시간에는 자바스크립트 또는 레이아웃을 실행될 수 없다. 자바스크립트 및 레이아웃과 같은 일을 처리하는데 CPU를 낭비하지 않도록 하기위해 GPU를 사용한다. GPU는 CPU보다 픽셀을 그리는데 더 빠르기 때문에 페인팅 속도가 빠르다. 이것은 CPU에서 GPU로 복사해야 하는 데이터가 적다는 것을 의미한다.

- CPU: (기존 또는 일부 브라우저에는 여전히) 페인팅
- GPU: 레이어 페인팅 & 합성

### 리페인트와 리플로우 발생요인

- DOM 노드의 변경: 추가, 제거 업데이트(렌더트리가 변경된다)
- DOM 노드의 노출 속성을 통한 변경: display:none은 리플로와 리페인트를 발생시키지만 비슷한 속성인 visibility:hidden은 요소가 차지한 영역을 유지해 레이아웃에 영향을 주지 않으므로 리페인트만 발생시킵니다.
- 스크립트 애니메이션: 애니메이션은 DOM 노드의 이동과 스타일 변경이 짧은 시간 내에 수차례 반복해 발생되는 작업입니다.
- 스타일: 새로운 스타일시트의 추가 등을 통한 스타일 정보 변경 또는 기존 스타일 규칙의 변경
- 사용자의 액션: 브라우저 크기 변경, 글꼴 크기 변경 등

### 렌더링과정의 생략이 가능하다면 성능이점

렌더링 과정이 생략된다는 것은 바로 브라우저가 해야 하는 일이 줄어들고, 이는 성능을 개선할 수 있음을 의미합니다. 즉, 수명 주기에서 애니메이션이나 스크롤처럼 많은 부담을 주는 시점에 가장 이상적이고 비용이 가장 적게 드는 과정을 통해 성능을 개선할 수 있습니다.

고성능 애니메이션에 빠른 트랙을 원하는 경우 컴포지터(compositor) 전용 속성을 변경하여 렌더링 과정을 최소화 할 수 있습니다.

- will-change: 앞으로 일어날 변경점들을 브라우저에게 알려주어 브라우저가 실제 요소가 변화되기 전에 적절하게 최적화한다.
- AddEventListener{passive: true}: 이벤트를 받는 컴포지터 스레드에 해당 이벤트가 메인 스레드의 처리를 기다리지 않고 바로 Composite를 수행해도 된다는 힌트를 준다.
- display: 여러 속성의 스타일을 변경하는 중간 단계에서는 화면에 표시하지 않고, 작업이 완료되고 최종 경과가 반영되는 마지막 시점에 요소를 다시 표시한다면 `(특히)리플로`와 리페인트의 발생횟수를 크게 줄일 수 있.
- node clone: 복제된 노드는 DOM 트리에 추가된 상태가 아니므로 렌더링 성능에 영향을 줄 수 있는 작업을 실행하더라도 리플로나 리페인트가 발생하지 않는다.

참고) https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count?hl=ko

#### JS / CSS > 스타일 > 페인트 > 합성

페이지의 레이아웃에 영향을 주지 않는 배경 이미지, 텍스트 색상 또는 그림자 등의 'paint only' 속성을 변경하면, 브라우저가 레이아웃을 건너뛰되 페인트 작업은 여전히 수행합니다.

#### JS / CSS > 스타일 > 합성

레이아웃과 페인트가 필요 없는 속성을 변경하면 브라우저가 합성 단계로 건너뜁니다.

---

해당 내용은 다음 글을 참고 하였습니다.

- https://12bme.tistory.com/140
- https://developers.google.com/web/fundamentals/performance/rendering?hl=ko#1_js_css_%EC%8A%A4%ED%83%80%EC%9D%BC_%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83_%ED%8E%98%EC%9D%B8%ED%8A%B8_%ED%95%A9%EC%84%B1
- https://ui.toast.com/weekly-pick/ko_20171016/

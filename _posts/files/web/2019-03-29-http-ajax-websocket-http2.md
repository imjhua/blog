---
layout: post
title: 웹에서의 서버와 클라이언트 통신 (HTTP/Ajax/WebSocket/Http2)
categories: Web
---

웹(www)에서 서버와 통신할 수 있는 다양한 방법들이 있습니다. 그중 웹에서 시각적으로, 정보의 양으로 멋진 문서를 주고 받을 수 있도록 등장한 HTTP부터 HTTP의 제약을 조금은 해결한 Ajax, 그리고 HTTP와 Ajax의 제약에서 벗어나 새로운 해결책이 된 WebSocket에 대해 알아 보겠습니다.
- HTTP는 통신 제약이 있는 약속입니다.
- AJAX로 HTTP의 통신 제약으로부터 조금 벗어날 수 있었습니다.
- Websocket은 HTTP의 통신 제약을 해결한 새로운 약속입니다.

## HTTP(Hyper Text Transfer Protocol)
1989년 팀 버너스리로 부터 HTTP 통신규약이 등장하였습니다. 이전에는 없던 텍스트 문서를, 교환하기 위하여 사용된 프로토콜입니다. HTTP는 클라이언트와 서버 사이에 이루어지는 요청/응답(request/response) 약속입니다. 사용자는 HTTP를 통해 텍스트 및 그림 정보를 서버로 부터 전달받을 수 있습니다. HTTP를 통해 전달되는 자료는 http:로 시작하는 URL(인터넷 주소)로 조회할 수 있습니다. HTTP가 등장하기 이전에는 터미널에서 텍스트를 주고 받았습니다. 터미털에서 벗어 날 수 있었지만 제약사항이 존재 하였으니, 그것은 요청이 있어야만 서버가 해당 요청에 응답한다는 것입니다. HTTP의 대전제는 "URL 및 부가정보를 통해 사용자가 원하는 페이지를 서버에 요청한다, 그리고 서버는 해당 요청에 응답한다" 인 것입니다. 따라서 "사용자는 서버로부터 새로운 정보를 받아보기 위해서, 반드시, 새로운 URL을 요청해야 한다"는 것을 의미합니다.

즉, 브라우저가 웹서버에 무엇인가를 요청하려면, 페이지를 이동해야만 하는 것입니다. 그렇게 웹페이지를 이동하는 방식으로 만들어버리면 시각적으로 너무 번거롭고 불편하기 때문에 상호작용을 위한 다양한 꼼수 기술? 플래시(플렉스), 자바애플릿(자바FX), ActiveX , 실버라이트 등이 등장하였습니다.

## Ajax(Asynchronous JavaScript and XML)
Ajax는 Http의 "사용자는 서버로부터 새로운 정보를 받아보기 위해서, 반드시, 새로운 URL을 요청해야 한다"는 제약을 벗어나기 위해 등장하였습다. 전에도 이미 존재하던 기술이었지만 2000년도 중반 이후로 인기를 끌기 시작했습니다. 구글은 2004년에 G메일, 2005년에 구글 지도 등의 웹 애플리케이션을 만들기 위해 비동기식 통신으로 사용했고 Ajax라는 용어는 공식적으로 구글이 Google pages 에서 사용한 기술에 기반하여 등장하였습니다. 

사용자가 Ajax를 사용하여 서버에 요청하면(이때 사용자는 XMLHttpRequest 객체를 통해 서버에 요청) 서버는 요청에 대한 처리의 결과로서 Html을 전송하는 것이 아닌 XML, Text 혹은 JSON을 XMLHttpRequest 객체에 전송합니다. 그러면, Javascript가 해당 응답 정보를 DOM에 적용하여 기존에 있던 Html을 업데이트 합니다. 즉, Json이나 xml형태로 필요한 데이터만 주고 받으며 DOM을 갱신하기 때문에 그만큼의 자원과 시간을 아낄 수 있게 되었고, Html의 부분만을 바꿀수 있게 되면서 요청에 대한 Html을 서버로부터 받기 위해 페이지 이동이 발생하지 않게 되었습니다. 따라서 Ajax를 통해 비동기적인 웹 애플리케이션의 제작이 가능합니다. 

Ajax에도 제약사항이 존재하는데 지연시간이 짧아야 하는 실시간성 응용 프로그램에서는 Http 오버헤드가 존재한다는 점입니다. 또한 여전히 HTTP로 서버와 통신하기 때문에 HTTP의 한계를 완전히 벗어나지 못했습니다. 여전히 클라이언트의 요청이 있고 그 다음 서버로부터 응답을 받는 상황을 벗어나지 못하였습니다. 

Http와 Ajax의 비교 포인트

| 내용 | Http | Ajax |
|:----|:-----|:-----|
| 목적 | 문서 공유 | 상호작용 | 
| 요청시 페이지 변경 범위 | 전체 | 일부분 |
| 서버 요청 주체 | 웹브라우저 | XMLHttpRequest 객체 |
| 페이지 이동 | 항상 | 필요시마다 |



## WebSocket
WebSocket은 컴퓨터 네트워크용 통신 규약(protocol)의 하나입니다. 인터넷의 표준화 단체인 W3C(World Wide Web Consortium)와 IETF가 웹서버(Web server)와 웹브라우저(Web browser) 간의 통신을 위한 규정을 정의한 쌍방향통신(Duplex)용 기술 규약으로써, API는 W3C가 책정을 맡고 있고, WebSocket 프로토콜(Protocol)은 IETF가 책정을 맡고 있습니다.

HTTP프로토콜은 인터넷 역사상 가장 성공적인 프로토콜이지만 연결을 유지하지 않는 특성으로 인해 효율에 문제를 가지고 있습니다. 하나의 요청을 보내려면 연결을 맺고 요청을 보낸 후 응답을 받고 연결을 끊는 방식으로 동작합니다. 10번의 요청을 보내려면 10번의 연결을 맺고 끊는 과정이 필요하며 모든 요청에 헤더 파일이 중복적으로 들어가기 때문에 낭비가 생길 수 밖에 없는 것입니다. 이러한 문제들을 해결하기 위해 html5에는 websocket protocol이 추가 되었습니다. 웹소켓은 http를 기반으로 하지만 http프로토콜과는 전혀 다른 프로토콜입니다. http를 기반으로 한다는 것의 의미는 웹소켓 연결을 맺는 과정에 http가 개입한다는 의미로 handshake과정이 성공적으로 끝나면 http를 웹소켓 프로토콜로 바꾸는 protocol switching 과정을 진행합니다. 이제 웹소켓을 위한 새로운 소켓이 만들어지고, 이 소켓을 이용해서 통신을 합니다. 웹소켓은 최초 접속을 제외 하고는 헤더 정보를 보내지 않기 때문에 네트워크 비용 측면에서 훨씬 이득이 되며 양방향 통신(full-duplex)통신을 하기 때문에 대기 없이 빠르게 구현 할 수 있습니다. 데이터의 구조는 텍스트와 바이너리 모두 양방향 통신이 가능하며 텍스트의 경우 시작 바이트가 0x00 끝 바이트가 0xFF로 끝나며 UTF-8데이터를 포함할 수 있습니다.  

웹소켓에서는 서버와 브라우저 사이에 양방향 통신이 가능합니다. 웹소켓을 통해 HTTP에서 원리적으로 해결할 수 없었던 "클라이언트의 요청이 없음에도, 그 다음 서버로부터 응답을 받는 상황"을 해결하게 되었습니다. 브라우저가 서버에 데이터를 요청하고 서버가 브라우저에 데이터를 보내기 위해 별다른 제약이 없게 된 것입니다. 브라우저는 서버가 직접 보내는 데이터를 받아들일 수 있고, 사용자가 다른 웹사이트로 이동하지 않아도 최신 데이터가 적용된 웹을 볼 수 있게 되었습니다. 웹소켓을 통해 서버와 브라우저간의 실시간 소통이 가능하게 되었습다. 클라이언트와 서버 사이에 지속적인 연결이 설정되며 양측은 언제든지 데이터를 보낼 수 있습니다. 웹소켓을 적용하기 위해서는 서버측에서도 코드 구현이 들어가야 합니다.

WebSocket 소켓이 필요한 다섯가지 경우는 다음과 같습니다.
- 실시간 양방향 데이터 통신이 필요한 경우
- 많은 수의 동시 접속자를 수용해야 하는 경우
- 브라우저에서 TCP 기반의 통신으로 확장해야 하는 경우
- 개발자에게 사용하기 쉬운 API가 필요할 경우
- 클라우드 환경이나 웹을 넘어 SOA(Service Oriented Architecture)로 확장해야 하는 경우

 
## Http/2
동사, 상태 코드 및 대부분의 머리글은 현재와 동일하게 유지되지만 HTTP/2는 데이터가 전송되는 방식의 효율성을 향상시키는 목적으로 등장하였습니다. HTTP/2는 모든 HTTP대체하는 것이 아닙니다. HTTP/2는 스트리밍 기술의 필요성을 해결책으로 나온것이 아니라는 뜻 입니다. HTTP/2는 Server Push를 도입하여 서버가 클라이언트 캐시에 리소스를 사전에 전송할 수 있는 규약입니다. 그러나 데이터를 클라이언트 응용 프로그램 자체로 푸시할 수는 없습니다. 서버 푸시는 브라우저에서만 처리되며 응용 프로그램 코드에서 나타나지 않습니다다. 즉, 응용 프로그램이 해당 이벤트에 대한 알림을 가져올 API가 없습니다. 

따라서 SSE(Server-Sent Events, 서버전송이벤트)가 매우 유용합니다. SSE는 클라이언트-서버 연결이 설정되면 서버가 클라이언트에 비동기적으로 데이터를 푸시 할 수 있게하는 메커니즘을 제공합니다. 그런 다음 서버는 새로운 데이터 덩어리가 사용 가능할 때마다 데이터를 전송하도록 할 수 있습니다(단방향 게시-구독 모델과 비슷함). 




----
해당 내용은 다음 글을 참고 하였습니다.
- https://www.slideshare.net/hiscale/111015-html5-1
- https://medium.com/@chullino/
- http%EC%97%90%EC%84%9C%EB%B6%80%ED%84%B0-websocket%EA%B9%8C%EC%A7%80-94df91988788
- https://cyberx.tistory.com/28?category=195624
---
layout: post
title: 객체지향 설계 (SOLID)
categories: Programming
---

객체지향 프로그래밍을 하기 위해 반드시 알아야만 하는 중요한 원칙들이 있습니다. 객체지향을 올바르게 설계할 수 있는 원칙들에 대해 알아봅니다.

## 객체지향 기초

먼저 객체지향의 추상화, 캡슐화, 다형성, 상속의 4가지 특징을 가집니다. 객체 지향 프로그래밍은 자료 추상화를 기초로 하여 상속, 다형 개념, 동적 바인딩이 시스템의 복잡성을 제어하기 위해 서로 맞물려 기능하는 것입니다.

### 캡슐화

비슷한 역할을 하는 속성과 메소드들을 하나의 클래스로 모은것을 캡슐화라고 합니다. 캡슐화에 속한 개념으로 정보 은닉이라는것이 있는데, 캡슐 내부의 로직이나 변수들을 감추고 외부에는 기능(api)만을 제공하는것을 의미한다.

- 데이터 구조와 데이터를 다루는 방법들을 결합 시켜 묶는 것

### 상속

상속이란 클래스를 재사용 하는 것입니다. 상위 클래스를 하위 클래스에서 상속 받게 되면 상위 클래스의 멤버변수나 메소드를 그대로 물려 받을 수 있습니다. 상속이 있기 때문에 코드를 재활용할 수 있고 그렇기 때문에 생산성이 높고 유지보수 하기가 좋습니다.

- 상위 개념의 특징을 하위 개념이 물려받는 것

### 추상화

추상화라는것은, 어떤 실체로부터 공통적인 부분이나 관심 있는 특성들만 한곳에 모은것을 의미합니다. 예를들어, 지구를 본따 만든 지구본을 예로 들 수 있습니다. 지구본은 실제 지구로 부터 관심 있는 특성들(대륙의 위치, 위도,경도)만 뽑아서 만든것입니다. 지구를 추상화해서 지구본을 만들었다고 할 수 있습니다. 객체지향에서의 추상화는 어떤 하위클래스들에 존재하는 공통적인 메소드를 인터페이스로 정의하는것을 예로 들 수 있습니다.

- 공통의 속성이나 기능을 묶어 이름을 붙이는 것

### 다형성

다형성은, 같은 모양의 함수가 상황에 따라 다르게 동작 하는것을 의미한다. 오버로딩과 오버라이딩이 있는데, 오버로딩이란것은 함수의 이름은 같으나 함수의 매개변수 숫자, 타입등을 달리해서 다르게 사용하는것을 의미하고, 오버라이딩은 상위 클래스의 메소드를 하위 클래스에서 똑같은 이름으로 재정의 하는것을 의미합니다.

- 부모클레스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용되는 것

## 객체지향의 원칙

아무리 객체 지향 4대 특성인 캡슐화, 상속, 추상화, 다형성을 잘 한다고 해서 설계를 잘하는 것은 아닙니다. 4대 특성을 잘 살릴수록 좋은 설계가 되는 것입니다.

객체지향 설계에는 다음과 같은 원칙이 있습니다.

- 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다.
- 바뀌는 부분을 캡슐화한다.
- 상속보다는 구성을 활용한다.
- 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
- 서로 상호작용을 하는 객체사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.
- 클래스는 확장에 대해서는 열려있어야 하지만, 코드 변경에 대해서는 닫혀 있어야 한다.
- 추상화된 것에 의존하라. 구상 클래스에 의존하지 않는다.
- 최소 지식의 원칙: 친한친구들하고만 이야기한다.
- 먼저 연락하지 마세요. 저희가 연락 드리겠습니다.
- 클래스를 바꾸는 이유는 한 가지 뿐이어야 한다.

## 객체 지향 설계 5대 원칙

- SRP (Single Responsibility Principle) 단일 책임 원칙
- OCP (Open Closed Principle) 개방 폐쇄 원칙
- LSP (Liskov Substitution Principle) 리스코프 치환 원칙
- ISP (Interface Segregation Principle) 인터페이스 분리 원칙
- DIP (Dependency Inversion Principle) 의존 역전 원칙

## 정리

좋은 소프트웨어는 응집도가 높고 결합도가 낮습니다. SOLID 원칙들은 결국 자기 자신 클래스 안에 응집도는 내부적으로 높이고, 타 클래스들 간 결합도는 낮추는 High Cohesion-Loose Coupling 원칙을 객체 지향의 관점에서 도입한 것입니다.

- 모듈 또는 클래스 당 하나의 책임을 주어 더욱더 독립된 모듈(클래스)을 만들수 있습니다.
- 이렇게 설계된 소프트웨어는 재 사용이 많아집니다.
- 수정이 최소화 되기 때문에 결국 유지 보수가 용이해집니다.

---

해당 내용은 다음 글을 참고 하였습니다.

- https://88240.tistory.com/228
- https://ologist.tistory.com/266
- https://limkydev.tistory.com/77

---
layout: post
title: React Virtaul Dom
categories: React
---


반응 형 프로그래밍의 가장 중요한 두 가지 아이디어는 시스템이 이벤트 중심이며 상태 변화에 반응해야한다는 것입니다. 그런데, 이런 상태 변화가 생길 때 DOM(Document Object Model)을 직접 업데이트 하는 것인 무척이나 비효율적이고 느립니다. DOM조작에 대한 문제를 해결하기 위해 UI라이브러리인 React에서는 VirtualDOM을 사용합니다. 직접 DOM을 조작하는 것과 VirtaulDOM을 조작하는 것에 대한 차이를 알아보겠습니다.


## DOM조작과 브라우저 업데이트의 문제
성능저하로 인한 페이지 속도 지연등이 발생하는 이유에는 실제로 DOM을 조작하는 것 보다 브라우저 내부적으로 변경된 DOM을 업데이트 하는데 더 많은 문제가 있습니다. DOM을 조작하는데 있어 브라우저 내부적으로는 많은 일들이 일어 나기 때문입니다. 마찬가지로 Javascript엔진은 빠르지만 DOM에서 읽고 쓰는 속도가 느리다고 생각할 수 있지만 실제로 느린것은 DOM이 아닌, DOM이 변경 될 때마다 브라우저가 수행해야 하는 레이아웃입니다. DOM이 변경 될 때마다 브라우저는 CSS를 다시 계산하고 레이아웃을 수행하고 웹 페이지를 다시 페인트해야합니다. 시간이 걸리는 것입니다. DOM은 동적 UI에 최적화 되어 있지 않습니다. 

### 브라우저 작동 방식
DOM의 사용자 인터페이스 구성 요소는 내부 상태를 가지고 있으며 브라우저를 업데이트하는 것은 무언가가 변경 될 때마다 DOM을 재생성하는 것만 큼 간단하지 않습니다. 예를 들어 Gmail에서이 작업을 수행 한 경우, 작성중인 이메일을 지우고 새 메시지를 표시하기 위해 전체 브라우저 창을 새로 고칠 때 끊임없이 짜증이 날 것입니다.

브라우저는 다음과 같은 순서를 거쳐 DOM을 화면에 보여줍니다.

- DOM Tree 생성: 브라우저가 HTML 을 전달받으면, 브라우저의 렌더 엔진이 이를 파싱하고 DOM 노드(Node) 로 이뤄진 트리를 만들어요. 각 노드는 각 HTML 엘리먼트들과 연관되어 있다.
- Render Tree 생성: 외부 CSS 파일과 각 엘리먼트의 inline 스타일을 파싱해요. 스타일 정보를 사용하여 DOM 트리에 따라 새로운 트리, 렌더트리를 만든다.
- Render Tree 생성: attachment(webkit용어) 스타일 정보를 계산해서 객체형태로 반환. 동기적(synchronous) 작업으로 DOM 트리에 새로운 노드가 추가되면 그 노드의 attach 메소드가 실행된다. 렌더 트리를 만드는 과정에선, 각 요소들의 스타일이 계산되며 이 계산되는 과정에서 다른 요소들의 스타일 속성들을 참조한다.
- Layout (reflow 라고도 불립니다): 렌더 트리가 다 만들어지고 나면, 레이아웃 과정을 거치는데 각 노드들은 스크린의 좌표가 주어지고, 정확히 어디에 나타나야 할 지 위치가 주어진다.
- Painting: 위치가 정해진 후 렌더링 된 요소들에 색을 입히는 과정을 거친다. 트리의 각 노드들을 거쳐가면서 paint() 메소드를 호출. 이후에 스크린에 원하는 정보가 나타남


브라우저 제조업체는 화면을 다시 그리는 데 걸리는 시간을 단축하기 위해 지속적으로 노력하고 있습니다. 수행 할 수있는 가장 큰 일은 다시 그리기가 필요한 DOM 변경을 최소화하고 일괄 처리하는 것입니다.

정리하자면, 다음 과정이 계속 반복됩니다.
1. DOM에 변화가 생긴다.
2. 렌더트리를 재생성한다.(그러면 모든 요소들의 스타일이 다시 계산됩니다)
3. 레이아웃을 만든다.
4. 페인팅을 한다.


## 바인딩
### 양방향 바인딩
UI 라이브러리는 이러한 변경이 발생할 때 데이터 모델에 대한 변경 사항을 관찰하고 DOM의 올바른 부분을 업데이트하거나, DOM에서 변경 사항을 관찰하고 데이터 모델이 업데이트 될 때, 이를 업데이트합니다. 이러한 유형의 감시 및 업데이트를 양방향 바인딩이라고하며 사용자 인터페이스 작업을 매우 복잡하고 혼란스럽게 만들 수 있습니다.

### 단방향 바인딩
양방향 바인딩으로 인한 복잡한 문제에서 벗어나기 위해 React 는 단방향 데이터 바인딩을 사용합니다. React는 단방향 데이터 바인딩을 사용하여 작업을 단순화합니다. 예를 들어 React UI의 입력 필드에 입력 할 때마다 해당 구성 요소의 상태가 직접 변경되지 않습니다. 대신 데이터 모델이 업데이트되어 UI가 업데이트되고 필드에 입력 한 텍스트가 필드에 나타납니다.

## Virtaul DOM
복잡한 SPA(싱글 페이지 어플리케이션) 에서는 DOM 조작이 많이 발생합니다. 그만큼 변화에 적용되기 위해서는 브라우저가 많이 연산을 해야하고 전체적인 프로세스를 비효율적으로 만들게 됩니다. 이를 효율적으로 개선하기 위하여 VirtaulDOM의 역할이 주어지게 되는데, 실제 변화가 DOM에 적용되기 전에 가상의 DOM에 먼저 적용시키고 그 최종적인 결과를 실제 DOM으로 전달하는 것입니다. 브라우저 내에서 발생하는 연산의 양을 줄이면서 성능이 개선되는 것 입니다. 다른 추상화 수준으로 취해진 DOM 변경을 줄이고 배치하는이 전략은 React의 Virtual DOM의 기본 개념입니다. DOM API를 직접 사용하지 않고 virtualDOM객체를 메모리에 두고 처리하기 때문에 훨씬 빠릅니다. 즉, React 앱에서 기본 데이터가 변경 될 때마다 사용자 인터페이스의 새로운 가상 DOM 표현이 작성됩니다.


### Virtaul DOM의 동작
Virtual DOM 트리는 렌더링도 되지 않기 때문에 연산 비용이 적고 연산이 끝나고나면 그 최종적인 변화를 실제 DOM 에 `딱 한번만` 던져줍니다. 모든 변화를 하나로 묶어서 딱 한번만! 그러면, 레이아웃 계산과 리렌더링의 규모는 커지겠지만 하나로 묶어서 적용시키는것이, 연산의 횟수를 줄이게 되고 이 연산의 횟수는 레아이웃 계산과 리렌더링의 비용보다 훨씬 고 비용이기 때문에, 결론적으로는 효율적인 성능을 만들어 냅니다.

React에 사용되는 Virtual DOM은 어떻게 동작할까요? 실제 DOM과 마찬가지로 가상 DOM은 요소와 해당 속성 및 내용을 객체 및 속성으로 나열하는 노드 트리입니다. React의 render () 메소드는 React 컴포넌트에서 노드 트리를 작성하고 조치로 인한 데이터 모델의 돌연변이에 대한 응답으로이 트리를 업데이트합니다.

React에서 사용하는 VirtaulDOM을 사용한 브라우저의 DOM 업데이트는 다음 3가지 단계를 가집니다.

1. 변경 사항이있을 때마다 전체 UI가 가상 DOM 표현으로 다시 렌더링됩니다.
2. 이전 가상 DOM 표현과 새로운 가상 DOM 표현의 차이가 계산됩니다.
3. 실제 DOM은 실제로 변경된 내용으로 업데이트됩니다. 이것은 패치를 적용하는 것과 매우 유사합니다.


### Virtaul DOM의 렌더링
React가 두 개의 가상 DOM 트리를 메모리에 유지한다는 사실은 말할 것도없고, 무언가 변경 될 가능성이있을 때마다 전체 Virtual DOM을 다시 렌더링한다고 생각할 것입니다. UI가 원하는 모양을 보이도록 코드를 작성하면 Virtual DOM은 그 모양과 현재 모양의 차이점을 해결하고 업데이트해야 할 내용 만 업데이트합니다. React는 문서의 요소에 속성을 첨부하고 diff를 수행 한 후 업데이트가 필요한 항목을 결정한 후 (이러한 특정 ID 속성을 사용하여) 개별적으로 조작하여이 마법을 수행합니다. Virtual DOM은 프로세스에 추가 단계를 삽입하지만 실제 사용되는 방법이나 업데이트해야 할 사항 및시기에 대해 걱정할 필요없이 브라우저 창을 최소한으로 업데이트하는 우아한 방법을 만듭니다. 이것이 바로 자식들이 엘리먼트를 식별할 수 있는 Key값을 가져야 하는 이유 입니다. 


### 재조정(Reconcilication)
최초에 한번 렌더링을 한 후, 리렌더링시에는 reconcilication(또는 diffing) 알고리즘에 의해 노드 트리의 어느 부분이 갱신되어야 하는지, 그리고 어떤 부분은 손대지 말아야 하는기 결정이 내려지게 됩니다. 따라서 React는 갱신이 될 때마다 매번 무엇이 바뀌었는지를 걱정할 필요가 없습니다. 

갱신이 일어나는 경우는 크게 4가지로 생각해 볼 수 있습니다.
초기 데이터: type(div). props('prop')
- type(div). props('prop') 변경 없음
- type(div). props('props') props만 변경됨
- type(span). props('prop') type만 변경됨
- type(Component). props('props') type이 컴포넌트임.

#### type(div). props('prop') 변경 없음
DOM은 동일하게 유지

#### type(div). props('props') props만 변경됨
type이 여전히 HTML 요소를 가르키고 있으므로, React는 DOM 트리에서 노드 제거 없이 표준 DOM API 호출을 통해 프로퍼티를 바꾸는 방법을 사용.

#### type(span). props('prop') type만 변경됨
요소 타입이 달라졌다는 것을 React가 알게 되었기 때문에, 노드를 업데이트 하려는 시도조차 하지 않고, 예전 요소는 모든 자식과 함께 제거(unmounted)가 됩니다. 그렇기 때문에 완전히 다른 요소로 DOM 트리 저 높은 곳의 노드를 갈아 끼우는 일은 치루는 데 비용이 꽤 들어갈 수 있습니다. 다행이게도 실제 업무 중엔 아주 드물게 일어나는 케이스에 속합니다.

#### type(Component). props('props') type이 컴포넌트임.
만약 type에 함수나 클래스의 참조(즉, 여러분이 만든 일반 React 컴포넌트)가 들어가있고, 트리 reconciliation 과정이 시작되었다면, React는 언제나 컴포넌트 내부를 조사해서 render로 반환된 값이 바뀌지 않았나 (일종의 부수 효과 예방 차원에서) 확인합니다. 확인이 끝나면 흘려보내고 트리 구조상 하위에 위치한 컴포넌트도 모두 확인합니다. 이 과정에는 복잡한 렌더링도 포함되어 있는데 이 렌더링 자체도 비용이 많이 들어갈 가능성이 있습니다. (컴포넌트의 render 메소드(클래스 컴포넌트에서만 이 메소드가 직접적으로 정의됩니다)는 ReactDOM.render 메소드와 같은 것이 아닙니다. React 세계에서 render라는 단어는 사실 조금 과도하게 사용되고 있습니다.)

여기서 중요한점은 컴포넌트내 상태 혹은 프로퍼티의 변경이 생기는 경우, 페이지 전체가 아닌 컴포넌트 자기 자신과 자식들만 다시 렌더링된다는 점입니다. 그 컴포넌트의 부모와 자손뻘 컴포넌트에는 아무런 영향이 없습니다. 트리 규모가 크고 부분적으로만 다시 렌더링하고 싶을 때 유용하게 작용합니다.


#### 자식들의 리렌더링
자식들이 엘리먼트를 식별할 수 있는 Key값을 가져야 한다고 하였습니다. "diff 비교" 과정이 진행되고 있는 와중에 React가 props.children에 배열이 하나라도 들어있는 것을 보게 된다면, 그때부터 React는 배열 안에 들어있는 요소를 전에 본 것과 비교하기 시작합니다. 배열 요소는 순서대로 비교하는데, 인덱스 0에 위치한 요소끼리, 그리고 1에 위치한 것끼리 비교하는 식입니다. 

예를들어, React를 사용하지 않는 경우 테이블 행이 1000개 있는데 여기서 첫번째 행을 제거한다고 할 때 React가 나머지 999개의 자식을 업데이트해야 하는 상황이 옵니다. 인덱스가 같은 요소끼리 비교하게 된다면 같은 내용을 가지는 요소가 하나도 없을 것이기 때문입니다. 다행이게도 이런 문제를 해결하기 위한 해결책이 React 안에 내장되어 있습니다. 만약 요소가 key 프로퍼티를 가지고 있으면 인덱스가 아니라 key 프로퍼티가 같은 것들끼리 비교가 진행됩니다. key 값이 유일한 이상 React는 이 요소들을 DOM 트리에서 제거 후에 다시 올려 놓는 과정 없이 그냥 옮기기만 합니다. (React에서 마운팅/언마운팅이라고 불리는 과정입니다.)


## 정리
React의 VirtaulDOM 을 사용하면, DOM을 조작하는 것과 브라우저에 DOM 을 반영하는데 있어 효율을 낼 수 있습니다. 실제 DOM VirtualDOM에 먼저 변경작업을 하므로써 변경된 부분만 찾아 실제 DOM에 변경해 주는 방식을 사용하여, 기존 VIEW 방식보다 많은 양의 연산을 줄이게 되어 SPA에서는 성능을 개선하는데 효과적이라 할 수 있습니다.

----
해당 내용은 다음 글을 참고 하였습니다.
- https://www.accelebrate.com/blog/the-real-benefits-of-the-virtual-dom-in-react-js/
- https://velopert.com/3236
- https://www.holaxprogramming.com/2018/04/15/react-optimizing-virtual-dom-explained/
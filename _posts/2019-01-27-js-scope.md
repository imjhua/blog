---
layout: post
title:  Scope의 이해 (var / let)
categories: JavaScript
---

스코프(Scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적인 개념으로 확실한 이해가 필요합니다. 스코프는 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙입니다. 자바스크립트는 이 규칙대로 식별자를 찾게 됩니다. 프로그래밍은 변수를 선언하고 값을 할당하며 변수를 참조하는 기본적인 기능을 제공하며 이것으로 프로그램의 상태를 관리합니다, 변수는 전역 또는 코드 블록이나 함수 내에 선언하며 코드블록이나 함수는 중첩될 수 있습니다. `식별자는 자신이 어디에서 선언됐는지에 의해 자신이 유효한 범위를 갖게됩니다.`


```js
var x = 'global';

function foo () {
  var x = 'function scope';
  console.log(x);
}

foo(); // ?
console.log(x); // ?
```



## 스코프
변수는 선언 위치(전역 또는 지역)에 의해 스코프를 가지게 됩니다. 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역(자바스크립트의 경우 함수 내부)에서 선언된 변수는 지역 스코프를 갖는 지역 변수가 됩니다. 전역 스코프를 갖는 전역 변수는 전역(코드 어디서든지)에서 참조할 수 있고 지역(함수 내부)에서 선언된 지역 변수는 그 지역과 그 지역의 하부 지역에서만 참조할 수 있습니다.

### 전역 스코프
전역에 변수를 선언하면 이 변수는 어디서든지 참조할 수 있는 전역 스코프를 갖는 전역 변수가 됩니다. var 키워드로 선언한 전역 변수는 전역 객체(Global Object) window의 프로퍼티입니다. 프로그램의 대부분의 문제는 전역 변수로 인해 발생합니다. 전역 변수는 간단한 애플리케이션의 경우, 사용이 편리하다는 장점이 있지만 불가피한 상황을 제외하고 사용을 억제해야 합니다. 이유는, 전역 변수는 유효 범위(scope)가 넓어서 어디에서 어떻게 사용될 것인지 파악하기 힘들며, 비순수 함수(Impure function)에 의해 의도하지 않게 변경될 수도 있어서 복잡성을 증가시키는 원인 및 변수이름이 중복되어 의도치 않은 재할당에 의한 상태 변화로 코드를 예측하기 어렵게 만들기기 때문입니다. 따라서 변수의 스코프는 좁을수록 좋습니다.


참고) var키워드의 특징
- 함수 레벨 스코프(Function-level scope)
- var 키워드 생략 허용: 암묵적 전역 변수를 양산할 가능성이 크다.
- 변수 중복 선언 허용: 의도하지 않은 변수값의 변경이 일어날 가능성이 크다.
- 변수 호이스팅: 변수를 선언하기 이전에 참조할 수 있다.


### 지역 스코프
함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있습니다. var 키워드는 함수레벨 스코프를, let 키워드로 선언된 변수는 블록 레벨 스코프를 따릅니다. 위

```js


let foo = 123; // 전역 변수

{
  let foo = 456; // 지역 변수
  let bar = 456; // 지역 변수
}

console.log(foo); // 123
console.log(bar); // ReferenceError: bar is not defined
```

## 자바스크립트 스코프의 특징
대부분의 프로그래밍 언어는 블록 레벨 스코프(Block-level scope)를 따르지만 자바스크립트는 함수 레벨 스코프(Function-level scope)를 따릅니다. 대부분의 언어들은 블록레벨스코프를 가지고 있습니다. 자바스크립트의 특징은 이와는 다르게 함수레벨스코프를 가진다는 점입니다. 함수레벨스코프란, 함수코드 블록내에서 선언된 변수는 함수코드블록 내에서만 유효하고 함수외부에서는 유효하지 않다는 점입니다. 함수안에 하위블록 예를들면 for문이나 if문 등에서는 스코프의 범위가 해당 구문의 블록이 아닌, 구문을 포함하는 함수블록이 된다는 점 입니다. 단, ECMAScript 6에서 도입된 let keyword를 사용하면 블록 레벨 스코프를 사용할 수 있습니다.


다음에서 x는 전역변수입니다.
```js
if (true) {
  var x = 5;
}
console.log(x);
```


### 함수레벨 스코프 범위
다음 함수레벨 스코프의 범위 입니다.

```js
var a = 10;     // 전역변수

(function () {
  var b = 20;   // 지역변수
})();

console.log(a); // 10
console.log(b); // "b" is not defined
```

### 전역변수와 지역변수가 중복으로 선언된 경우
```js
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x);
}

foo();          // local
console.log(x); // global
```
전역변수 x와 지역변수 x가 중복 선언되었으나 전역 영역에서는 전역변수만이 참조 가능하고 함수 내 지역 영역에서는 전역과 지역 변수 모두 참조 가능하나 위 예제와 같이 변수명이 중복된 경우, 지역변수를 우선하여 참조하게 됩니다.

### 함수내에 존재하는 함수
내부함수는 자신을 포함하고 있는 외부함수의 변수에 접근할 수 있습니다. 이는 매우 유용합니다. 클로저에서와 같이 내부함수가 더 오래 생존하는 경우, 타 언어와는 다른 움직임을 보입니다. 함수 bar에서 참조하는 변수 x는 함수 foo에서 선언된 지역변수입니다. 이는 `실행 컨텍스트의 스코프 체인에 의해 참조 순위`에서 전역변수 x보다 foo함수의 x의 우선순위가 높기 때문입니다. 중첩 스코프는 가장 인접한 지역을 우선하여 참조한다.


```js
var x = 'global';

function foo() {
  var x = 'local';
  console.log(x); // local

  function bar() {  // 내부함수
    console.log(x); // local
  }

  bar();
}
foo();
console.log(x); // global
```

함수(지역) 영역에서 전역변수를 참조할 수 있으므로 전역변수의 값도 변경할 수 있습니다. 내부 함수의 경우, 전역변수는 물론 상위 함수에서 선언한 변수에 접근/변경이 가능합니다.
```js
var x = 10;

function foo() {
  x = 100;
  console.log(x); // 100
}
foo();
console.log(x); // 100

```

## 동적 스코프와 렉시컬 스코프
다음을 예측해보자.


```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // x=?
bar(); // x=?
```

x의 값은, 함수 bar의 상위 스코프가 무엇인지에 따라 결정된다. 두가지 패턴을 예측할 수 있는데 

- 첫번째는 함수를 `어디서 호출`하였는지에 따라 상위 스코프를 결정하는 것 -> 동적 스코프 (이때 상위 스코프는 함수 bar의 상위 스코프는 함수 foo와 전역)
- 중요!!) 두번째는 함수를 `어디서 선언`하였는지에 따라 상위 스코프를 결정하는 것 -> 렉시컬 스코프 (이때 상위 스코프는 함수 bar의 스코프는 전역)

즉, 변수는 그들의 렉시컬(어휘적) 환경에 포함될 때 생성되지만, 어휘적 바인딩이 실행되기 전까지는 액세스할 수 없습니다.

### 렉시컬 스코프
자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따릅니다. 렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정됩니다. 자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정되비니다. 함수를 어디에서 호출하였는지는 스코프 결정에 아무런 의미를 주지 않습니다. 위 예제의 함수 bar는 전역에 선언되었습니다. 따라서 함수 bar의 상위 스코프는 전역 스코프이고 위 예제는 전역 변수 x의 값 1을 두번 출력합니다.



## 정리
- 동적 스코프(Dynamic scope): 함수를 `어디서 호출`하였는지에 따라 상위 스코프를 결정하는 것
- 렉시컬 스코프(Lexical scope) 또는 정적 스코프(Static scope): 함수를 `어디서 선언`하였는지에 따라 상위 스코프를 결정하는 것
- 함수 레벨 스코프(Function-level scope): 함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.
- 블록 레벨 스코프(Block-level scope): 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 내에서 선언된 변수는 코드 블록 내에서만 유효하며 코드 블록 외부에서는 참조할 수 없다. 즉, 코드 블록 내부에서 선언한 변수는 지역 변수이다.


----
해당 내용은 다음 글을 참고 하였습니다.
- https://poiemaweb.com/js-scope
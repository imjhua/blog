---
layout: post
title: Javascript 기본 개념
tags:
  - javascript
categories: Javascript
---


## 소개
자바스크립트는 객체 기반의 스크립트 프로그래밍 언어입니다. 인터프리팅 방식을 사용하고, C++이나 자바같은 정적인(Static) 언어가 아니라 동적 언어로 타입을 명시할 필요가 없는 인터프리터 언어입니다. 그렇기 때문에 보다 유연하며 추상화(abstraction)나 위임(delegation) 등의 메커니즘이 프로토타입(prototype) 객체나 함수를 통해 구현이 가능합니다. 작고 빠르기 때문에 웹문서를 동적으로 꾸밀 때 가장 널리 쓰여 웹 브라우저 내에서 주로 사용합니다. 자바스크립트는 HTML과 CSS로 만들어진 정적인 페이지를 동적인 페이지로 만들 수 있습니다. HTML과 CSS와 결합외어 웹페이지 상에 올려진 후, 브라우저의 자바스크립트 엔진(인터프리터기)에 의해 실행(이말인 즉슨 브라우저 자바스크립트 엔진 버전에 따라 최신 문법이 호환될수도 있고 되지 않을 수도 있음을 의미함) 됩니다. 현재에는 웹 애플리케이션, 웹서버(nodejs)와 함께 클라이언트 웹페이지를 동시에 구현할 수 있는 수준까지 발전되었습니다. 웹 개발의 핵심 기술인 javascripts의 기본 개념들을 정리해봅시다. 

## 기본 개념
자바스크립트의 기본 개념으로는 프로토타입, 실행 컨텍스트, 일급객체 함수, 호이스팅, 실행 컨텍스트, 클로저, 스코프(유효범위) 체인 등이 있습니다. 앞으로 자세히 살펴 봅시다.

### 프로토타입 기반 프로그래밍
프로토타입 기반 프로그래밍 이란 객체의 원형인 프로토타입을 이용하여 새로운 객체를 만들어내는 프로그래밍 기법을 의미합니다. 자바스크립트는 클래스라는 개념이 없습니다. 그래서 기존 객체를 복사하여 새로운 객체를 생성하는데 그렇기 때문에 프로토타입 기반언어라고도 불리웁니다. 프로토타입 기반 언어는 객체 원형인 프로토타입을 이용하여 새로운 객체를 만들어 내는데 이 또한 또 다른 객체의 원형이 될 수 있습니다. 프로토타입 기반으로 만들어진 객체 역시 자기자신의 프로토타입을 갖게 됩니다. 프로토 타입은 객체를 확장하고 객체지향 프로그래밍이 가능하도록 합니다. prototype에 저장된 속성들은 생성자를 통해서 객체가 만들어질 때 그 객체에 연결됩니다. 

이 새로운 객체의 원형을 이용하면 또 다른 새로운 객체를 만들어 낼수도 있으며 이런 구조로 객체를 확장하는 방식을 프로토타입 기반 프로그래밍이라고 합니다.

### 프로토타입 객체의 속성 
Prototype Object는 일반적인 객체와 같으며 기본적인 속성으로 constructor와 ____proto__를__ 가지고 있습니다.
- constructor: 생성자로써, 자신을 만들어낸 객체와 연결된 속성
- ____proto____: 상위 객체. 객체를 만들어내기 위해 사용된 객체원형에 대한 숨겨진 연결. 자신을 만들어낸 객체의 원형(Prototype Link)
- prototype: 자기 자신. 자신을 통해 만들어질 객체의 원형(Prototype Object)

#### prototype 프로퍼티
prototype 프로퍼티는 객체가 생성될 당시 만들어지는 객체 자신의 원형이될 prototype 객체를 가리킵니다. prototype이 원형이라는 뜻이니, 결국 자기자신의 원형을 가르키는 속성이 prototype입니다. 자기 자신을 가리키는 속성입니다. 이 뜻은 앞으로도 자신을 통해 만들어질 객체들이 원형으로 사용할 객체를 의미하고 자신을 원형으로 만들어질 다른 객체가 참조할 프로토타입이 됩니다. 자신을 원형으로 만들어질 새로운 객체들 즉 하위로 물려줄 연결에 대한 속성입니다.

#### ____proto____
객체를 만들어내기 위해 사용된 객체원형에 대한 숨겨진 연결(Link)입니다. 자신이 상속받은 상위객체, 객체원형(부모)을 의미합니다. 상위에서 물려받은 객체의 프로토타입에 대한 정보가 있습니다.


### 프로토타입 체인
객체의 생성 과정에서 모태가 되는 프로토타입과의 연결고리가 이어져 상속관계를 통하여 상위 프로토타입으로 연속해서 이어지는 관계를 프로토타입 체인이라고 한다. 이 연결은 상위에서 물려받은 객체의 프로토타입에 대한 정보를 담고 있는 ____proto____ 프로퍼티를 따라 찾아 갈 수 있습니다.

즉, 프로토타입 체인이란 위에서 봤던 프로토타입을 상속해서 만들어지는 객체들관의 연관관계를 의미합니다. ____proto____ 프로퍼티들간 이어진 점선을 타고 가다보면 최종적으로 Object 객체의 prototype Object에 다다르게 됩니다. 자바스크립트의 모든 객체는 Object 객체에서부터 파생되어 나온 자식들이기 때문입니다. 이러한 프로토타입 체인은 하위 객체에서 상위객체의 프로퍼티와 메소드를 상속받습니다. 그리고 동일한 이름의 프로퍼티와 메소드를 재정의 하지 않는 이상 상위에서 정의한 내용을 그대로 물려받게 됩니다. 하위 객체는 상위 객체의 속성과 메소드를 상속 받는 것이 아니라 그것을 공유하고 있는 것입니다.


### 실행 문맥(Excution Context)
실행 컨텍스트는 자바스크립트 코드 블럭이 실행되는 환경을 말합니다. 스코프(scope), 호이스팅(hoisting), this, function, 클로저(closure) 등의 동작원리를 담고 있는 자바스크립트의 핵심 원리이기도 합니다. ECMAScript 스팩에 따르면 실행 컨텍스트를 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 정의합니다. 즉, 실행컨텍스틀는 실행 가능한 코드가 실행되기 위해 필요한 환경이라고 할 수 있습니다. 자바스크립트 엔진은 코드를 실행하기 위히여 실행에 필요한 여러가지 정보(전역변수, 지역변수, 매개변수, 변수 선언, 변수의 유효범위, this 등)를 알고 있기 위해 이러한 정보를 형상화하고 구분하기 위해 실행 컨텍스트를 물리적 객체의 형태로 관리 합니다. 

함수 실행시, 실행 문맥 생성과정은 다음과 같습니다. 크게 실행문맥 생성과정(1~5)과 코드 실행 과정(6~7)으로 나뉩니다.
1. 함수를 실행할 코드를 찾는다
2. 함수를 실행하기전에 실행문맥을 만든다
3. 생성과정을 시작한다. - 활성 객체 (컨텍스트에서 실행에 필요한 정보들을 담고 있음)
- 스코프체인 초기화 또는 생성
- 변수 객체(Valiable Object) 생성: 매개변수의 정보를 저장하고 있는 arguments 객체 생성
- 함수가 가지고 있는 변수 및 객체 정보를 생성
- this 값 결정
5. 코드 실행화정 실행 
- 줄 마다 문맥안의 함수 코드를 실행하고 변수의 값을 할당
6. 함수 실행이 마무리되면 해당 컨텍스트는 사라짐. (클로저 제외) 페이지가 종료되면 전역 컨텍스트가 사라짐.

참고) 활성 객체에는 이 함수가 가지고 있는 파라미터나 변수, 객체 등에 대한 정보가 저장된다. 또한 다른 스코프에서 이 실행 컨텍스트를 참조할 땐 저 활성 객체를 참조 하게 된다. 함수 실행시에는 사용되는 변수들을 변수객체 안에서 값을 찾고, 없다면 스코프 체인을 따라 올라가며 찾는다.

### 실행 문맥 
자바스크립트의 실행 문맥은 크게 다음 3가지의 컴포넌트로 나누어 집니다.
1. 렉시컬 환경 컴포넌트(LexicalEnvironment)
2. 변수 환경 컴포넌트(VariableEnvironment)
3. 디스 바인딩 컴포넌트(This Binding)

렉시컬 환경 컴포넌트와 변수 환경 컴포넌트는 타입이 같고 with 문을 사용할 때를 제외하면 내부 값이 똑같다고 알려져있습니다. 디스 바인딩 컴포넌트의 경우, this는 함수가 실행되었을 때 그 함수가 속해 있던 객체를 참조합니다.


### 일급객체 함수
자바스크립트에서 함수는 일급 객체입니다. 다음 조건을 만족하면 일급 객체의 조건을 만족 할 수 있습니다.
- 변수(variable)나 데이터 구조에 담을 수 있다. (할당)
- 인자(parameter)로 전달할 수 있다.
- 반환값(return value)으로 전달할 수 있다.

다음을 추가로 만족하면 일급 함수가 됩니다.
- 런타임(runtime) 생성이 가능하다
- 익명(anonymous)으로 생성이 가능하다

따라서 자바스크립트에서 함수는 일급 객체 이면서 동시에 일급 함수입니다. 변수나 데이터 구조 안에 담을 수 있으며 인자로 전달 할 수 있고 반환값으로도 사용할수 있으며 런타임에 생성 가능 합니다. 

자바스크립트에서 함수가 일급객체 인것이 중요한 이유는 고차 함수(Higher-Order Function: HOF)가 가능하다는 것 입니다. 고차 함수는 함수를 인자로 받거나 결과로 반환하는 함수로서 이같은 조건에 부합하려면 무조건 일급 객체여야만 합니다. 함수를 인자로 받는 것을 흔히 콜백(callback)이라고 하며 이를 통해 되돌려지기가 가능하게 됩니다. 즉, 함수의 흐름을 제어 하는 등 비동기적인 실행 맥락을 처리 할 때 유용합니다. 여러 함수들이 반복적으로 가지고 있는 기능들을 고차 함수에 정의해 두고, 나머지 디테일한 기능은 인자로 넣는 콜백함수를 통해 중복되는 부분을 줄이면서 가독성을 높일 수 있습니다. 함수를 반환하는 고차 힘수를 이용하면 필요할떄 재활용 할 수 있는 함수를 만들 수 있습니다.

### 호이스팅
코드 구현 위치와 상관 없이 브라우저가 자바스크립트를 해석 할때 맨 위로 끌어 올리는 현상으로 메모리 할당을 우선적으로 해 줍니다.

### 함수의 종류(함수 선언식vs함수 표현식)
자바스트립트에서 함수는 두가지 중요한 개념이 있습니다. 바로 함수 선언식과 함수 표현식입니다. 

#### 함수 선언식
함수 선언식은 함수의 문장으로써 실행 가능한 코드 블럭이 아니며, 함수의 정의를 나타내는 문장으로 해석됩니다. 때문에 수행결과가 존재 하지 않습니다. 이러한 이유료 함수 선언을 클래스(class)와 동일한 개념으로 이해 할 수 있습니다. 

#### 함수 표현식
함수 표현식은 함수리터럴로 특정변수에 할당되거나 즉시 실행 가능한 코드 블럭으로서 존재하는 함수입니다. 이때 즉시 실행 가능한 코드 블럭으로 존재하는 함수를 즉시함수호출(IIFE) 또는 자기 호출 함수라고 하는데, 이를 통해 블록 스코프를 흉내 낼 수 있습니다. ES6 이전 (let이 없을 때) 블록 레벨 스코프는 존재하지 않았는데 이를 흉내 낼 수 있는 방법으로 익명함수를 정의 하고 바로 호출하는 방법입니다. 함수 표현이 실행 코드로 해석되기 위하여(변수에 할당하지 않지만 함수 선언식이 아닌 표현식으로 인식 될 수 있도록) 괄호로 묶어 주어야 합니다. 괄호로 묶어 주지 않으면 함수 선언의 시작으로 인식하여 에러가 발생하게 됩니다. 코드 블럭으로서 존재하는 함수 표현식은 해석과 동시에 실행되는 코드 블록이 됩니다. 

두 함수모두 함수 호출 방법에는 큰 차이가 없으나 호이스팅과 관련하여 가장 큰 차이가 있는데, 함수 표현식(var로 할당)은 호이스팅에 영향을 받지 않지만 함수 선언식은 호이스팅에 영향을 받는 다는 점입니다. 즉, 함수 선언식은 호이스팅에 의해 다른 코드보다 먼저 읽고 실행 됩니다. 할당 구문인 함수 표현식은 런타임 과정이 이루어지기 때문에 호이스팅 되지 않습니다.

정리하자면, 
- 함수 선언식은 호이스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않는다. 
- 함수 선언식은 코드를 구현한 위치와 관계없이 자바스크립트의 특징인 호이스팅에 따라 브라우저가 자바스크립트를 해석할 때 맨 위로 끌어 올려진다.

### 스코프(유효범위)
ES6 전까지 자바스크립트는 전통적으로 함수 레벨 스코프를 지원하였습니다. 블록 레벨 스코프는 지원하지 않았습니다. 자바스크립트에서 스코프의 특징은 함수 호출시점이 아닌 선언된 시점을 기준으로 유효범위를 갖는다는 것인데 외부/내부함수가 아닌 경우, 함수가 또 다른 함수를 호출한다고 했을 때 또 다른 함수에서 이전 함수의 지역변수를 사용한다 하더라도 선언시점에는 그 관계를 모르기 때문에 최초 선언된 전역 변수의 값을 갖게 됩니다. 

#### 함수 레벨 스코프
var키워드로 선언된 변수나 함수 선언식으로 만들어진 함수는 함수 레벨 스코프를 가집니다.

#### 블록 레벨 스코프
ES6에서 지원하는 let키워드를 통해 선언하면 블록 레벨 스코프를 가집니다. 블록 내부에서는 참조가 가능하며 그 밖의 영역에서 참조 할 경우 에러가 발생합니다. 


#### 렉시컬 스코프(Lexical scope)
렉시컬 스코프는 정적 스코프 라고도 하며 동적 스코프와는 반대 되는 개념입니다. 동적 스코프는 프로그램의 런타임 도중의 실행 컨텍스트나 호출 컨텍스트에 의해 결정됩니다. 렉시컬 스코프는 소스코드가 작성된 그 문맥에서 결정되는 유효 범위로써 현대 프로그래밍에서 대부분의 언어들은 렉시컬 스코프 규칙을 따릅니다. 렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정됩니다. 함수를 처음 선언하는 순간, 함수 내부의 변수는 자기 스코프로부터 가장 가까운 곳에 있는 변수를 참고 하게 됩니다. 변수 선언시 가장 가까운 스코프가 전역 변수라면 전역 변수를 참조 하게 됩니다. 

이때 함수 실행시의 this는 실행 문맥(함수가 작성 됐을때가 아닌 실행 당시의 문맥)에 의하여 함수를 소유하고 있는 객체를 가리키게 되는데 런타임에서 객체 내부의 속성으로 정의된 함수가 실행 될때, this는 함수가 아닌 객체를 참조 합니다. es6에 새롭게 추가된 화살표 함수는 렉시컬 스코프를 갖기 때문에 새롭게 만들어진 객체(인스턴스)가 아닌 당시 문맥에 의한 상위 객체를 가르키게 됩니다. 따라서 기존의 메소드 정의 방법과 화살표 정의 방법 구분하여 사용하는데 주의해야 합니다. (참고. 실행문맥 3가지 환경)


### 스코프 체인
전역변수와 지역변수의 개념에서 나옵니다. 내부 함수에서는 외부함수의 변수에 접근이 가능하지만 외부함수에서는 내부함수의 변수에 접근 할 수 없습니다. 변수의 값은 먼저 자기 자신의 스코프에서 찾고 점점 위로 올라가 상위 스코프를 찾으며 마지막으로는 전역 스코프에서 값을 찾게 됩니다.

### 클로저
클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수를 말합니다. 이로써 내부함수가 외부함수의 데이터에 접근하게 됩니다. 다른 함수의 스코프에 있는 변수에 접근 가능한 함수라고도 하며 함수의 부모 함수의 범위에 대한 접근성을 제공하는 것을 뜻하기도 합니다. 이미 스코프 체인이 결정된 이후에 전역에서 함수를 호출할 지라도 호출되는 함수는 이미 결정된 렉시컬 환경에서 변수의 값을 찾습니다. 렉시컬 환경, 렉시컬 스코프는 함수를 둘러싼 환경으로 소스코드가 작성된 그 문맥에서 바로 결정되는 것을 의미합니다. 함수를 만들고 그 함수 내부의 코드가 탐색하는 스코프를 함수 생성 당시의 렉시컬 스코프로 고정하면 바로 클로저가 되는 것입니다. 외부 함수는 호출됨과 동시에 실행 컨텍스트 스택(콜스택)에서 제거 되었으므로 외부 함수의 변수값들은 더 이상 유효하지 않지만, 내부 함수에서 외부 함수의 렉시컬 환경으로 외부 함수의 환경을 참조 했기에 외부 함수의 콜스택이 제거된 이후에도 변수에 접근이 가능한 것입니다. 즉, 자바스크립트에서 클로저는 함수가 생성되는 시점에 생성됩니다. 함수가 생성될 때 그 함수의 렉시컬 환경을 포섭(closure)하여 실행될 때 이용하는 것입니다. 클로저 안에 정의된 함수는 만들어진 환경을 기억합니다. 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수 라고 정의 할 수 있습니다.  외부함수를 실행하면서 생성되는 지역변수 객체는 스코프체인에 들어가게 되고, 내부함수의 스코프 체인으로 참조됩니다. 외부함수는 종료되었지만 여전히 내부함수 스코프 체인으로 참조되므로 가비지 컬렉션의 대상이 되지 않아 여전히 접근이 가능 한 것입니다. 

클로저는 렉시컬 환경을 기억해야 하므로 메모리 차원에서 손해를 볼수 있지만 현재 상태를 유지할 수 있으며, 객체지향 프로그래밍을 한다면 은닉도 쉽게 할수 있다는 장점이 있습니다. 기존 prototype으로 객체를 다루던 자바스크립트에서 클로저를 통해 java처럼 외부에서 특별한 인터페이스를 제공하지 않는 이상 변수에 직접 접근이 힘들게 됩니다. 여러 영역에서 사용되는 변수들의 이름이 서로 충돌해도 오류가 발생하지 않는 문제를 해결할수 있으며 호출 객체를 단위로 캡슐화가 가능합니다. 

주의사항으로는, 가비지 컬렉터가 호출이 끝난 함수를 제거하지 못해서 메모리 낭비와 성능이 떨어지는 현상이 발생 할 수 있습니다. 중첩되는 반복문에서 조심해야 합니다. 


## 마치며
자바스크립트의 동작원리를 이해하기 위한 기본 개념들을 살펴 보았습니다.
